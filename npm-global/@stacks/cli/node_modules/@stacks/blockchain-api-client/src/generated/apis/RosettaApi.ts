/* tslint:disable */
/* eslint-disable */
/**
 * Stacks 2.0 Blockchain API
 * This is the documentation for the Stacks 2.0 Blockchain API.  It is comprised of two parts; the Stacks Blockchain API and the Stacks Core API.  [![Run in Postman](https://run.pstmn.io/button.svg)](https://app.getpostman.com/run-collection/614feab5c108d292bffa#?env%5BStacks%20Blockchain%20API%5D=W3sia2V5Ijoic3R4X2FkZHJlc3MiLCJ2YWx1ZSI6IlNUMlRKUkhESE1ZQlE0MTdIRkIwQkRYNDMwVFFBNVBYUlg2NDk1RzFWIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJibG9ja19pZCIsInZhbHVlIjoiMHgiLCJlbmFibGVkIjp0cnVlfSx7ImtleSI6Im9mZnNldCIsInZhbHVlIjoiMCIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoibGltaXRfdHgiLCJ2YWx1ZSI6IjIwMCIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoibGltaXRfYmxvY2siLCJ2YWx1ZSI6IjMwIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJ0eF9pZCIsInZhbHVlIjoiMHg1NDA5MGMxNmE3MDJiNzUzYjQzMTE0ZTg4NGJjMTlhODBhNzk2MzhmZDQ0OWE0MGY4MDY4Y2RmMDAzY2RlNmUwIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJjb250cmFjdF9pZCIsInZhbHVlIjoiU1RKVFhFSlBKUFBWRE5BOUIwNTJOU1JSQkdRQ0ZOS1ZTMTc4VkdIMS5oZWxsb193b3JsZFxuIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJidGNfYWRkcmVzcyIsInZhbHVlIjoiYWJjIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJjb250cmFjdF9hZGRyZXNzIiwidmFsdWUiOiJTVEpUWEVKUEpQUFZETkE5QjA1Mk5TUlJCR1FDRk5LVlMxNzhWR0gxIiwiZW5hYmxlZCI6dHJ1ZX0seyJrZXkiOiJjb250cmFjdF9uYW1lIiwidmFsdWUiOiJoZWxsb193b3JsZCIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoiY29udHJhY3RfbWFwIiwidmFsdWUiOiJzdG9yZSIsImVuYWJsZWQiOnRydWV9LHsia2V5IjoiY29udHJhY3RfbWV0aG9kIiwidmFsdWUiOiJnZXQtdmFsdWUiLCJlbmFibGVkIjp0cnVlfV0=) 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    RosettaAccountBalanceRequest,
    RosettaAccountBalanceRequestFromJSON,
    RosettaAccountBalanceRequestToJSON,
    RosettaAccountBalanceResponse,
    RosettaAccountBalanceResponseFromJSON,
    RosettaAccountBalanceResponseToJSON,
    RosettaBlockRequest,
    RosettaBlockRequestFromJSON,
    RosettaBlockRequestToJSON,
    RosettaBlockResponse,
    RosettaBlockResponseFromJSON,
    RosettaBlockResponseToJSON,
    RosettaBlockTransactionRequest,
    RosettaBlockTransactionRequestFromJSON,
    RosettaBlockTransactionRequestToJSON,
    RosettaBlockTransactionResponse,
    RosettaBlockTransactionResponseFromJSON,
    RosettaBlockTransactionResponseToJSON,
    RosettaConstructionCombineRequest,
    RosettaConstructionCombineRequestFromJSON,
    RosettaConstructionCombineRequestToJSON,
    RosettaConstructionCombineResponse,
    RosettaConstructionCombineResponseFromJSON,
    RosettaConstructionCombineResponseToJSON,
    RosettaConstructionDeriveRequest,
    RosettaConstructionDeriveRequestFromJSON,
    RosettaConstructionDeriveRequestToJSON,
    RosettaConstructionDeriveResponse,
    RosettaConstructionDeriveResponseFromJSON,
    RosettaConstructionDeriveResponseToJSON,
    RosettaConstructionHashRequest,
    RosettaConstructionHashRequestFromJSON,
    RosettaConstructionHashRequestToJSON,
    RosettaConstructionHashResponse,
    RosettaConstructionHashResponseFromJSON,
    RosettaConstructionHashResponseToJSON,
    RosettaConstructionMetadataRequest,
    RosettaConstructionMetadataRequestFromJSON,
    RosettaConstructionMetadataRequestToJSON,
    RosettaConstructionMetadataResponse,
    RosettaConstructionMetadataResponseFromJSON,
    RosettaConstructionMetadataResponseToJSON,
    RosettaConstructionParseRequest,
    RosettaConstructionParseRequestFromJSON,
    RosettaConstructionParseRequestToJSON,
    RosettaConstructionParseResponse,
    RosettaConstructionParseResponseFromJSON,
    RosettaConstructionParseResponseToJSON,
    RosettaConstructionPayloadResponse,
    RosettaConstructionPayloadResponseFromJSON,
    RosettaConstructionPayloadResponseToJSON,
    RosettaConstructionPayloadsRequest,
    RosettaConstructionPayloadsRequestFromJSON,
    RosettaConstructionPayloadsRequestToJSON,
    RosettaConstructionPreprocessRequest,
    RosettaConstructionPreprocessRequestFromJSON,
    RosettaConstructionPreprocessRequestToJSON,
    RosettaConstructionPreprocessResponse,
    RosettaConstructionPreprocessResponseFromJSON,
    RosettaConstructionPreprocessResponseToJSON,
    RosettaConstructionSubmitRequest,
    RosettaConstructionSubmitRequestFromJSON,
    RosettaConstructionSubmitRequestToJSON,
    RosettaConstructionSubmitResponse,
    RosettaConstructionSubmitResponseFromJSON,
    RosettaConstructionSubmitResponseToJSON,
    RosettaError,
    RosettaErrorFromJSON,
    RosettaErrorToJSON,
    RosettaMempoolRequest,
    RosettaMempoolRequestFromJSON,
    RosettaMempoolRequestToJSON,
    RosettaMempoolResponse,
    RosettaMempoolResponseFromJSON,
    RosettaMempoolResponseToJSON,
    RosettaMempoolTransactionRequest,
    RosettaMempoolTransactionRequestFromJSON,
    RosettaMempoolTransactionRequestToJSON,
    RosettaMempoolTransactionResponse,
    RosettaMempoolTransactionResponseFromJSON,
    RosettaMempoolTransactionResponseToJSON,
    RosettaNetworkListResponse,
    RosettaNetworkListResponseFromJSON,
    RosettaNetworkListResponseToJSON,
    RosettaNetworkOptionsResponse,
    RosettaNetworkOptionsResponseFromJSON,
    RosettaNetworkOptionsResponseToJSON,
    RosettaOptionsRequest,
    RosettaOptionsRequestFromJSON,
    RosettaOptionsRequestToJSON,
    RosettaStatusRequest,
    RosettaStatusRequestFromJSON,
    RosettaStatusRequestToJSON,
} from '../models';

export interface RosettaAccountBalanceOperationRequest {
    rosettaAccountBalanceRequest: RosettaAccountBalanceRequest;
}

export interface RosettaBlockOperationRequest {
    rosettaBlockRequest: RosettaBlockRequest;
}

export interface RosettaBlockTransactionOperationRequest {
    rosettaBlockTransactionRequest: RosettaBlockTransactionRequest;
}

export interface RosettaConstructionCombineOperationRequest {
    rosettaConstructionCombineRequest: RosettaConstructionCombineRequest;
}

export interface RosettaConstructionDeriveOperationRequest {
    rosettaConstructionDeriveRequest: RosettaConstructionDeriveRequest;
}

export interface RosettaConstructionHashOperationRequest {
    rosettaConstructionHashRequest: RosettaConstructionHashRequest;
}

export interface RosettaConstructionMetadataOperationRequest {
    rosettaConstructionMetadataRequest: RosettaConstructionMetadataRequest;
}

export interface RosettaConstructionParseOperationRequest {
    rosettaConstructionParseRequest: RosettaConstructionParseRequest;
}

export interface RosettaConstructionPayloadsOperationRequest {
    rosettaConstructionPayloadsRequest: RosettaConstructionPayloadsRequest;
}

export interface RosettaConstructionPreprocessOperationRequest {
    rosettaConstructionPreprocessRequest: RosettaConstructionPreprocessRequest;
}

export interface RosettaConstructionSubmitOperationRequest {
    rosettaConstructionSubmitRequest: RosettaConstructionSubmitRequest;
}

export interface RosettaMempoolOperationRequest {
    rosettaMempoolRequest: RosettaMempoolRequest;
}

export interface RosettaMempoolTransactionOperationRequest {
    rosettaMempoolTransactionRequest: RosettaMempoolTransactionRequest;
}

export interface RosettaNetworkOptionsRequest {
    rosettaOptionsRequest: RosettaOptionsRequest;
}

export interface RosettaNetworkStatusRequest {
    rosettaStatusRequest: RosettaStatusRequest;
}

/**
 * RosettaApi - interface
 * 
 * @export
 * @interface RosettaApiInterface
 */
export interface RosettaApiInterface {
    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * @summary Get an Account Balance
     * @param {RosettaAccountBalanceRequest} rosettaAccountBalanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaAccountBalanceRaw(requestParameters: RosettaAccountBalanceOperationRequest): Promise<runtime.ApiResponse<RosettaAccountBalanceResponse>>;

    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * Get an Account Balance
     */
    rosettaAccountBalance(requestParameters: RosettaAccountBalanceOperationRequest): Promise<RosettaAccountBalanceResponse>;

    /**
     * A BlockRequest is utilized to make a block request on the /block endpoint.
     * @summary Get a Block
     * @param {RosettaBlockRequest} rosettaBlockRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaBlockRaw(requestParameters: RosettaBlockOperationRequest): Promise<runtime.ApiResponse<RosettaBlockResponse>>;

    /**
     * A BlockRequest is utilized to make a block request on the /block endpoint.
     * Get a Block
     */
    rosettaBlock(requestParameters: RosettaBlockOperationRequest): Promise<RosettaBlockResponse>;

    /**
     * A BlockTransactionRequest is used to fetch a Transaction included in a block that is not returned in a BlockResponse.
     * @summary Get a Block Transaction
     * @param {RosettaBlockTransactionRequest} rosettaBlockTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaBlockTransactionRaw(requestParameters: RosettaBlockTransactionOperationRequest): Promise<runtime.ApiResponse<RosettaBlockTransactionResponse>>;

    /**
     * A BlockTransactionRequest is used to fetch a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    rosettaBlockTransaction(requestParameters: RosettaBlockTransactionOperationRequest): Promise<RosettaBlockTransactionResponse>;

    /**
     * Take unsigned transaction and signature, combine both and return signed transaction
     * @summary Create Network Transaction from Signatures
     * @param {RosettaConstructionCombineRequest} rosettaConstructionCombineRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionCombineRaw(requestParameters: RosettaConstructionCombineOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionCombineResponse>>;

    /**
     * Take unsigned transaction and signature, combine both and return signed transaction
     * Create Network Transaction from Signatures
     */
    rosettaConstructionCombine(requestParameters: RosettaConstructionCombineOperationRequest): Promise<RosettaConstructionCombineResponse>;

    /**
     * TODO
     * @summary Derive an AccountIdentifier from a PublicKey
     * @param {RosettaConstructionDeriveRequest} rosettaConstructionDeriveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionDeriveRaw(requestParameters: RosettaConstructionDeriveOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionDeriveResponse>>;

    /**
     * TODO
     * Derive an AccountIdentifier from a PublicKey
     */
    rosettaConstructionDerive(requestParameters: RosettaConstructionDeriveOperationRequest): Promise<RosettaConstructionDeriveResponse>;

    /**
     * TODO
     * @summary Get the Hash of a Signed Transaction
     * @param {RosettaConstructionHashRequest} rosettaConstructionHashRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionHashRaw(requestParameters: RosettaConstructionHashOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionHashResponse>>;

    /**
     * TODO
     * Get the Hash of a Signed Transaction
     */
    rosettaConstructionHash(requestParameters: RosettaConstructionHashOperationRequest): Promise<RosettaConstructionHashResponse>;

    /**
     * TODO
     * @summary Get Metadata for Transaction Construction
     * @param {RosettaConstructionMetadataRequest} rosettaConstructionMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionMetadataRaw(requestParameters: RosettaConstructionMetadataOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionMetadataResponse>>;

    /**
     * TODO
     * Get Metadata for Transaction Construction
     */
    rosettaConstructionMetadata(requestParameters: RosettaConstructionMetadataOperationRequest): Promise<RosettaConstructionMetadataResponse>;

    /**
     * TODO
     * @summary Parse a Transaction
     * @param {RosettaConstructionParseRequest} rosettaConstructionParseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionParseRaw(requestParameters: RosettaConstructionParseOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionParseResponse>>;

    /**
     * TODO
     * Parse a Transaction
     */
    rosettaConstructionParse(requestParameters: RosettaConstructionParseOperationRequest): Promise<RosettaConstructionParseResponse>;

    /**
     * Generate and unsigned transaction from operations and metadata
     * @summary Generate an Unsigned Transaction and Signing Payloads
     * @param {RosettaConstructionPayloadsRequest} rosettaConstructionPayloadsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionPayloadsRaw(requestParameters: RosettaConstructionPayloadsOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionPayloadResponse>>;

    /**
     * Generate and unsigned transaction from operations and metadata
     * Generate an Unsigned Transaction and Signing Payloads
     */
    rosettaConstructionPayloads(requestParameters: RosettaConstructionPayloadsOperationRequest): Promise<RosettaConstructionPayloadResponse>;

    /**
     * TODO
     * @summary Create a Request to Fetch Metadata
     * @param {RosettaConstructionPreprocessRequest} rosettaConstructionPreprocessRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionPreprocessRaw(requestParameters: RosettaConstructionPreprocessOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionPreprocessResponse>>;

    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    rosettaConstructionPreprocess(requestParameters: RosettaConstructionPreprocessOperationRequest): Promise<RosettaConstructionPreprocessResponse>;

    /**
     * Submit a pre-signed transaction to the node.
     * @summary Submit a Signed Transaction
     * @param {RosettaConstructionSubmitRequest} rosettaConstructionSubmitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaConstructionSubmitRaw(requestParameters: RosettaConstructionSubmitOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionSubmitResponse>>;

    /**
     * Submit a pre-signed transaction to the node.
     * Submit a Signed Transaction
     */
    rosettaConstructionSubmit(requestParameters: RosettaConstructionSubmitOperationRequest): Promise<RosettaConstructionSubmitResponse>;

    /**
     * Get all Transaction Identifiers in the mempool.
     * @summary Get All Mempool Transactions
     * @param {RosettaMempoolRequest} rosettaMempoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaMempoolRaw(requestParameters: RosettaMempoolOperationRequest): Promise<runtime.ApiResponse<RosettaMempoolResponse>>;

    /**
     * Get all Transaction Identifiers in the mempool.
     * Get All Mempool Transactions
     */
    rosettaMempool(requestParameters: RosettaMempoolOperationRequest): Promise<RosettaMempoolResponse>;

    /**
     * A MempoolTransactionRequest is utilized to retrieve a transaction from the mempool.
     * @summary Get a Mempool Transaction
     * @param {RosettaMempoolTransactionRequest} rosettaMempoolTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaMempoolTransactionRaw(requestParameters: RosettaMempoolTransactionOperationRequest): Promise<runtime.ApiResponse<RosettaMempoolTransactionResponse>>;

    /**
     * A MempoolTransactionRequest is utilized to retrieve a transaction from the mempool.
     * Get a Mempool Transaction
     */
    rosettaMempoolTransaction(requestParameters: RosettaMempoolTransactionOperationRequest): Promise<RosettaMempoolTransactionResponse>;

    /**
     * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
     * @summary Get List of Available Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaNetworkListRaw(): Promise<runtime.ApiResponse<RosettaNetworkListResponse>>;

    /**
     * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    rosettaNetworkList(): Promise<RosettaNetworkListResponse>;

    /**
     * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * @summary Get Network Options
     * @param {RosettaOptionsRequest} rosettaOptionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaNetworkOptionsRaw(requestParameters: RosettaNetworkOptionsRequest): Promise<runtime.ApiResponse<RosettaNetworkOptionsResponse>>;

    /**
     * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * Get Network Options
     */
    rosettaNetworkOptions(requestParameters: RosettaNetworkOptionsRequest): Promise<RosettaNetworkOptionsResponse>;

    /**
     * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * @summary Get Network Status
     * @param {RosettaStatusRequest} rosettaStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RosettaApiInterface
     */
    rosettaNetworkStatusRaw(requestParameters: RosettaNetworkStatusRequest): Promise<runtime.ApiResponse<{ [key: string]: object; }>>;

    /**
     * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * Get Network Status
     */
    rosettaNetworkStatus(requestParameters: RosettaNetworkStatusRequest): Promise<{ [key: string]: object; }>;

}

/**
 * 
 */
export class RosettaApi extends runtime.BaseAPI implements RosettaApiInterface {

    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * Get an Account Balance
     */
    async rosettaAccountBalanceRaw(requestParameters: RosettaAccountBalanceOperationRequest): Promise<runtime.ApiResponse<RosettaAccountBalanceResponse>> {
        if (requestParameters.rosettaAccountBalanceRequest === null || requestParameters.rosettaAccountBalanceRequest === undefined) {
            throw new runtime.RequiredError('rosettaAccountBalanceRequest','Required parameter requestParameters.rosettaAccountBalanceRequest was null or undefined when calling rosettaAccountBalance.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/account/balance`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaAccountBalanceRequestToJSON(requestParameters.rosettaAccountBalanceRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaAccountBalanceResponseFromJSON(jsonValue));
    }

    /**
     * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed. 
     * Get an Account Balance
     */
    async rosettaAccountBalance(requestParameters: RosettaAccountBalanceOperationRequest): Promise<RosettaAccountBalanceResponse> {
        const response = await this.rosettaAccountBalanceRaw(requestParameters);
        return await response.value();
    }

    /**
     * A BlockRequest is utilized to make a block request on the /block endpoint.
     * Get a Block
     */
    async rosettaBlockRaw(requestParameters: RosettaBlockOperationRequest): Promise<runtime.ApiResponse<RosettaBlockResponse>> {
        if (requestParameters.rosettaBlockRequest === null || requestParameters.rosettaBlockRequest === undefined) {
            throw new runtime.RequiredError('rosettaBlockRequest','Required parameter requestParameters.rosettaBlockRequest was null or undefined when calling rosettaBlock.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/block`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaBlockRequestToJSON(requestParameters.rosettaBlockRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaBlockResponseFromJSON(jsonValue));
    }

    /**
     * A BlockRequest is utilized to make a block request on the /block endpoint.
     * Get a Block
     */
    async rosettaBlock(requestParameters: RosettaBlockOperationRequest): Promise<RosettaBlockResponse> {
        const response = await this.rosettaBlockRaw(requestParameters);
        return await response.value();
    }

    /**
     * A BlockTransactionRequest is used to fetch a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    async rosettaBlockTransactionRaw(requestParameters: RosettaBlockTransactionOperationRequest): Promise<runtime.ApiResponse<RosettaBlockTransactionResponse>> {
        if (requestParameters.rosettaBlockTransactionRequest === null || requestParameters.rosettaBlockTransactionRequest === undefined) {
            throw new runtime.RequiredError('rosettaBlockTransactionRequest','Required parameter requestParameters.rosettaBlockTransactionRequest was null or undefined when calling rosettaBlockTransaction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/block/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaBlockTransactionRequestToJSON(requestParameters.rosettaBlockTransactionRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaBlockTransactionResponseFromJSON(jsonValue));
    }

    /**
     * A BlockTransactionRequest is used to fetch a Transaction included in a block that is not returned in a BlockResponse.
     * Get a Block Transaction
     */
    async rosettaBlockTransaction(requestParameters: RosettaBlockTransactionOperationRequest): Promise<RosettaBlockTransactionResponse> {
        const response = await this.rosettaBlockTransactionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Take unsigned transaction and signature, combine both and return signed transaction
     * Create Network Transaction from Signatures
     */
    async rosettaConstructionCombineRaw(requestParameters: RosettaConstructionCombineOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionCombineResponse>> {
        if (requestParameters.rosettaConstructionCombineRequest === null || requestParameters.rosettaConstructionCombineRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionCombineRequest','Required parameter requestParameters.rosettaConstructionCombineRequest was null or undefined when calling rosettaConstructionCombine.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/combine`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionCombineRequestToJSON(requestParameters.rosettaConstructionCombineRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionCombineResponseFromJSON(jsonValue));
    }

    /**
     * Take unsigned transaction and signature, combine both and return signed transaction
     * Create Network Transaction from Signatures
     */
    async rosettaConstructionCombine(requestParameters: RosettaConstructionCombineOperationRequest): Promise<RosettaConstructionCombineResponse> {
        const response = await this.rosettaConstructionCombineRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Derive an AccountIdentifier from a PublicKey
     */
    async rosettaConstructionDeriveRaw(requestParameters: RosettaConstructionDeriveOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionDeriveResponse>> {
        if (requestParameters.rosettaConstructionDeriveRequest === null || requestParameters.rosettaConstructionDeriveRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionDeriveRequest','Required parameter requestParameters.rosettaConstructionDeriveRequest was null or undefined when calling rosettaConstructionDerive.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/derive`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionDeriveRequestToJSON(requestParameters.rosettaConstructionDeriveRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionDeriveResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Derive an AccountIdentifier from a PublicKey
     */
    async rosettaConstructionDerive(requestParameters: RosettaConstructionDeriveOperationRequest): Promise<RosettaConstructionDeriveResponse> {
        const response = await this.rosettaConstructionDeriveRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Get the Hash of a Signed Transaction
     */
    async rosettaConstructionHashRaw(requestParameters: RosettaConstructionHashOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionHashResponse>> {
        if (requestParameters.rosettaConstructionHashRequest === null || requestParameters.rosettaConstructionHashRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionHashRequest','Required parameter requestParameters.rosettaConstructionHashRequest was null or undefined when calling rosettaConstructionHash.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/hash`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionHashRequestToJSON(requestParameters.rosettaConstructionHashRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionHashResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Get the Hash of a Signed Transaction
     */
    async rosettaConstructionHash(requestParameters: RosettaConstructionHashOperationRequest): Promise<RosettaConstructionHashResponse> {
        const response = await this.rosettaConstructionHashRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Get Metadata for Transaction Construction
     */
    async rosettaConstructionMetadataRaw(requestParameters: RosettaConstructionMetadataOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionMetadataResponse>> {
        if (requestParameters.rosettaConstructionMetadataRequest === null || requestParameters.rosettaConstructionMetadataRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionMetadataRequest','Required parameter requestParameters.rosettaConstructionMetadataRequest was null or undefined when calling rosettaConstructionMetadata.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/metadata`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionMetadataRequestToJSON(requestParameters.rosettaConstructionMetadataRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionMetadataResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Get Metadata for Transaction Construction
     */
    async rosettaConstructionMetadata(requestParameters: RosettaConstructionMetadataOperationRequest): Promise<RosettaConstructionMetadataResponse> {
        const response = await this.rosettaConstructionMetadataRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Parse a Transaction
     */
    async rosettaConstructionParseRaw(requestParameters: RosettaConstructionParseOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionParseResponse>> {
        if (requestParameters.rosettaConstructionParseRequest === null || requestParameters.rosettaConstructionParseRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionParseRequest','Required parameter requestParameters.rosettaConstructionParseRequest was null or undefined when calling rosettaConstructionParse.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/parse`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionParseRequestToJSON(requestParameters.rosettaConstructionParseRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionParseResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Parse a Transaction
     */
    async rosettaConstructionParse(requestParameters: RosettaConstructionParseOperationRequest): Promise<RosettaConstructionParseResponse> {
        const response = await this.rosettaConstructionParseRaw(requestParameters);
        return await response.value();
    }

    /**
     * Generate and unsigned transaction from operations and metadata
     * Generate an Unsigned Transaction and Signing Payloads
     */
    async rosettaConstructionPayloadsRaw(requestParameters: RosettaConstructionPayloadsOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionPayloadResponse>> {
        if (requestParameters.rosettaConstructionPayloadsRequest === null || requestParameters.rosettaConstructionPayloadsRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionPayloadsRequest','Required parameter requestParameters.rosettaConstructionPayloadsRequest was null or undefined when calling rosettaConstructionPayloads.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/payloads`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionPayloadsRequestToJSON(requestParameters.rosettaConstructionPayloadsRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionPayloadResponseFromJSON(jsonValue));
    }

    /**
     * Generate and unsigned transaction from operations and metadata
     * Generate an Unsigned Transaction and Signing Payloads
     */
    async rosettaConstructionPayloads(requestParameters: RosettaConstructionPayloadsOperationRequest): Promise<RosettaConstructionPayloadResponse> {
        const response = await this.rosettaConstructionPayloadsRaw(requestParameters);
        return await response.value();
    }

    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    async rosettaConstructionPreprocessRaw(requestParameters: RosettaConstructionPreprocessOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionPreprocessResponse>> {
        if (requestParameters.rosettaConstructionPreprocessRequest === null || requestParameters.rosettaConstructionPreprocessRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionPreprocessRequest','Required parameter requestParameters.rosettaConstructionPreprocessRequest was null or undefined when calling rosettaConstructionPreprocess.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/preprocess`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionPreprocessRequestToJSON(requestParameters.rosettaConstructionPreprocessRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionPreprocessResponseFromJSON(jsonValue));
    }

    /**
     * TODO
     * Create a Request to Fetch Metadata
     */
    async rosettaConstructionPreprocess(requestParameters: RosettaConstructionPreprocessOperationRequest): Promise<RosettaConstructionPreprocessResponse> {
        const response = await this.rosettaConstructionPreprocessRaw(requestParameters);
        return await response.value();
    }

    /**
     * Submit a pre-signed transaction to the node.
     * Submit a Signed Transaction
     */
    async rosettaConstructionSubmitRaw(requestParameters: RosettaConstructionSubmitOperationRequest): Promise<runtime.ApiResponse<RosettaConstructionSubmitResponse>> {
        if (requestParameters.rosettaConstructionSubmitRequest === null || requestParameters.rosettaConstructionSubmitRequest === undefined) {
            throw new runtime.RequiredError('rosettaConstructionSubmitRequest','Required parameter requestParameters.rosettaConstructionSubmitRequest was null or undefined when calling rosettaConstructionSubmit.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/construction/submit`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaConstructionSubmitRequestToJSON(requestParameters.rosettaConstructionSubmitRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaConstructionSubmitResponseFromJSON(jsonValue));
    }

    /**
     * Submit a pre-signed transaction to the node.
     * Submit a Signed Transaction
     */
    async rosettaConstructionSubmit(requestParameters: RosettaConstructionSubmitOperationRequest): Promise<RosettaConstructionSubmitResponse> {
        const response = await this.rosettaConstructionSubmitRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all Transaction Identifiers in the mempool.
     * Get All Mempool Transactions
     */
    async rosettaMempoolRaw(requestParameters: RosettaMempoolOperationRequest): Promise<runtime.ApiResponse<RosettaMempoolResponse>> {
        if (requestParameters.rosettaMempoolRequest === null || requestParameters.rosettaMempoolRequest === undefined) {
            throw new runtime.RequiredError('rosettaMempoolRequest','Required parameter requestParameters.rosettaMempoolRequest was null or undefined when calling rosettaMempool.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/mempool`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaMempoolRequestToJSON(requestParameters.rosettaMempoolRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaMempoolResponseFromJSON(jsonValue));
    }

    /**
     * Get all Transaction Identifiers in the mempool.
     * Get All Mempool Transactions
     */
    async rosettaMempool(requestParameters: RosettaMempoolOperationRequest): Promise<RosettaMempoolResponse> {
        const response = await this.rosettaMempoolRaw(requestParameters);
        return await response.value();
    }

    /**
     * A MempoolTransactionRequest is utilized to retrieve a transaction from the mempool.
     * Get a Mempool Transaction
     */
    async rosettaMempoolTransactionRaw(requestParameters: RosettaMempoolTransactionOperationRequest): Promise<runtime.ApiResponse<RosettaMempoolTransactionResponse>> {
        if (requestParameters.rosettaMempoolTransactionRequest === null || requestParameters.rosettaMempoolTransactionRequest === undefined) {
            throw new runtime.RequiredError('rosettaMempoolTransactionRequest','Required parameter requestParameters.rosettaMempoolTransactionRequest was null or undefined when calling rosettaMempoolTransaction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/mempool/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaMempoolTransactionRequestToJSON(requestParameters.rosettaMempoolTransactionRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaMempoolTransactionResponseFromJSON(jsonValue));
    }

    /**
     * A MempoolTransactionRequest is utilized to retrieve a transaction from the mempool.
     * Get a Mempool Transaction
     */
    async rosettaMempoolTransaction(requestParameters: RosettaMempoolTransactionOperationRequest): Promise<RosettaMempoolTransactionResponse> {
        const response = await this.rosettaMempoolTransactionRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    async rosettaNetworkListRaw(): Promise<runtime.ApiResponse<RosettaNetworkListResponse>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/rosetta/v1/network/list`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaNetworkListResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
     * Get List of Available Networks
     */
    async rosettaNetworkList(): Promise<RosettaNetworkListResponse> {
        const response = await this.rosettaNetworkListRaw();
        return await response.value();
    }

    /**
     * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * Get Network Options
     */
    async rosettaNetworkOptionsRaw(requestParameters: RosettaNetworkOptionsRequest): Promise<runtime.ApiResponse<RosettaNetworkOptionsResponse>> {
        if (requestParameters.rosettaOptionsRequest === null || requestParameters.rosettaOptionsRequest === undefined) {
            throw new runtime.RequiredError('rosettaOptionsRequest','Required parameter requestParameters.rosettaOptionsRequest was null or undefined when calling rosettaNetworkOptions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/network/options`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaOptionsRequestToJSON(requestParameters.rosettaOptionsRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RosettaNetworkOptionsResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network. 
     * Get Network Options
     */
    async rosettaNetworkOptions(requestParameters: RosettaNetworkOptionsRequest): Promise<RosettaNetworkOptionsResponse> {
        const response = await this.rosettaNetworkOptionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * Get Network Status
     */
    async rosettaNetworkStatusRaw(requestParameters: RosettaNetworkStatusRequest): Promise<runtime.ApiResponse<{ [key: string]: object; }>> {
        if (requestParameters.rosettaStatusRequest === null || requestParameters.rosettaStatusRequest === undefined) {
            throw new runtime.RequiredError('rosettaStatusRequest','Required parameter requestParameters.rosettaStatusRequest was null or undefined when calling rosettaNetworkStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/rosetta/v1/network/status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RosettaStatusRequestToJSON(requestParameters.rosettaStatusRequest),
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here. 
     * Get Network Status
     */
    async rosettaNetworkStatus(requestParameters: RosettaNetworkStatusRequest): Promise<{ [key: string]: object; }> {
        const response = await this.rosettaNetworkStatusRaw(requestParameters);
        return await response.value();
    }

}

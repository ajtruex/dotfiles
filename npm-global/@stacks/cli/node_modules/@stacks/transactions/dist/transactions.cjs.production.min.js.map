{"version":3,"file":"transactions.cjs.production.min.js","sources":["../src/constants.ts","../../../node_modules/regenerator-runtime/runtime.js","../src/keys.ts","../src/clarity/clarityValue.ts","../src/errors.ts","../src/postcondition.ts","../src/payload.ts","../src/clarity/types/principalCV.ts","../src/types.ts","../src/clarity/types/booleanCV.ts","../src/clarity/types/intCV.ts","../src/clarity/types/bufferCV.ts","../src/clarity/types/optionalCV.ts","../src/clarity/types/responseCV.ts","../src/clarity/types/listCV.ts","../src/clarity/types/tupleCV.ts","../src/clarity/types/stringCV.ts","../src/clarity/serialize.ts","../src/bufferReader.ts","../src/clarity/deserialize.ts","../src/utils.ts","../src/authorization.ts","../src/contract-abi.ts","../src/transaction.ts","../src/signer.ts","../src/builders.ts"],"sourcesContent":["/**\n * Unsigned 32-bit integer\n */\nenum ChainID {\n  Testnet = 0x80000000,\n  Mainnet = 0x00000001,\n}\n\nconst DEFAULT_CHAIN_ID = ChainID.Mainnet;\nconst MAX_STRING_LENGTH_BYTES = 128;\nconst CLARITY_INT_SIZE = 128;\nconst COINBASE_BUFFER_LENGTH_BYTES = 32;\nconst RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;\nconst COMPRESSED_PUBKEY_LENGTH_BYTES = 32;\nconst UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;\nconst MEMO_MAX_LENGTH_BYTES = 34;\nconst DEFAULT_CORE_NODE_API_URL = 'https://stacks-node-api.mainnet.stacks.co';\n\nenum StacksMessageType {\n  Address,\n  Principal,\n  LengthPrefixedString,\n  MemoString,\n  AssetInfo,\n  PostCondition,\n  PublicKey,\n  LengthPrefixedList,\n  Payload,\n  MessageSignature,\n  TransactionAuthField,\n}\n\nenum PayloadType {\n  TokenTransfer = 0x00,\n  SmartContract = 0x01,\n  ContractCall = 0x02,\n  PoisonMicroblock = 0x03,\n  Coinbase = 0x04,\n}\n\nenum AnchorMode {\n  OnChainOnly = 0x01,\n  OffChainOnly = 0x02,\n  Any = 0x03,\n}\n\nenum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\nconst DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\n\nenum PostConditionMode {\n  Allow = 0x01,\n  Deny = 0x02,\n}\n\nenum PostConditionType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum AuthType {\n  Standard = 0x04,\n  Sponsored = 0x05,\n}\n\nenum AddressHashMode {\n  // serialization modes for public keys to addresses.\n  // We support four different modes due to legacy compatibility with Stacks v1 addresses:\n  /** SingleSigHashMode - hash160(public-key), same as bitcoin's p2pkh */\n  SerializeP2PKH = 0x00,\n  /** MultiSigHashMode - hash160(multisig-redeem-script), same as bitcoin's multisig p2sh */\n  SerializeP2SH = 0x01,\n  /** SingleSigHashMode - hash160(segwit-program-00(p2pkh)), same as bitcoin's p2sh-p2wpkh */\n  SerializeP2WPKH = 0x02,\n  /** MultiSigHashMode - hash160(segwit-program-00(public-keys)), same as bitcoin's p2sh-p2wsh */\n  SerializeP2WSH = 0x03,\n}\n\ntype SingleSigHashMode = AddressHashMode.SerializeP2PKH | AddressHashMode.SerializeP2WPKH;\ntype MultiSigHashMode = AddressHashMode.SerializeP2SH | AddressHashMode.SerializeP2WSH;\n\nenum AddressVersion {\n  MainnetSingleSig = 22,\n  MainnetMultiSig = 20,\n  TestnetSingleSig = 26,\n  TestnetMultiSig = 21,\n}\n\nenum PubKeyEncoding {\n  Compressed = 0x00,\n  Uncompressed = 0x01,\n}\n\nenum FungibleConditionCode {\n  Equal = 0x01,\n  Greater = 0x02,\n  GreaterEqual = 0x03,\n  Less = 0x04,\n  LessEqual = 0x05,\n}\n\nenum NonFungibleConditionCode {\n  DoesNotOwn = 0x10,\n  Owns = 0x11,\n}\n\nenum PostConditionPrincipalID {\n  Origin = 0x01,\n  Standard = 0x02,\n  Contract = 0x03,\n}\n\nenum AssetType {\n  STX = 0x00,\n  Fungible = 0x01,\n  NonFungible = 0x02,\n}\n\nenum TxRejectedReason {\n  Serialization = 'Serialization',\n  Deserialization = 'Deserialization',\n  SignatureValidation = 'SignatureValidation',\n  FeeTooLow = 'FeeTooLow',\n  BadNonce = 'BadNonce',\n  NotEnoughFunds = 'NotEnoughFunds',\n  NoSuchContract = 'NoSuchContract',\n  NoSuchPublicFunction = 'NoSuchPublicFunction',\n  BadFunctionArgument = 'BadFunctionArgument',\n  ContractAlreadyExists = 'ContractAlreadyExists',\n  PoisonMicroblocksDoNotConflict = 'PoisonMicroblocksDoNotConflict',\n  PoisonMicroblockHasUnknownPubKeyHash = 'PoisonMicroblockHasUnknownPubKeyHash',\n  PoisonMicroblockIsInvalid = 'PoisonMicroblockIsInvalid',\n  BadAddressVersionByte = 'BadAddressVersionByte',\n  NoCoinbaseViaMempool = 'NoCoinbaseViaMempool',\n  ServerFailureNoSuchChainTip = 'ServerFailureNoSuchChainTip',\n  ServerFailureDatabase = 'ServerFailureDatabase',\n  ServerFailureOther = 'ServerFailureOther',\n}\n\nexport {\n  MAX_STRING_LENGTH_BYTES,\n  CLARITY_INT_SIZE,\n  COINBASE_BUFFER_LENGTH_BYTES,\n  DEFAULT_CHAIN_ID,\n  DEFAULT_TRANSACTION_VERSION,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n  MEMO_MAX_LENGTH_BYTES,\n  DEFAULT_CORE_NODE_API_URL,\n  ChainID,\n  StacksMessageType,\n  PayloadType,\n  AnchorMode,\n  TransactionVersion,\n  PostConditionMode,\n  PostConditionType,\n  PostConditionPrincipalID,\n  AuthType,\n  AddressHashMode,\n  SingleSigHashMode,\n  MultiSigHashMode,\n  AddressVersion,\n  PubKeyEncoding,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  AssetType,\n  TxRejectedReason,\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import {\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n  StacksMessageType,\n  AddressHashMode,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  BufferArray,\n  leftPadHexToLength,\n  intToHexString,\n  randomBytes,\n  hash160,\n  hashP2PKH,\n  hexStringToInt,\n} from './utils';\n\nimport { ec as EC } from 'elliptic';\n\nimport { MessageSignature, createMessageSignature } from './authorization';\nimport { BufferReader } from './bufferReader';\nimport { AddressVersion } from './constants';\nimport { c32address } from 'c32check';\nimport { addressHashModeToVersion, addressFromVersionHash, addressToString } from './types';\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Buffer;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key buffer or hex string */\n  privateKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key buffer or hex string */\n  publicKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: Buffer.from(key, 'hex'),\n  };\n}\n\nexport function publicKeyFromSignature(message: string, messageSignature: MessageSignature) {\n  const ec = new EC('secp256k1');\n  const messageBN = ec\n    .keyFromPrivate(message, 'hex')\n    .getPrivate()\n    .toString(10);\n\n  const parsedSignature = parseRecoverableSignature(messageSignature.data);\n\n  const publicKey = ec.recoverPubKey(\n    messageBN,\n    parsedSignature,\n    parsedSignature.recoveryParam,\n    'hex'\n  ) as { encodeCompressed: (enc: string) => string };\n\n  return publicKey.encodeCompressed('hex');\n}\n\nexport function publicKeyFromBuffer(data: Buffer): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !key.data.toString('hex').startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return key.data.toString('hex');\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(key.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Buffer): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const ec = new EC('secp256k1');\n  const keyPair = ec.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');\n  const pubKey = keyPair.getPublic(privKey.compressed, 'hex');\n  return createStacksPublicKey(pubKey);\n}\n\nexport function deserializePublicKey(bufferReader: BufferReader): StacksPublicKey {\n  const fieldId = bufferReader.readUInt8();\n  const keyLength =\n    fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBuffer(\n    Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)])\n  );\n}\n\nexport interface StacksPrivateKey {\n  data: Buffer;\n  compressed: boolean;\n}\n\nexport function createStacksPrivateKey(key: string | Buffer): StacksPrivateKey {\n  const data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;\n  let compressed: boolean;\n  if (data.length === 33) {\n    if (data[data.length - 1] !== 1) {\n      throw new Error(\n        'Improperly formatted private-key. 33 byte length usually ' +\n          'indicates compressed key, but last byte must be == 0x01'\n      );\n    }\n    compressed = true;\n  } else if (data.length === 32) {\n    compressed = false;\n  } else {\n    throw new Error(\n      `Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${data.length}`\n    );\n  }\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(entropy?: Buffer): StacksPrivateKey {\n  const ec = new EC('secp256k1');\n  const options = { entropy: entropy || randomBytes(32) };\n  const keyPair = ec.genKeyPair(options);\n  const privateKey = keyPair.getPrivate().toString('hex', 32);\n  return createStacksPrivateKey(privateKey);\n}\n\nexport function signWithKey(privateKey: StacksPrivateKey, input: string): MessageSignature {\n  const ec = new EC('secp256k1');\n  const key = ec.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');\n  const signature = key.sign(input, 'hex', { canonical: true });\n  const coordinateValueBytes = 32;\n  const r = leftPadHexToLength(signature.r.toString('hex'), coordinateValueBytes * 2);\n  const s = leftPadHexToLength(signature.s.toString('hex'), coordinateValueBytes * 2);\n  if (signature.recoveryParam === undefined || signature.recoveryParam === null) {\n    throw new Error('\"signature.recoveryParam\" is not set');\n  }\n  const recoveryParam = intToHexString(signature.recoveryParam, 1);\n  const recoverableSignatureString = recoveryParam + r + s;\n  const recoverableSignature = createMessageSignature(recoverableSignatureString);\n  return recoverableSignature;\n}\n\nexport function getSignatureRecoveryParam(signature: string) {\n  const coordinateValueBytes = 32;\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n  const recoveryParamHex = signature.substr(0, 2);\n  return hexStringToInt(recoveryParamHex);\n}\n\nexport function parseRecoverableSignature(signature: string) {\n  const coordinateValueBytes = 32;\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n  const recoveryParamHex = signature.substr(0, 2);\n  const r = signature.substr(2, coordinateValueBytes * 2);\n  const s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);\n  return {\n    recoveryParam: hexStringToInt(recoveryParamHex),\n    r,\n    s,\n  };\n}\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return privateKey.data.toString('hex');\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, hash160(publicKey.data).toString('hex'));\n}\n","import {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseErrorCV,\n  ResponseOkCV,\n  ListCV,\n  TupleCV,\n  StringAsciiCV,\n  StringUtf8CV,\n} from '.';\n\nimport { principalToString } from './types/principalCV';\nimport { CLARITY_INT_SIZE } from '../constants';\n\n/**\n * Type IDs corresponding to each of the Clarity value types as described here:\n * {@link https://github.com/blockstack/blockstack-core/blob/sip/sip-005/sip/sip-005-blocks-and-transactions.md#clarity-value-representation}\n */\nexport enum ClarityType {\n  Int = 0x00,\n  UInt = 0x01,\n  Buffer = 0x02,\n  BoolTrue = 0x03,\n  BoolFalse = 0x04,\n  PrincipalStandard = 0x05,\n  PrincipalContract = 0x06,\n  ResponseOk = 0x07,\n  ResponseErr = 0x08,\n  OptionalNone = 0x09,\n  OptionalSome = 0x0a,\n  List = 0x0b,\n  Tuple = 0x0c,\n  StringASCII = 0x0d,\n  StringUTF8 = 0x0e,\n}\n\nexport type ClarityValue =\n  | BooleanCV\n  | OptionalCV\n  | BufferCV\n  | IntCV\n  | UIntCV\n  | StandardPrincipalCV\n  | ContractPrincipalCV\n  | ResponseErrorCV\n  | ResponseOkCV\n  | ListCV\n  | TupleCV\n  | StringAsciiCV\n  | StringUtf8CV;\n\nexport function cvToString(val: ClarityValue, encoding: 'tryAscii' | 'hex' = 'hex'): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return 'true';\n    case ClarityType.BoolFalse:\n      return 'false';\n    case ClarityType.Int:\n      return val.value.fromTwos(CLARITY_INT_SIZE).toString();\n    case ClarityType.UInt:\n      return `u${val.value.toString()}`;\n    case ClarityType.Buffer:\n      if (encoding === 'tryAscii') {\n        const str = val.buffer.toString('ascii');\n        if (/[ -~]/.test(str)) {\n          return JSON.stringify(str);\n        }\n      }\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return 'none';\n    case ClarityType.OptionalSome:\n      return `(some ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseErr:\n      return `(err ${cvToString(val.value, encoding)})`;\n    case ClarityType.ResponseOk:\n      return `(ok ${cvToString(val.value, encoding)})`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `\"${val.data}\"`;\n    case ClarityType.StringUTF8:\n      return `u\"${val.data}\"`;\n  }\n}\n\nfunction cvToValue(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n      return true;\n    case ClarityType.BoolFalse:\n      return false;\n    case ClarityType.Int:\n      return val.value.fromTwos(CLARITY_INT_SIZE).toNumber();\n    case ClarityType.UInt:\n      return val.value.toNumber();\n    case ClarityType.Buffer:\n      return `0x${val.buffer.toString('hex')}`;\n    case ClarityType.OptionalNone:\n      return null;\n    case ClarityType.OptionalSome:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseErr:\n      return cvToJSON(val.value);\n    case ClarityType.ResponseOk:\n      return cvToJSON(val.value);\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return principalToString(val);\n    case ClarityType.List:\n      return val.list.map(v => cvToJSON(v));\n    case ClarityType.Tuple:\n      const result: { [key: string]: any } = {};\n      Object.keys(val.data).forEach(key => {\n        result[key] = cvToJSON(val.data[key]);\n      });\n      return result;\n    case ClarityType.StringASCII:\n      return val.data;\n    case ClarityType.StringUTF8:\n      return val.data;\n  }\n}\n\nexport function cvToJSON(val: ClarityValue): any {\n  switch (val.type) {\n    case ClarityType.ResponseErr:\n      return { type: getCVTypeString(val), value: cvToValue(val), success: false };\n    case ClarityType.ResponseOk:\n      return { type: getCVTypeString(val), value: cvToValue(val), success: true };\n    default:\n      return { type: getCVTypeString(val), value: cvToValue(val) };\n  }\n}\n\nexport function getCVTypeString(val: ClarityValue): string {\n  switch (val.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return 'bool';\n    case ClarityType.Int:\n      return 'int';\n    case ClarityType.UInt:\n      return 'uint';\n    case ClarityType.Buffer:\n      return `(buff ${val.buffer.length})`;\n    case ClarityType.OptionalNone:\n      return '(optional none)';\n    case ClarityType.OptionalSome:\n      return `(optional ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseErr:\n      return `(response UnknownType ${getCVTypeString(val.value)})`;\n    case ClarityType.ResponseOk:\n      return `(response ${getCVTypeString(val.value)} UnknownType)`;\n    case ClarityType.PrincipalStandard:\n    case ClarityType.PrincipalContract:\n      return 'principal';\n    case ClarityType.List:\n      return `(list ${val.list.length} ${getCVTypeString(val.list[0])})`;\n    case ClarityType.Tuple:\n      return `(tuple ${Object.keys(val.data)\n        .map(key => `(${key} ${getCVTypeString(val.data[key])})`)\n        .join(' ')})`;\n    case ClarityType.StringASCII:\n      return `(string-ascii ${Buffer.from(val.data, 'ascii').length})`;\n    case ClarityType.StringUTF8:\n      return `(string-utf8 ${Buffer.from(val.data, 'utf8').length})`;\n  }\n}\n","export class StacksTransactionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SerializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class DeserializationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class NotImplementedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class SigningError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\nexport class VerificationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n","import {\n  PostConditionType,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  StacksMessageType,\n} from './constants';\n\nimport { BufferArray } from './utils';\n\nimport {\n  AssetInfo,\n  serializeAssetInfo,\n  deserializeAssetInfo,\n  PostConditionPrincipal,\n  serializePrincipal,\n  deserializePrincipal,\n  parseAssetInfoString,\n  parsePrincipalString,\n} from './types';\n\nimport BigNum from 'bn.js';\nimport { BufferReader } from './bufferReader';\nimport { ClarityValue, serializeCV, deserializeCV } from './clarity';\nimport { DeserializationError } from './errors';\n\nexport type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;\n\nexport interface STXPostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.STX;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: BigNum;\n}\n\nexport function createSTXPostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum\n): STXPostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.STX,\n    principal,\n    conditionCode,\n    amount,\n  };\n}\n\nexport interface FungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.Fungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: FungibleConditionCode;\n  readonly amount: BigNum;\n  readonly assetInfo: AssetInfo;\n}\n\nexport function createFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.Fungible,\n    principal,\n    conditionCode,\n    amount,\n    assetInfo,\n  };\n}\n\nexport interface NonFungiblePostCondition {\n  readonly type: StacksMessageType.PostCondition;\n  readonly conditionType: PostConditionType.NonFungible;\n  readonly principal: PostConditionPrincipal;\n  readonly conditionCode: NonFungibleConditionCode;\n  /** Structure that identifies the token type. */\n  readonly assetInfo: AssetInfo;\n  /** The Clarity value that names the token instance. */\n  readonly assetName: ClarityValue;\n}\n\nexport function createNonFungiblePostCondition(\n  principal: string | PostConditionPrincipal,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  if (typeof principal === 'string') {\n    principal = parsePrincipalString(principal);\n  }\n  if (typeof assetInfo === 'string') {\n    assetInfo = parseAssetInfoString(assetInfo);\n  }\n\n  return {\n    type: StacksMessageType.PostCondition,\n    conditionType: PostConditionType.NonFungible,\n    principal,\n    conditionCode,\n    assetInfo,\n    assetName,\n  };\n}\n\nexport function serializePostCondition(postCondition: PostCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(postCondition.conditionType);\n  bufferArray.push(serializePrincipal(postCondition.principal));\n\n  if (\n    postCondition.conditionType === PostConditionType.Fungible ||\n    postCondition.conditionType === PostConditionType.NonFungible\n  ) {\n    bufferArray.push(serializeAssetInfo(postCondition.assetInfo));\n  }\n\n  if (postCondition.conditionType === PostConditionType.NonFungible) {\n    bufferArray.push(serializeCV(postCondition.assetName));\n  }\n\n  bufferArray.appendByte(postCondition.conditionCode);\n\n  if (\n    postCondition.conditionType === PostConditionType.STX ||\n    postCondition.conditionType === PostConditionType.Fungible\n  ) {\n    bufferArray.push(postCondition.amount.toArrayLike(Buffer, 'be', 8));\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePostCondition(bufferReader: BufferReader): PostCondition {\n  const postConditionType = bufferReader.readUInt8Enum(PostConditionType, n => {\n    throw new DeserializationError(`Could not read ${n} as PostConditionType`);\n  });\n\n  const principal = deserializePrincipal(bufferReader);\n\n  let conditionCode;\n  let assetInfo;\n  let amount;\n  switch (postConditionType) {\n    case PostConditionType.STX:\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.STX,\n        principal,\n        conditionCode,\n        amount,\n      };\n    case PostConditionType.Fungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(FungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      amount = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.Fungible,\n        principal,\n        conditionCode,\n        amount,\n        assetInfo,\n      };\n    case PostConditionType.NonFungible:\n      assetInfo = deserializeAssetInfo(bufferReader);\n      const assetName = deserializeCV(bufferReader);\n      conditionCode = bufferReader.readUInt8Enum(NonFungibleConditionCode, n => {\n        throw new DeserializationError(`Could not read ${n} as FungibleConditionCode`);\n      });\n      return {\n        type: StacksMessageType.PostCondition,\n        conditionType: PostConditionType.NonFungible,\n        principal,\n        conditionCode,\n        assetInfo,\n        assetName,\n      };\n  }\n}\n","import { COINBASE_BUFFER_LENGTH_BYTES, PayloadType, StacksMessageType } from './constants';\n\nimport { BufferArray } from './utils';\n\nimport {\n  Address,\n  MemoString,\n  createAddress,\n  createMemoString,\n  LengthPrefixedString,\n  createLPString,\n  serializeStacksMessage,\n  deserializeAddress,\n  deserializeLPString,\n  deserializeMemoString,\n  codeBodyString,\n} from './types';\n\nimport { ClarityValue, serializeCV, deserializeCV } from './clarity/';\n\nimport BigNum from 'bn.js';\nimport { BufferReader } from './bufferReader';\nimport { PrincipalCV, principalCV } from './clarity/types/principalCV';\n\nexport type Payload =\n  | TokenTransferPayload\n  | ContractCallPayload\n  | SmartContractPayload\n  | PoisonPayload\n  | CoinbasePayload;\n\nexport interface TokenTransferPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.TokenTransfer;\n  readonly recipient: PrincipalCV;\n  readonly amount: BigNum;\n  readonly memo: MemoString;\n}\n\nexport function createTokenTransferPayload(\n  recipient: string | PrincipalCV,\n  amount: BigNum,\n  memo?: string | MemoString\n): TokenTransferPayload {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount,\n    memo: memo ?? createMemoString(''),\n  };\n}\n\nexport interface ContractCallPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.ContractCall;\n  readonly contractAddress: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly functionName: LengthPrefixedString;\n  readonly functionArgs: ClarityValue[];\n}\n\nexport function createContractCallPayload(\n  contractAddress: string | Address,\n  contractName: string | LengthPrefixedString,\n  functionName: string | LengthPrefixedString,\n  functionArgs: ClarityValue[]\n): ContractCallPayload {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs,\n  };\n}\n\nexport interface SmartContractPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.SmartContract;\n  readonly contractName: LengthPrefixedString;\n  readonly codeBody: LengthPrefixedString;\n}\n\nexport function createSmartContractPayload(\n  contractName: string | LengthPrefixedString,\n  codeBody: string | LengthPrefixedString\n): SmartContractPayload {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody,\n  };\n}\n\nexport interface PoisonPayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.PoisonMicroblock;\n}\n\nexport function createPoisonPayload(): PoisonPayload {\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\n\nexport interface CoinbasePayload {\n  readonly type: StacksMessageType.Payload;\n  readonly payloadType: PayloadType.Coinbase;\n  readonly coinbaseBuffer: Buffer;\n}\n\nexport function createCoinbasePayload(coinbaseBuffer: Buffer): CoinbasePayload {\n  if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);\n  }\n  return { type: StacksMessageType.Payload, payloadType: PayloadType.Coinbase, coinbaseBuffer };\n}\n\nexport function serializePayload(payload: Payload): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bufferArray.push(serializeCV(payload.recipient));\n      bufferArray.push(payload.amount.toArrayLike(Buffer, 'be', 8));\n      bufferArray.push(serializeStacksMessage(payload.memo));\n      break;\n    case PayloadType.ContractCall:\n      bufferArray.push(serializeStacksMessage(payload.contractAddress));\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = Buffer.alloc(4);\n      numArgs.writeUInt32BE(payload.functionArgs.length, 0);\n      bufferArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bufferArray.push(serializeCV(arg));\n      });\n      break;\n    case PayloadType.SmartContract:\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      break;\n    case PayloadType.Coinbase:\n      bufferArray.push(payload.coinbaseBuffer);\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePayload(bufferReader: BufferReader): Payload {\n  const payloadType = bufferReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bufferReader) as PrincipalCV;\n      const amount = new BigNum(bufferReader.readBuffer(8));\n      const memo = deserializeMemoString(bufferReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bufferReader);\n      const contractCallName = deserializeLPString(bufferReader);\n      const functionName = deserializeLPString(bufferReader);\n      const functionArgs = [];\n      const numberOfArgs = bufferReader.readUInt32BE();\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bufferReader);\n        functionArgs.push(clarityValue);\n      }\n      return createContractCallPayload(\n        contractAddress,\n        contractCallName,\n        functionName,\n        functionArgs\n      );\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bufferReader);\n      const codeBody = deserializeLPString(bufferReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n    case PayloadType.PoisonMicroblock:\n      // TODO: implement\n      return createPoisonPayload();\n    case PayloadType.Coinbase:\n      const coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);\n      return createCoinbasePayload(coinbaseBuffer);\n  }\n}\n","import {\n  Address,\n  LengthPrefixedString,\n  createAddress,\n  createLPString,\n  addressToString,\n} from '../../types';\nimport { ClarityType } from '../clarityValue';\n\ntype PrincipalCV = StandardPrincipalCV | ContractPrincipalCV;\n\ninterface StandardPrincipalCV {\n  readonly type: ClarityType.PrincipalStandard;\n  readonly address: Address;\n}\n\ninterface ContractPrincipalCV {\n  readonly type: ClarityType.PrincipalContract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\nfunction principalToString(principal: PrincipalCV): string {\n  if (principal.type === ClarityType.PrincipalStandard) {\n    return addressToString(principal.address);\n  } else if (principal.type === ClarityType.PrincipalContract) {\n    const address = addressToString(principal.address);\n    return `${address}.${principal.contractName.content}`;\n  } else {\n    throw new Error(`Unexpected principal data: ${JSON.stringify(principal)}`);\n  }\n}\n\nfunction principalCV(principal: string): PrincipalCV {\n  if (principal.includes('.')) {\n    const [address, contractName] = principal.split('.');\n    return contractPrincipalCV(address, contractName);\n  } else {\n    return standardPrincipalCV(principal);\n  }\n}\n\nfunction standardPrincipalCV(addressString: string): StandardPrincipalCV {\n  const addr = createAddress(addressString);\n  return { type: ClarityType.PrincipalStandard, address: addr };\n}\n\nfunction standardPrincipalCVFromAddress(address: Address): StandardPrincipalCV {\n  return { type: ClarityType.PrincipalStandard, address };\n}\n\nfunction contractPrincipalCV(addressString: string, contractName: string): ContractPrincipalCV {\n  const addr = createAddress(addressString);\n  const lengthPrefixedContractName = createLPString(contractName);\n  return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);\n}\n\nfunction contractPrincipalCVFromAddress(\n  address: Address,\n  contractName: LengthPrefixedString\n): ContractPrincipalCV {\n  if (Buffer.byteLength(contractName.content) >= 128) {\n    throw new Error('Contract name must be less than 128 bytes');\n  }\n  return { type: ClarityType.PrincipalContract, address, contractName };\n}\n\nfunction contractPrincipalCVFromStandard(\n  sp: StandardPrincipalCV,\n  contractName: string\n): ContractPrincipalCV {\n  const lengthPrefixedContractName = createLPString(contractName);\n  return {\n    type: ClarityType.PrincipalContract,\n    address: sp.address,\n    contractName: lengthPrefixedContractName,\n  };\n}\n\nexport {\n  PrincipalCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  principalCV,\n  principalToString,\n  standardPrincipalCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCV,\n  contractPrincipalCVFromAddress,\n  contractPrincipalCVFromStandard,\n};\n","import {\n  MAX_STRING_LENGTH_BYTES,\n  MEMO_MAX_LENGTH_BYTES,\n  AddressHashMode,\n  AddressVersion,\n  TransactionVersion,\n  StacksMessageType,\n  PostConditionPrincipalID,\n} from './constants';\n\nimport { StacksPublicKey, serializePublicKey, deserializePublicKey, isCompressed } from './keys';\n\nimport {\n  BufferArray,\n  intToHexString,\n  hexStringToInt,\n  exceedsMaxLengthBytes,\n  hashP2PKH,\n  rightPadHexToLength,\n  hashP2SH,\n} from './utils';\n\nimport { c32addressDecode, c32address } from 'c32check';\nimport { BufferReader } from './bufferReader';\nimport { PostCondition, serializePostCondition, deserializePostCondition } from './postcondition';\nimport { Payload, deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport {\n  deserializeTransactionAuthField,\n  deserializeMessageSignature,\n  MessageSignature,\n  serializeMessageSignature,\n  serializeTransactionAuthField,\n  TransactionAuthField,\n} from './authorization';\n\nexport type StacksMessage =\n  | Address\n  | PostConditionPrincipal\n  | LengthPrefixedString\n  | LengthPrefixedList\n  | Payload\n  | MemoString\n  | AssetInfo\n  | PostCondition\n  | StacksPublicKey\n  | TransactionAuthField\n  | MessageSignature;\n\nexport function serializeStacksMessage(message: StacksMessage): Buffer {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\n\nexport function deserializeStacksMessage(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  listType?: StacksMessageType\n): StacksMessage {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bufferReader);\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bufferReader);\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bufferReader);\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bufferReader);\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bufferReader);\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bufferReader);\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bufferReader);\n    case StacksMessageType.Payload:\n      return deserializePayload(bufferReader);\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n      return deserializeLPList(bufferReader, listType);\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bufferReader);\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\n\nexport interface Address {\n  readonly type: StacksMessageType.Address;\n  readonly version: AddressVersion;\n  readonly hash160: string;\n}\n\nexport function createAddress(c32AddressString: string): Address {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1],\n  };\n}\n\nexport function createEmptyAddress(): Address {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40),\n  };\n}\n\nexport function addressFromVersionHash(version: AddressVersion, hash: string): Address {\n  return { type: StacksMessageType.Address, version, hash160: hash };\n}\n\n/**\n * Translates the tx auth hash mode to the corresponding address version.\n * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization\n */\nexport function addressHashModeToVersion(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion\n): AddressVersion {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n        default:\n          throw new Error(\n            `Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`\n          );\n      }\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\n\nexport function addressFromHashMode(\n  hashMode: AddressHashMode,\n  txVersion: TransactionVersion,\n  data: string\n): Address {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\n\nexport function addressFromPublicKeys(\n  version: AddressVersion,\n  hashMode: AddressHashMode,\n  numSigs: number,\n  publicKeys: StacksPublicKey[]\n): Address {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n    default:\n      throw Error(\n        `Not yet implemented: address construction using public keys for hash mode: ${hashMode}`\n      );\n  }\n}\n\nexport function addressToString(address: Address): string {\n  return c32address(address.version, address.hash160).toString();\n}\n\nexport function serializeAddress(address: Address): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(address.version, 1));\n  bufferArray.appendHexString(address.hash160);\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAddress(bufferReader: BufferReader): Address {\n  const version = hexStringToInt(bufferReader.readBuffer(1).toString('hex'));\n  const data = bufferReader.readBuffer(20).toString('hex');\n\n  return { type: StacksMessageType.Address, version, hash160: data };\n}\n\nexport type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;\n\nexport interface StandardPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Standard;\n  readonly address: Address;\n}\n\nexport interface ContractPrincipal {\n  readonly type: StacksMessageType.Principal;\n  readonly prefix: PostConditionPrincipalID.Contract;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n}\n\n/**\n * Parses a principal string for either a standard principal or contract principal.\n * @param principalString - String in the format `{address}.{contractName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract\"\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G\"\n */\nexport function parsePrincipalString(\n  principalString: string\n): StandardPrincipal | ContractPrincipal {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\n\nexport function createStandardPrincipal(addressString: string): StandardPrincipal {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr,\n  };\n}\n\nexport function createContractPrincipal(\n  addressString: string,\n  contractName: string\n): ContractPrincipal {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name,\n  };\n}\n\nexport function serializePrincipal(principal: PostConditionPrincipal): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(Buffer.from([principal.prefix]));\n  bufferArray.push(serializeAddress(principal.address));\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bufferArray.push(serializeLPString(principal.contractName));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal {\n  const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n    throw new DeserializationError('Unexpected Principal payload type: ${n}');\n  });\n  const address = deserializeAddress(bufferReader);\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return { type: StacksMessageType.Principal, prefix, address } as StandardPrincipal;\n  }\n  const contractName = deserializeLPString(bufferReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName,\n  } as ContractPrincipal;\n}\n\nexport interface LengthPrefixedString {\n  readonly type: StacksMessageType.LengthPrefixedString;\n  readonly content: string;\n  readonly lengthPrefixBytes: number;\n  readonly maxLengthBytes: number;\n}\n\nexport function createLPString(content: string): LengthPrefixedString;\nexport function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes: number,\n  maxLengthBytes: number\n): LengthPrefixedString;\nexport function createLPString(\n  content: string,\n  lengthPrefixBytes?: number,\n  maxLengthBytes?: number\n): LengthPrefixedString {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength,\n  };\n}\n\nexport function serializeLPString(lps: LengthPrefixedString) {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(lps.content);\n  const length = contentBuffer.byteLength;\n  bufferArray.appendHexString(intToHexString(length, lps.lengthPrefixBytes));\n  bufferArray.push(contentBuffer);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPString(\n  bufferReader: BufferReader,\n  prefixBytes?: number,\n  maxLength?: number\n): LengthPrefixedString {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n  const content = bufferReader.readBuffer(length).toString();\n  return createLPString(content, prefixBytes, maxLength ?? 128);\n}\n\nexport function codeBodyString(content: string): LengthPrefixedString {\n  return createLPString(content, 4, 100000);\n}\n\nexport interface MemoString {\n  readonly type: StacksMessageType.MemoString;\n  readonly content: string;\n}\n\nexport function createMemoString(content: string): MemoString {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n  }\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport function serializeMemoString(memoString: MemoString): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(memoString.content);\n  const paddedContent = rightPadHexToLength(\n    contentBuffer.toString('hex'),\n    MEMO_MAX_LENGTH_BYTES * 2\n  );\n  bufferArray.push(Buffer.from(paddedContent, 'hex'));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMemoString(bufferReader: BufferReader): MemoString {\n  const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n  return { type: StacksMessageType.MemoString, content };\n}\n\nexport interface AssetInfo {\n  readonly type: StacksMessageType.AssetInfo;\n  readonly address: Address;\n  readonly contractName: LengthPrefixedString;\n  readonly assetName: LengthPrefixedString;\n}\n\n/**\n * Parse a fully qualified string that identifies the token type.\n * @param id - String in the format `{address}.{contractName}::{assetName}`\n * @example \"SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract::example-token\"\n */\nexport function parseAssetInfoString(id: string): AssetInfo {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\n\nexport function createAssetInfo(\n  addressString: string,\n  contractName: string,\n  assetName: string\n): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName),\n  };\n}\n\nexport function serializeAssetInfo(info: AssetInfo): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(serializeAddress(info.address));\n  bufferArray.push(serializeLPString(info.contractName));\n  bufferArray.push(serializeLPString(info.assetName));\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bufferReader),\n    contractName: deserializeLPString(bufferReader),\n    assetName: deserializeLPString(bufferReader),\n  };\n}\n\nexport interface LengthPrefixedList {\n  readonly type: StacksMessageType.LengthPrefixedList;\n  readonly lengthPrefixBytes: number;\n  readonly values: StacksMessage[];\n}\n\nexport function createLPList<T extends StacksMessage>(\n  values: T[],\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values,\n  };\n}\n\nexport function serializeLPList(lpList: LengthPrefixedList): Buffer {\n  const list = lpList.values;\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(list.length, lpList.lengthPrefixBytes));\n  for (let index = 0; index < list.length; index++) {\n    bufferArray.push(serializeStacksMessage(list[index]));\n  }\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeLPList(\n  bufferReader: BufferReader,\n  type: StacksMessageType,\n  lengthPrefixBytes?: number\n): LengthPrefixedList {\n  const length = hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n  const l: StacksMessage[] = [];\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bufferReader));\n        break;\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bufferReader));\n        break;\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bufferReader));\n        break;\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bufferReader));\n        break;\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bufferReader));\n        break;\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bufferReader));\n        break;\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bufferReader));\n        break;\n    }\n  }\n  return createLPList(l, lengthPrefixBytes);\n}\n","import { ClarityType } from '../clarityValue';\n\ntype BooleanCV = TrueCV | FalseCV;\n\ninterface TrueCV {\n  type: ClarityType.BoolTrue;\n}\n\ninterface FalseCV {\n  type: ClarityType.BoolFalse;\n}\n\nconst trueCV = (): BooleanCV => ({ type: ClarityType.BoolTrue });\nconst falseCV = (): BooleanCV => ({ type: ClarityType.BoolFalse });\n\nexport { BooleanCV, TrueCV, FalseCV, trueCV, falseCV };\n","import BigNum from 'bn.js';\nimport { CLARITY_INT_SIZE } from '../../constants';\nimport { ClarityType } from '../clarityValue';\n\ninterface IntCV {\n  readonly type: ClarityType.Int;\n  readonly value: BigNum;\n}\n\nconst intCV = (value: number | string | Buffer): IntCV => {\n  const bn = new BigNum(value);\n  const twos = bn.toTwos(CLARITY_INT_SIZE);\n\n  if (twos.bitLength() > CLARITY_INT_SIZE) {\n    throw new Error('Cannot construct clarity integer from value greater than INT_SIZE bits');\n  }\n\n  return { type: ClarityType.Int, value: twos };\n};\n\ninterface UIntCV {\n  readonly type: ClarityType.UInt;\n  readonly value: BigNum;\n}\n\nconst uintCV = (value: number | string | Buffer): UIntCV => {\n  const bn = new BigNum(value);\n  const twos = bn.toTwos(CLARITY_INT_SIZE);\n\n  if (twos.isNeg()) {\n    throw new Error('Cannot construct unsigned clarity integer from negative value');\n  } else if (twos.bitLength() > CLARITY_INT_SIZE) {\n    throw new Error('Cannot construct unsigned clarity integer from value greater than 128 bits');\n  }\n\n  return { type: ClarityType.UInt, value: twos };\n};\n\nexport { IntCV, UIntCV, intCV, uintCV };\n","import { ClarityType } from '../clarityValue';\n\ninterface BufferCV {\n  readonly type: ClarityType.Buffer;\n  readonly buffer: Buffer;\n}\n\nconst bufferCV = (buffer: Buffer): BufferCV => {\n  if (buffer.length > 1000000) {\n    throw new Error('Cannot construct clarity buffer that is greater than 1MB');\n  }\n\n  return { type: ClarityType.Buffer, buffer };\n};\n\nconst bufferCVFromString = (str: string): BufferCV => bufferCV(Buffer.from(str));\n\nexport { BufferCV, bufferCV, bufferCVFromString };\n","import { ClarityType, ClarityValue } from '../clarityValue';\n\ntype OptionalCV = NoneCV | SomeCV;\n\ninterface NoneCV {\n  readonly type: ClarityType.OptionalNone;\n}\n\ninterface SomeCV {\n  readonly type: ClarityType.OptionalSome;\n  readonly value: ClarityValue;\n}\n\nconst noneCV = (): OptionalCV => ({ type: ClarityType.OptionalNone });\nconst someCV = (value: ClarityValue): OptionalCV => ({ type: ClarityType.OptionalSome, value });\nconst optionalCVOf = (value?: ClarityValue): OptionalCV => {\n  if (value) {\n    return someCV(value);\n  } else {\n    return noneCV();\n  }\n};\n\nexport { OptionalCV, NoneCV, SomeCV, noneCV, someCV, optionalCVOf };\n","import { ClarityType, ClarityValue } from '../clarityValue';\n\ntype ResponseCV = ResponseErrorCV | ResponseOkCV;\n\ninterface ResponseErrorCV {\n  readonly type: ClarityType.ResponseErr;\n  readonly value: ClarityValue;\n}\n\ninterface ResponseOkCV {\n  readonly type: ClarityType.ResponseOk;\n  readonly value: ClarityValue;\n}\n\nfunction responseErrorCV(value: ClarityValue): ResponseErrorCV {\n  return { type: ClarityType.ResponseErr, value };\n}\n\nfunction responseOkCV(value: ClarityValue): ResponseOkCV {\n  return { type: ClarityType.ResponseOk, value };\n}\n\nexport { ResponseCV, ResponseErrorCV, ResponseOkCV, responseErrorCV, responseOkCV };\n","import { ClarityValue, ClarityType } from '../clarityValue';\n\ninterface ListCV {\n  type: ClarityType.List;\n  list: ClarityValue[];\n}\n\nfunction listCV<T extends ClarityValue>(values: T[]): ListCV {\n  return { type: ClarityType.List, list: values };\n}\n\nexport { ListCV, listCV };\n","import { ClarityType, ClarityValue } from '../clarityValue';\nimport { isClarityName } from '../../utils';\n\ntype TupleData = { [key: string]: ClarityValue };\n\ninterface TupleCV {\n  type: ClarityType.Tuple;\n  data: TupleData;\n}\n\nfunction tupleCV(data: TupleData): TupleCV {\n  for (const key in data) {\n    if (!isClarityName(key)) {\n      throw new Error(`\"${key}\" is not a valid Clarity name`);\n    }\n  }\n\n  return { type: ClarityType.Tuple, data };\n}\n\nexport { TupleCV, tupleCV };\n","import { ClarityType } from '../clarityValue';\n\ninterface StringAsciiCV {\n  readonly type: ClarityType.StringASCII;\n  readonly data: string;\n}\n\ninterface StringUtf8CV {\n  readonly type: ClarityType.StringUTF8;\n  readonly data: string;\n}\n\nconst stringAsciiCV = (data: string): StringAsciiCV => {\n  return { type: ClarityType.StringASCII, data };\n};\n\nconst stringUtf8CV = (data: string): StringUtf8CV => {\n  return { type: ClarityType.StringUTF8, data };\n};\n\nconst stringCV = (data: string, encoding: 'ascii' | 'utf8'): StringAsciiCV | StringUtf8CV => {\n  switch (encoding) {\n    case 'ascii':\n      return stringAsciiCV(data);\n    case 'utf8':\n      return stringAsciiCV(data);\n  }\n};\n\nexport { StringAsciiCV, StringUtf8CV, stringAsciiCV, stringUtf8CV, stringCV };\n","import { serializeAddress, serializeLPString, createLPString } from '../types';\nimport {\n  BooleanCV,\n  OptionalCV,\n  BufferCV,\n  IntCV,\n  UIntCV,\n  StandardPrincipalCV,\n  ContractPrincipalCV,\n  ResponseCV,\n  ListCV,\n  TupleCV,\n  ClarityType,\n  ClarityValue,\n} from '.';\nimport { BufferArray } from '../utils';\nimport { SerializationError } from '../errors';\nimport { StringAsciiCV, StringUtf8CV } from './types/stringCV';\n\nfunction bufferWithTypeID(typeId: ClarityType, buffer: Buffer): Buffer {\n  const id = Buffer.from([typeId]);\n  return Buffer.concat([id, buffer]);\n}\n\nfunction serializeBoolCV(value: BooleanCV): Buffer {\n  return Buffer.from([value.type]);\n}\n\nfunction serializeOptionalCV(cv: OptionalCV): Buffer {\n  if (cv.type === ClarityType.OptionalNone) {\n    return Buffer.from([cv.type]);\n  } else {\n    return bufferWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv: BufferCV): Buffer {\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.buffer.length, 0);\n  return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));\n}\n\nfunction serializeIntCV(cv: IntCV | UIntCV): Buffer {\n  const buffer = cv.value.toArrayLike(Buffer, 'be', 16);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeStandardPrincipalCV(cv: StandardPrincipalCV): Buffer {\n  return bufferWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv: ContractPrincipalCV): Buffer {\n  return bufferWithTypeID(\n    cv.type,\n    Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)])\n  );\n}\n\nfunction serializeResponseCV(cv: ResponseCV) {\n  return bufferWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv: ListCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.list.length, 0);\n  buffers.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeTupleCV(cv: TupleCV) {\n  const buffers = new BufferArray();\n\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(Object.keys(cv.data).length, 0);\n  buffers.push(length);\n\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {\n    const bufA = Buffer.from(a);\n    const bufB = Buffer.from(b);\n    return bufA.compare(bufB);\n  });\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    buffers.push(serializeLPString(nameWithLength));\n\n    const serializedValue = serializeCV(cv.data[key]);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringCV(cv: StringAsciiCV | StringUtf8CV, encoding: 'ascii' | 'utf8') {\n  const buffers = new BufferArray();\n\n  const str = Buffer.from(cv.data, encoding);\n  const len = Buffer.alloc(4);\n  len.writeUInt32BE(str.length, 0);\n\n  buffers.push(len);\n  buffers.push(str);\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringAsciiCV(cv: StringAsciiCV) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv: StringUtf8CV) {\n  return serializeStringCV(cv, 'utf8');\n}\n\nexport function serializeCV(value: ClarityValue): Buffer {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n    case ClarityType.Int:\n    case ClarityType.UInt:\n      return serializeIntCV(value);\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n    case ClarityType.List:\n      return serializeListCV(value);\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}\n","import { SmartBuffer, SmartBufferOptions } from 'smart-buffer';\n\nfunction createEnumChecker<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue }\n): (value: number) => value is TEnumValue {\n  // Create a set of valid enum number values.\n  const enumValues = Object.values<number>(enumVariable).filter(v => typeof v === 'number');\n  const enumValueSet = new Set<number>(enumValues);\n  return (value: number): value is TEnumValue => enumValueSet.has(value);\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst enumCheckFunctions = new Map<object, (value: number) => boolean>();\n\n/**\n * Type guard to check if a given value is a valid enum value.\n * @param enumVariable - Literal `enum` type.\n * @param value - A value to check against the enum's values.\n * @example\n * ```ts\n * enum Color {\n *   Purple = 3,\n *   Orange = 5\n * }\n * const val: number = 3;\n * if (isEnum(Color, val)) {\n *   // `val` is known as enum type `Color`, e.g.:\n *   const colorVal: Color = val;\n * }\n * ```\n */\nexport function isEnum<T extends string, TEnumValue extends number>(\n  enumVariable: { [key in T]: TEnumValue },\n  value: number\n): value is TEnumValue {\n  const checker = enumCheckFunctions.get(enumVariable);\n  if (checker !== undefined) {\n    return checker(value);\n  }\n  const newChecker = createEnumChecker(enumVariable);\n  enumCheckFunctions.set(enumVariable, newChecker);\n  return isEnum(enumVariable, value);\n}\n\nexport class BufferReader {\n  smartBuffer: SmartBuffer;\n\n  static fromBuffer(buffer: Buffer): BufferReader {\n    return new BufferReader({ buff: buffer });\n  }\n\n  constructor(options?: SmartBufferOptions | Buffer) {\n    if (Buffer.isBuffer(options)) {\n      this.smartBuffer = new SmartBuffer({ buff: options });\n    } else {\n      this.smartBuffer = new SmartBuffer(options);\n    }\n  }\n\n  readBuffer(length: number): Buffer {\n    return this.smartBuffer.readBuffer(length);\n  }\n\n  readUInt32BE(offset?: number): number {\n    return this.smartBuffer.readUInt32BE(offset);\n  }\n\n  readUInt8(): number {\n    return this.smartBuffer.readUInt8();\n  }\n\n  readUInt16BE(): number {\n    return this.smartBuffer.readUInt16BE();\n  }\n\n  readBigUIntLE(length: number): bigint {\n    const buffer = Buffer.from(this.smartBuffer.readBuffer(length)).reverse();\n    const hex = buffer.toString();\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUIntBE(length: number): bigint {\n    const buffer = this.smartBuffer.readBuffer(length);\n    const hex = buffer.toString('hex');\n    const num = BigInt(`0x${hex}`);\n    return num;\n  }\n\n  readBigUInt64BE(): bigint {\n    return this.smartBuffer.readBigUInt64BE();\n  }\n\n  readString(arg?: number | BufferEncoding, encoding?: BufferEncoding): string {\n    return this.smartBuffer.readString(arg, encoding);\n  }\n\n  get readOffset(): number {\n    return this.smartBuffer.readOffset;\n  }\n\n  set readOffset(val: number) {\n    this.smartBuffer.readOffset = val;\n  }\n\n  get internalBuffer(): Buffer {\n    return this.smartBuffer.internalBuffer;\n  }\n\n  readUInt8Enum<T extends string, TEnumValue extends number>(\n    enumVariable: { [key in T]: TEnumValue },\n    invalidEnumErrorFormatter: (val: number) => Error\n  ): TEnumValue {\n    const num = this.smartBuffer.readUInt8();\n    if (isEnum(enumVariable, num)) {\n      return num;\n    } else {\n      throw invalidEnumErrorFormatter(num);\n    }\n  }\n}\n","import {\n  ClarityType,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCV,\n  trueCV,\n  falseCV,\n  standardPrincipalCVFromAddress,\n  contractPrincipalCVFromAddress,\n  responseOkCV,\n  responseErrorCV,\n  noneCV,\n  someCV,\n  listCV,\n  tupleCV,\n} from '.';\nimport { BufferReader } from '../bufferReader';\nimport { deserializeAddress, deserializeLPString } from '../types';\nimport { DeserializationError } from '../errors';\nimport { stringAsciiCV, stringUtf8CV } from './types/stringCV';\n\nexport default function deserializeCV(buffer: BufferReader | Buffer): ClarityValue {\n  const bufferReader = Buffer.isBuffer(buffer) ? new BufferReader(buffer) : buffer;\n  const type = bufferReader.readUInt8Enum(ClarityType, n => {\n    throw new DeserializationError(`Cannot recognize Clarity Type: ${n}`);\n  });\n\n  switch (type) {\n    case ClarityType.Int:\n      return intCV(bufferReader.readBuffer(16));\n\n    case ClarityType.UInt:\n      return uintCV(bufferReader.readBuffer(16));\n\n    case ClarityType.Buffer:\n      const bufferLength = bufferReader.readUInt32BE();\n      return bufferCV(bufferReader.readBuffer(bufferLength));\n\n    case ClarityType.BoolTrue:\n      return trueCV();\n\n    case ClarityType.BoolFalse:\n      return falseCV();\n\n    case ClarityType.PrincipalStandard:\n      const sAddress = deserializeAddress(bufferReader);\n      return standardPrincipalCVFromAddress(sAddress);\n\n    case ClarityType.PrincipalContract:\n      const cAddress = deserializeAddress(bufferReader);\n      const contractName = deserializeLPString(bufferReader);\n      return contractPrincipalCVFromAddress(cAddress, contractName);\n\n    case ClarityType.ResponseOk:\n      return responseOkCV(deserializeCV(bufferReader));\n\n    case ClarityType.ResponseErr:\n      return responseErrorCV(deserializeCV(bufferReader));\n\n    case ClarityType.OptionalNone:\n      return noneCV();\n\n    case ClarityType.OptionalSome:\n      return someCV(deserializeCV(bufferReader));\n\n    case ClarityType.List:\n      const listLength = bufferReader.readUInt32BE();\n      const listContents: ClarityValue[] = [];\n      for (let i = 0; i < listLength; i++) {\n        listContents.push(deserializeCV(bufferReader));\n      }\n      return listCV(listContents);\n\n    case ClarityType.Tuple:\n      const tupleLength = bufferReader.readUInt32BE();\n      const tupleContents: { [key: string]: ClarityValue } = {};\n      for (let i = 0; i < tupleLength; i++) {\n        const clarityName = deserializeLPString(bufferReader).content;\n        if (clarityName === undefined) {\n          throw new DeserializationError('\"content\" is undefined');\n        }\n        tupleContents[clarityName] = deserializeCV(bufferReader);\n      }\n      return tupleCV(tupleContents);\n\n    case ClarityType.StringASCII:\n      const asciiStrLen = bufferReader.readUInt32BE();\n      const asciiStr = bufferReader.readBuffer(asciiStrLen).toString('ascii');\n      return stringAsciiCV(asciiStr);\n\n    case ClarityType.StringUTF8:\n      const utf8StrLen = bufferReader.readUInt32BE();\n      const utf8Str = bufferReader.readBuffer(utf8StrLen).toString('utf8');\n      return stringUtf8CV(utf8Str);\n\n    default:\n      throw new DeserializationError(\n        'Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.'\n      );\n  }\n}\n","import { sha256, sha512 } from 'sha.js';\nimport { ClarityValue, serializeCV } from './clarity';\nimport RIPEMD160 from 'ripemd160-min';\nimport randombytes from 'randombytes';\nimport { deserializeCV } from './clarity';\nimport fetch from 'cross-fetch';\nimport { c32addressDecode } from 'c32check';\nimport lodashCloneDeep from 'lodash/cloneDeep';\n\nexport { randombytes as randomBytes };\n\nexport class BufferArray {\n  _value: Buffer[] = [];\n  get value() {\n    return this._value;\n  }\n  appendHexString(hexString: string) {\n    this.value.push(Buffer.from(hexString, 'hex'));\n  }\n\n  push(buffer: Buffer) {\n    return this._value.push(buffer);\n  }\n  appendByte(octet: number) {\n    if (!Number.isInteger(octet) || octet < 0 || octet > 255) {\n      throw new Error(`Value ${octet} is not a valid byte`);\n    }\n    this.value.push(Buffer.from([octet]));\n  }\n\n  concatBuffer(): Buffer {\n    return Buffer.concat(this.value);\n  }\n}\n\nexport const leftPadHex = (hexString: string): string =>\n  hexString.length % 2 == 0 ? hexString : `0${hexString}`;\n\nexport const leftPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padStart(length, '0');\n\nexport const rightPadHexToLength = (hexString: string, length: number): string =>\n  hexString.padEnd(length, '0');\n\nexport const intToHexString = (integer: number, lengthBytes = 8): string =>\n  integer.toString(16).padStart(lengthBytes * 2, '0');\n\nexport const hexStringToInt = (hexString: string): number => parseInt(hexString, 16);\n\nexport const exceedsMaxLengthBytes = (string: string, maxLengthBytes: number): boolean =>\n  string ? Buffer.from(string).length > maxLengthBytes : false;\n\nexport function cloneDeep<T>(obj: T): T {\n  return lodashCloneDeep(obj);\n}\n\nexport function omit<T, K extends keyof any>(obj: T, prop: K): Omit<T, K> {\n  const clone = cloneDeep(obj);\n  // @ts-expect-error\n  delete clone[prop];\n  return clone;\n}\n\nexport class sha512_256 extends sha512 {\n  constructor() {\n    super();\n    // set the \"SHA-512/256\" initialization vector\n    // see https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\n    Object.assign(this, {\n      _ah: 0x22312194,\n      _al: 0xfc2bf72c,\n      _bh: 0x9f555fa3,\n      _bl: 0xc84c64c2,\n      _ch: 0x2393b86b,\n      _cl: 0x6f53b151,\n      _dh: 0x96387719,\n      _dl: 0x5940eabd,\n      _eh: 0x96283ee2,\n      _el: 0xa88effe3,\n      _fh: 0xbe5e1e25,\n      _fl: 0x53863992,\n      _gh: 0x2b0199fc,\n      _gl: 0x2c85b8aa,\n      _hh: 0x0eb72ddc,\n      _hl: 0x81c52ca2,\n    });\n  }\n  digest(): Buffer;\n  digest(encoding: import('crypto').HexBase64Latin1Encoding): string;\n  digest(encoding?: import('crypto').HexBase64Latin1Encoding): string | Buffer {\n    // \"SHA-512/256\" truncates the digest to 32 bytes\n    const buff = super.digest().slice(0, 32);\n    return encoding ? buff.toString(encoding) : buff;\n  }\n}\n\nexport const txidFromData = (data: Buffer): string => new sha512_256().update(data).digest('hex');\n\nexport const hash160 = (input: Buffer): Buffer => {\n  const sha256Result = new sha256().update(input).digest();\n  return Buffer.from(new RIPEMD160().update(sha256Result).digest());\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// single-sig address (p2pkh)\nexport const hashP2PKH = (input: Buffer): string => {\n  return hash160(input).toString('hex');\n};\n\n// Internally, the Stacks blockchain encodes address the same as Bitcoin\n// multi-sig address (p2sh)\nexport const hashP2SH = (numSigs: number, pubKeys: Buffer[]): string => {\n  if (numSigs > 15 || pubKeys.length > 15) {\n    throw Error('P2SH multisig address can only contain up to 15 public keys');\n  }\n\n  // construct P2SH script\n  const bufferArray = new BufferArray();\n  // OP_n\n  bufferArray.appendByte(80 + numSigs);\n  // public keys prepended by their length\n  pubKeys.forEach(pubKey => {\n    bufferArray.appendByte(pubKey.length);\n    bufferArray.push(pubKey);\n  });\n  // OP_m\n  bufferArray.appendByte(80 + pubKeys.length);\n  // OP_CHECKMULTISIG\n  bufferArray.appendByte(174);\n\n  const redeemScript = bufferArray.concatBuffer();\n  const redeemScriptHash = hash160(redeemScript);\n  return redeemScriptHash.toString('hex');\n};\n\nexport function isClarityName(name: string) {\n  const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;\n  return regex.test(name) && name.length < 128;\n}\n\n/** @ignore */\nexport async function fetchPrivate(input: RequestInfo, init?: RequestInit): Promise<Response> {\n  const defaultFetchOpts: RequestInit = {\n    referrer: 'no-referrer',\n    referrerPolicy: 'no-referrer',\n  };\n  const fetchOpts = Object.assign(defaultFetchOpts, init);\n  const fetchResult = await fetch(input, fetchOpts);\n  return fetchResult;\n}\n/**\n * Converts a clarity value to a hex encoded string with `0x` prefix\n * @param {ClarityValue} cv  - the clarity value to convert\n */\nexport function cvToHex(cv: ClarityValue) {\n  const serialized = serializeCV(cv);\n  return `0x${serialized.toString('hex')}`;\n}\n\n/**\n * Converts a hex encoded string to a clarity value\n * @param {string} hex - the hex encoded string with or without `0x` prefix\n */\nexport function hexToCV(hex: string) {\n  const hexWithoutPrefix = hex.startsWith('0x') ? hex.slice(2) : hex;\n  const bufferCV = Buffer.from(hexWithoutPrefix, 'hex');\n  return deserializeCV(bufferCV);\n}\n/**\n * Read only function response object\n *\n * @param {Boolean} okay - the status of the response\n * @param {string} result - serialized hex clarity value\n */\n\nexport interface ReadOnlyFunctionResponse {\n  okay: boolean;\n  result: string;\n}\n\n/**\n * Converts the response of a read-only function call into its Clarity Value\n * @param param\n */\nexport const parseReadOnlyResponse = ({ result }: ReadOnlyFunctionResponse): ClarityValue => {\n  return hexToCV(result);\n};\n\nexport const validateStacksAddress = (stacksAddress: string): boolean => {\n  try {\n    c32addressDecode(stacksAddress);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n","import {\n  AuthType,\n  AddressHashMode,\n  PubKeyEncoding,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  SingleSigHashMode,\n  MultiSigHashMode,\n  StacksMessageType,\n} from './constants';\n\nimport { BufferArray, txidFromData, leftPadHex, cloneDeep } from './utils';\n\nimport {\n  addressFromPublicKeys,\n  deserializeLPList,\n  createLPList,\n  serializeLPList,\n  createEmptyAddress,\n} from './types';\n\nimport {\n  StacksPublicKey,\n  StacksPrivateKey,\n  createStacksPublicKey,\n  isCompressed,\n  signWithKey,\n  getPublicKey,\n  serializePublicKey,\n  deserializePublicKey,\n  publicKeyFromSignature,\n} from './keys';\n\nimport BigNum from 'bn.js';\nimport { BufferReader } from './bufferReader';\nimport { SerializationError, DeserializationError, SigningError } from './errors';\n\nabstract class Deserializable {\n  abstract serialize(): Buffer;\n  abstract deserialize(bufferReader: BufferReader): void;\n  static deserialize<T extends Deserializable>(this: new () => T, bufferReader: BufferReader): T {\n    const message = new this();\n    message.deserialize(bufferReader);\n    return message;\n  }\n}\n\nexport interface MessageSignature {\n  readonly type: StacksMessageType.MessageSignature;\n  data: string;\n}\n\nexport function createMessageSignature(signature: string): MessageSignature {\n  const length = Buffer.from(signature, 'hex').byteLength;\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature,\n  };\n}\n\nexport function emptyMessageSignature(): MessageSignature {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),\n  };\n}\n\nexport function serializeMessageSignature(messageSignature: MessageSignature): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature {\n  return createMessageSignature(\n    bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex')\n  );\n}\n\nenum AuthFieldType {\n  PublicKey = 0x00,\n  Signature = 0x02,\n}\n\nexport type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;\n\nexport interface TransactionAuthField {\n  type: StacksMessageType.TransactionAuthField;\n  contents: TransactionAuthFieldContents;\n}\n\nexport function createTransactionAuthField(\n  contents: TransactionAuthFieldContents\n): TransactionAuthField {\n  return {\n    type: StacksMessageType.TransactionAuthField,\n    contents,\n  };\n}\n\nexport function serializeTransactionAuthField(field: TransactionAuthField): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      bufferArray.appendByte(AuthFieldType.PublicKey);\n      bufferArray.push(serializePublicKey(field.contents));\n      break;\n    case StacksMessageType.MessageSignature:\n      bufferArray.appendByte(AuthFieldType.Signature);\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKey:\n      return createTransactionAuthField(deserializePublicKey(bufferReader));\n    case AuthFieldType.Signature:\n      return createTransactionAuthField(deserializeMessageSignature(bufferReader));\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\n\nexport interface SingleSigSpendingCondition {\n  hashMode: SingleSigHashMode;\n  signer: string;\n  nonce: BigNum;\n  fee: BigNum;\n  keyEncoding: PubKeyEncoding;\n  signature: MessageSignature;\n}\n\nexport interface MultiSigSpendingCondition {\n  hashMode: MultiSigHashMode;\n  signer: string;\n  nonce: BigNum;\n  fee: BigNum;\n  fields: TransactionAuthField[];\n  signaturesRequired: number;\n}\n\nexport type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;\n\nexport function createSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  pubKey: string,\n  nonce: BigNum,\n  fee: BigNum\n): SingleSigSpendingCondition {\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature: emptyMessageSignature(),\n  };\n}\n\nexport function createMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  numSigs: number,\n  pubKeys: string[],\n  nonce: BigNum,\n  fee: BigNum\n): MultiSigSpendingCondition {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n\n  // address version arg doesn't matter for signer hash generation\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields: [],\n    signaturesRequired: numSigs,\n  };\n}\n\nexport function isSingleSig(condition: SpendingCondition): condition is SingleSigSpendingCondition {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition: SpendingCondition): SpendingCondition {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = new BigNum(0);\n  cloned.fee = new BigNum(0);\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return cloned;\n}\n\nexport function serializeSingleSigSpendingCondition(condition: SingleSigSpendingCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));\n  bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\n\nexport function serializeMultiSigSpendingCondition(condition: MultiSigSpendingCondition): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(condition.nonce.toArrayLike(Buffer, 'be', 8));\n  bufferArray.push(condition.fee.toArrayLike(Buffer, 'be', 8));\n\n  const fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n\n  const numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\n\nexport function deserializeSingleSigSpendingCondition(\n  hashMode: SingleSigHashMode,\n  bufferReader: BufferReader\n): SingleSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n  const fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n\n  const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  const signature = deserializeMessageSignature(bufferReader);\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature,\n  };\n}\n\nexport function deserializeMultiSigSpendingCondition(\n  hashMode: MultiSigHashMode,\n  bufferReader: BufferReader\n): MultiSigSpendingCondition {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n  const fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);\n\n  const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField)\n    .values as TransactionAuthField[];\n\n  const signaturesRequired = bufferReader.readUInt16BE();\n\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired,\n  };\n}\n\nexport function serializeSpendingCondition(condition: SpendingCondition): Buffer {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\n\nexport function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition {\n  const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\n\nexport function makeSigHashPreSign(\n  curSigHash: string,\n  authType: AuthType,\n  fee: BigNum,\n  nonce: BigNum\n): string {\n  // new hash combines the previous hash and all the new data this signature will add. This\n  // includes:\n  // * the previous hash\n  // * the auth flag\n  // * the tx fee (big-endian 8-byte number)\n  // * nonce (big-endian 8-byte number)\n  const hashLength = 32 + 1 + 8 + 8;\n\n  const sigHash =\n    curSigHash +\n    Buffer.from([authType]).toString('hex') +\n    fee.toArrayLike(Buffer, 'be', 8).toString('hex') +\n    nonce.toArrayLike(Buffer, 'be', 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(\n  curSigHash: string,\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n): string {\n  // new hash combines the previous hash and all the new data this signature will add.  This\n  // includes:\n  // * the public key compression flag\n  // * the signature\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n\n  if (Buffer.from(sigHash, 'hex').byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nexport function nextSignature(\n  curSigHash: string,\n  authType: AuthType,\n  fee: BigNum,\n  nonce: BigNum,\n  privateKey: StacksPrivateKey\n): {\n  nextSig: MessageSignature;\n  nextSigHash: string;\n} {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const publicKeyEncoding = isCompressed(publicKey)\n    ? PubKeyEncoding.Compressed\n    : PubKeyEncoding.Uncompressed;\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKeyEncoding, signature);\n\n  return {\n    nextSig: signature,\n    nextSigHash,\n  };\n}\n\nexport function nextVerification(\n  initialSigHash: string,\n  authType: AuthType,\n  fee: BigNum,\n  nonce: BigNum,\n  // @ts-ignore\n  pubKeyEncoding: PubKeyEncoding,\n  signature: MessageSignature\n) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n\n  const publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature));\n\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, PubKeyEncoding.Compressed, signature);\n\n  return {\n    pubKey: publicKey,\n    nextSigHash,\n  };\n}\n\nfunction newInitialSigHash(): SpendingCondition {\n  const spendingCondition = createSingleSigSpendingCondition(\n    AddressHashMode.SerializeP2PKH,\n    '',\n    new BigNum(0),\n    new BigNum(0)\n  );\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(condition: SpendingCondition, initialSigHash: string, authType: AuthType): string {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    // TODO: verify multisig\n    return '';\n  }\n}\n\nfunction verifySingleSig(\n  condition: SingleSigSpendingCondition,\n  initialSigHash: string,\n  authType: AuthType\n): string {\n  const { nextSigHash } = nextVerification(\n    initialSigHash,\n    authType,\n    condition.fee,\n    condition.nonce,\n    condition.keyEncoding,\n    condition.signature\n  );\n\n  // TODO: verify pub key\n\n  return nextSigHash;\n}\n\nexport class Authorization extends Deserializable {\n  authType?: AuthType;\n  spendingCondition?: SpendingCondition;\n  sponsorSpendingCondition?: SpendingCondition;\n\n  constructor(\n    authType?: AuthType,\n    spendingConditions?: SpendingCondition,\n    sponsorSpendingCondition?: SpendingCondition\n  ) {\n    super();\n    this.authType = authType;\n    this.spendingCondition = spendingConditions;\n    this.sponsorSpendingCondition = sponsorSpendingCondition;\n  }\n\n  intoInitialSighashAuth(): Authorization {\n    if (this.spendingCondition) {\n      switch (this.authType) {\n        case AuthType.Standard:\n          return new Authorization(AuthType.Standard, clearCondition(this.spendingCondition));\n        case AuthType.Sponsored:\n          return new Authorization(\n            AuthType.Sponsored,\n            clearCondition(this.spendingCondition),\n            newInitialSigHash()\n          );\n        default:\n          throw new SigningError('Unexpected authorization type for signing');\n      }\n    }\n\n    throw new Error('Authorization missing SpendingCondition');\n  }\n\n  setFee(amount: BigNum) {\n    switch (this.authType) {\n      case AuthType.Standard:\n        this.spendingCondition!.fee = amount;\n        break;\n      case AuthType.Sponsored:\n        this.sponsorSpendingCondition!.fee = amount;\n        break;\n    }\n  }\n\n  getFee() {\n    switch (this.authType) {\n      case AuthType.Standard:\n        return this.spendingCondition!.fee;\n      case AuthType.Sponsored:\n        return this.sponsorSpendingCondition!.fee;\n      default:\n        return 0;\n    }\n  }\n\n  setNonce(nonce: BigNum) {\n    this.spendingCondition!.nonce = nonce;\n  }\n\n  setSponsorNonce(nonce: BigNum) {\n    this.sponsorSpendingCondition!.nonce = nonce;\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingCondition) {\n    this.sponsorSpendingCondition = sponsorSpendingCondition;\n  }\n\n  verifyOrigin(initialSigHash: string): string {\n    switch (this.authType) {\n      case AuthType.Standard:\n        return verify(this.spendingCondition!, initialSigHash, AuthType.Standard);\n      case AuthType.Sponsored:\n        return verify(this.spendingCondition!, initialSigHash, AuthType.Standard);\n      default:\n        throw new SigningError('Invalid origin auth type');\n    }\n  }\n\n  serialize(): Buffer {\n    const bufferArray: BufferArray = new BufferArray();\n    if (this.authType === undefined) {\n      throw new SerializationError('\"authType\" is undefined');\n    }\n    bufferArray.appendByte(this.authType);\n\n    switch (this.authType) {\n      case AuthType.Standard:\n        if (this.spendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n        bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n        break;\n      case AuthType.Sponsored:\n        if (this.spendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n        if (this.sponsorSpendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n        bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n        bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));\n        break;\n      default:\n        throw new SerializationError(\n          `Unexpected transaction AuthType while serializing: ${JSON.stringify(this.authType)}`\n        );\n    }\n\n    return bufferArray.concatBuffer();\n  }\n\n  deserialize(bufferReader: BufferReader) {\n    this.authType = bufferReader.readUInt8Enum(AuthType, n => {\n      throw new DeserializationError(`Could not parse ${n} as AuthType`);\n    });\n\n    switch (this.authType) {\n      case AuthType.Standard:\n        this.spendingCondition = deserializeSpendingCondition(bufferReader);\n        break;\n      case AuthType.Sponsored:\n        this.spendingCondition = deserializeSpendingCondition(bufferReader);\n        this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n        break;\n      // throw new DeserializationError('Not yet implemented: deserializing sponsored transactions');\n      default:\n        throw new DeserializationError(\n          `Unexpected transaction AuthType while deserializing: ${JSON.stringify(this.authType)}`\n        );\n    }\n  }\n}\n\nexport class StandardAuthorization extends Authorization {\n  constructor(spendingCondition: SpendingCondition) {\n    super(AuthType.Standard, spendingCondition);\n  }\n}\n\nexport class SponsoredAuthorization extends Authorization {\n  constructor(\n    originSpendingCondition: SpendingCondition,\n    sponsorSpendingCondition?: SpendingCondition\n  ) {\n    let sponsorSC = sponsorSpendingCondition;\n    if (!sponsorSC) {\n      sponsorSC = createSingleSigSpendingCondition(\n        AddressHashMode.SerializeP2PKH,\n        '0'.repeat(66),\n        new BigNum(0),\n        new BigNum(0)\n      );\n    }\n    super(AuthType.Sponsored, originSpendingCondition, sponsorSC);\n  }\n}\n","import { cloneDeep } from './utils';\nimport {\n  ClarityValue,\n  uintCV,\n  intCV,\n  contractPrincipalCV,\n  standardPrincipalCV,\n  noneCV,\n  bufferCV,\n  falseCV,\n  trueCV,\n  ClarityType,\n  getCVTypeString,\n  bufferCVFromString,\n} from './clarity';\nimport { ContractCallPayload } from './payload';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\n\n// From https://github.com/blockstack/stacks-blockchain-sidecar/blob/master/src/event-stream/contract-abi.ts\n\nexport type ClarityAbiTypeBuffer = { buffer: { length: number } };\nexport type ClarityAbiTypeStringAscii = { 'string-ascii': { length: number } };\nexport type ClarityAbiTypeStringUtf8 = { 'string-utf8': { length: number } };\nexport type ClarityAbiTypeResponse = { response: { ok: ClarityAbiType; error: ClarityAbiType } };\nexport type ClarityAbiTypeOptional = { optional: ClarityAbiType };\nexport type ClarityAbiTypeTuple = { tuple: { name: string; type: ClarityAbiType }[] };\nexport type ClarityAbiTypeList = { list: { type: ClarityAbiType; length: number } };\n\nexport type ClarityAbiTypeUInt128 = 'uint128';\nexport type ClarityAbiTypeInt128 = 'int128';\nexport type ClarityAbiTypeBool = 'bool';\nexport type ClarityAbiTypePrincipal = 'principal';\nexport type ClarityAbiTypeTraitReference = 'trait_reference';\nexport type ClarityAbiTypeNone = 'none';\n\nexport type ClarityAbiTypePrimitive =\n  | ClarityAbiTypeUInt128\n  | ClarityAbiTypeInt128\n  | ClarityAbiTypeBool\n  | ClarityAbiTypePrincipal\n  | ClarityAbiTypeTraitReference\n  | ClarityAbiTypeNone;\n\nexport type ClarityAbiType =\n  | ClarityAbiTypePrimitive\n  | ClarityAbiTypeBuffer\n  | ClarityAbiTypeResponse\n  | ClarityAbiTypeOptional\n  | ClarityAbiTypeTuple\n  | ClarityAbiTypeList\n  | ClarityAbiTypeStringAscii\n  | ClarityAbiTypeStringUtf8\n  | ClarityAbiTypeTraitReference;\n\nexport enum ClarityAbiTypeId {\n  ClarityAbiTypeUInt128 = 1,\n  ClarityAbiTypeInt128 = 2,\n  ClarityAbiTypeBool = 3,\n  ClarityAbiTypePrincipal = 4,\n  ClarityAbiTypeNone = 5,\n  ClarityAbiTypeBuffer = 6,\n  ClarityAbiTypeResponse = 7,\n  ClarityAbiTypeOptional = 8,\n  ClarityAbiTypeTuple = 9,\n  ClarityAbiTypeList = 10,\n  ClarityAbiTypeStringAscii = 11,\n  ClarityAbiTypeStringUtf8 = 12,\n  ClarityAbiTypeTraitReference = 13,\n}\n\nexport const isClarityAbiPrimitive = (val: ClarityAbiType): val is ClarityAbiTypePrimitive =>\n  typeof val === 'string';\nexport const isClarityAbiBuffer = (val: ClarityAbiType): val is ClarityAbiTypeBuffer =>\n  (val as ClarityAbiTypeBuffer).buffer !== undefined;\nexport const isClarityAbiStringAscii = (val: ClarityAbiType): val is ClarityAbiTypeStringAscii =>\n  (val as ClarityAbiTypeStringAscii)['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = (val: ClarityAbiType): val is ClarityAbiTypeStringUtf8 =>\n  (val as ClarityAbiTypeStringUtf8)['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = (val: ClarityAbiType): val is ClarityAbiTypeResponse =>\n  (val as ClarityAbiTypeResponse).response !== undefined;\nexport const isClarityAbiOptional = (val: ClarityAbiType): val is ClarityAbiTypeOptional =>\n  (val as ClarityAbiTypeOptional).optional !== undefined;\nexport const isClarityAbiTuple = (val: ClarityAbiType): val is ClarityAbiTypeTuple =>\n  (val as ClarityAbiTypeTuple).tuple !== undefined;\nexport const isClarityAbiList = (val: ClarityAbiType): val is ClarityAbiTypeList =>\n  (val as ClarityAbiTypeList).list !== undefined;\n\nexport type ClarityAbiTypeUnion =\n  | { id: ClarityAbiTypeId.ClarityAbiTypeUInt128; type: ClarityAbiTypeUInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeInt128; type: ClarityAbiTypeInt128 }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBool; type: ClarityAbiTypeBool }\n  | { id: ClarityAbiTypeId.ClarityAbiTypePrincipal; type: ClarityAbiTypePrincipal }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference; type: ClarityAbiTypeTraitReference }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeNone; type: ClarityAbiTypeNone }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeBuffer; type: ClarityAbiTypeBuffer }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeResponse; type: ClarityAbiTypeResponse }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeOptional; type: ClarityAbiTypeOptional }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeTuple; type: ClarityAbiTypeTuple }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeList; type: ClarityAbiTypeList }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii; type: ClarityAbiTypeStringAscii }\n  | { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8; type: ClarityAbiTypeStringUtf8 };\n\nexport function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };\n    } else if (val === 'int128') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };\n    } else if (val === 'bool') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };\n    } else if (val === 'principal') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };\n    } else if (val === 'trait_reference') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };\n    } else if (val === 'none') {\n      return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };\n  } else if (isClarityAbiResponse(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };\n  } else if (isClarityAbiOptional(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };\n  } else if (isClarityAbiTuple(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };\n  } else if (isClarityAbiList(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };\n  } else if (isClarityAbiStringAscii(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\nfunction encodeClarityValue(type: ClarityAbiType, val: string): ClarityValue;\nfunction encodeClarityValue(type: ClarityAbiTypeUnion, val: string): ClarityValue;\nfunction encodeClarityValue(\n  input: ClarityAbiTypeUnion | ClarityAbiType,\n  val: string\n): ClarityValue {\n  let union: ClarityAbiTypeUnion;\n  if ((input as ClarityAbiTypeUnion).id !== undefined) {\n    union = input as ClarityAbiTypeUnion;\n  } else {\n    union = getTypeUnion(input as ClarityAbiType);\n  }\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();\n      else if (val === 'true' || val === '1') return trueCV();\n      else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(Buffer.from(val, 'utf8'));\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\nexport { encodeClarityValue };\n\nexport function getTypeString(val: ClarityAbiType): string {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\n\nexport interface ClarityAbiFunction {\n  name: string;\n  access: 'private' | 'public' | 'read_only';\n  args: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  outputs: {\n    type: ClarityAbiType;\n  };\n}\n\nexport function abiFunctionToString(func: ClarityAbiFunction): string {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args\n    .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)\n    .join(' ')}))`;\n}\n\nexport interface ClarityAbiVariable {\n  name: string;\n  access: 'variable' | 'constant';\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbiMap {\n  name: string;\n  key: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n  value: {\n    name: string;\n    type: ClarityAbiType;\n  }[];\n}\n\nexport interface ClarityAbiTypeFungibleToken {\n  name: string;\n}\n\nexport interface ClarityAbiTypeNonFungibleToken {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport interface ClarityAbi {\n  functions: ClarityAbiFunction[];\n  variables: ClarityAbiVariable[];\n  maps: ClarityAbiMap[];\n  fungible_tokens: ClarityAbiTypeFungibleToken[];\n  non_fungible_tokens: ClarityAbiTypeNonFungibleToken[];\n}\n\nfunction matchType(cv: ClarityValue, abiType: ClarityAbiType): boolean {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n    case ClarityType.Buffer:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&\n        union.type.buffer.length >= cv.buffer.length\n      );\n    case ClarityType.StringASCII:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&\n        union.type['string-ascii'].length >= cv.data.length\n      );\n    case ClarityType.StringUTF8:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&\n        union.type['string-utf8'].length >= cv.data.length\n      );\n    case ClarityType.OptionalNone:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional\n      );\n    case ClarityType.OptionalSome:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&\n        matchType(cv.value, union.type.optional)\n      );\n    case ClarityType.ResponseErr:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.error)\n      );\n    case ClarityType.ResponseOk:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n        matchType(cv.value, union.type.response.ok)\n      );\n    case ClarityType.PrincipalContract:\n      return (\n        union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||\n        union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference\n      );\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n    case ClarityType.List:\n      return (\n        union.id == ClarityAbiTypeId.ClarityAbiTypeList &&\n        union.type.list.length === cv.list.length &&\n        cv.list.every(val => matchType(val, union.type.list.type))\n      );\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          // if key exists in cv tuple, check if its type matches the abi\n          // return false if key doesn't exist\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\n/**\n * Validates a contract-call payload with a contract ABI\n *\n * @param {ContractCallPayload} payload - a contract-call payload\n * @param {ClarityAbi} abi - a contract ABI\n *\n * @returns {boolean} true if the payloads functionArgs type check against those in the ABI\n */\nexport function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(\n        `Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`\n      );\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(\n          `Clarity function \\`${\n            payload.functionName.content\n          }\\` expects argument ${argNum} to be of type ${getTypeString(\n            abiArg.type\n          )}, not ${getCVTypeString(payloadArg)}`\n        );\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(\n      `Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`\n    );\n  }\n}\n\n/**\n * Convert string input to Clarity value based on contract ABI data. Only handles Clarity\n * primitives and buffers. Responses, optionals, tuples and lists are not supported.\n *\n * @param {string} input - string to be parsed into Clarity value\n * @param {ClarityAbiType} type - the contract function argument object\n *\n * @returns {ClarityValue} returns a Clarity value\n */\nexport function parseToCV(input: string, type: ClarityAbiType): ClarityValue {\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = Buffer.from(input).byteLength;\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n","import {\n  DEFAULT_CHAIN_ID,\n  TransactionVersion,\n  PayloadType,\n  AnchorMode,\n  PostConditionMode,\n  AuthType,\n  StacksMessageType,\n  ChainID,\n} from './constants';\n\nimport {\n  Authorization,\n  SpendingCondition,\n  nextSignature,\n  isSingleSig,\n  SingleSigSpendingCondition,\n  createTransactionAuthField,\n  createMessageSignature,\n} from './authorization';\n\nimport { BufferArray, txidFromData, cloneDeep } from './utils';\n\nimport { Payload, serializePayload, deserializePayload } from './payload';\n\nimport { LengthPrefixedList, serializeLPList, deserializeLPList, createLPList } from './types';\n\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\n\nimport { BufferReader } from './bufferReader';\n\nimport BigNum from 'bn.js';\nimport { SerializationError, SigningError } from './errors';\n\nexport class StacksTransaction {\n  version: TransactionVersion;\n  chainId: ChainID;\n  auth: Authorization;\n  anchorMode: AnchorMode;\n  payload: Payload;\n  postConditionMode: PostConditionMode;\n  postConditions: LengthPrefixedList;\n\n  constructor(\n    version: TransactionVersion,\n    auth: Authorization,\n    payload: Payload,\n    postConditions?: LengthPrefixedList,\n    postConditionMode?: PostConditionMode,\n    anchorMode?: AnchorMode,\n    chainId?: ChainID\n  ) {\n    this.version = version;\n    this.auth = auth;\n    this.payload = payload;\n    this.chainId = chainId ?? DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode ?? PostConditionMode.Deny;\n    this.postConditions = postConditions ?? createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorMode;\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.PoisonMicroblock: {\n          this.anchorMode = AnchorMode.OnChainOnly;\n          break;\n        }\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.TokenTransfer: {\n          this.anchorMode = AnchorMode.Any;\n          break;\n        }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = tx.auth.intoInitialSighashAuth();\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = tx.auth.intoInitialSighashAuth();\n    return tx.txid();\n  }\n\n  createTxWithSignature(signature: string | Buffer): StacksTransaction {\n    const parsedSig = typeof signature === 'string' ? signature : signature.toString('hex');\n    const tx = cloneDeep(this);\n    if (!tx.auth.spendingCondition) {\n      throw new Error('Cannot set signature on transaction without spending condition');\n    }\n    (tx.auth.spendingCondition as SingleSigSpendingCondition).signature = createMessageSignature(\n      parsedSig\n    );\n    return tx;\n  }\n\n  verifyOrigin(): string {\n    return this.auth.verifyOrigin(this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): string {\n    if (this.auth.sponsorSpendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n    return this.signAndAppend(\n      this.auth.sponsorSpendingCondition,\n      sigHash,\n      AuthType.Sponsored,\n      privateKey\n    );\n  }\n\n  appendPubkey(publicKey: StacksPublicKey) {\n    const cond = this.auth.spendingCondition;\n    if (cond && !isSingleSig(cond)) {\n      cond.fields.push(createTransactionAuthField(publicKey));\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(\n    condition: SpendingCondition,\n    curSigHash: string,\n    authType: AuthType,\n    privateKey: StacksPrivateKey\n  ): string {\n    const { nextSig, nextSigHash } = nextSignature(\n      curSigHash,\n      authType,\n      condition.fee,\n      condition.nonce,\n      privateKey\n    );\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      condition.fields.push(createTransactionAuthField(nextSig));\n    }\n\n    return nextSigHash;\n  }\n\n  txid(): string {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition: SpendingCondition) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth.setSponsor(sponsorSpendingCondition);\n  }\n\n  /**\n   * Set the total fee to be paid for this transaction\n   *\n   * @param {BigNum} fee - the fee amount in microstacks\n   */\n  setFee(amount: BigNum) {\n    this.auth.setFee(amount);\n  }\n\n  /**\n   * Set the transaction nonce\n   *\n   * @param {BigNum} nonce - the nonce value\n   */\n  setNonce(nonce: BigNum) {\n    this.auth.setNonce(nonce);\n  }\n\n  /**\n   * Set the transaction sponsor nonce\n   *\n   * @param {BigNum} nonce - the sponsor nonce value\n   */\n  setSponsorNonce(nonce: BigNum) {\n    this.auth.setSponsorNonce(nonce);\n  }\n\n  serialize(): Buffer {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bufferArray: BufferArray = new BufferArray();\n\n    bufferArray.appendByte(this.version);\n    const chainIdBuffer = Buffer.alloc(4);\n    chainIdBuffer.writeUInt32BE(this.chainId, 0);\n    bufferArray.push(chainIdBuffer);\n    bufferArray.push(this.auth.serialize());\n    bufferArray.appendByte(this.anchorMode);\n    bufferArray.appendByte(this.postConditionMode);\n    bufferArray.push(serializeLPList(this.postConditions));\n    bufferArray.push(serializePayload(this.payload));\n\n    return bufferArray.concatBuffer();\n  }\n}\n\nexport function deserializeTransaction(bufferReader: BufferReader) {\n  const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bufferReader.readUInt32BE();\n  const auth = Authorization.deserialize(bufferReader);\n  const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bufferReader);\n\n  return new StacksTransaction(\n    version,\n    auth,\n    payload,\n    postConditions,\n    postConditionMode,\n    anchorMode,\n    chainId\n  );\n}\n","import { StacksTransaction } from './transaction';\n\nimport { StacksPrivateKey, StacksPublicKey } from './keys';\nimport { isSingleSig } from './authorization';\nimport { cloneDeep } from './utils';\nimport { SpendingCondition } from './authorization';\nimport { AuthType } from './constants';\nimport { SigningError } from './errors';\n\nexport class TransactionSigner {\n  transaction: StacksTransaction;\n  sigHash: string;\n  originDone: boolean;\n  checkOversign: boolean;\n  checkOverlap: boolean;\n\n  constructor(transaction: StacksTransaction) {\n    this.transaction = transaction;\n    this.sigHash = transaction.signBegin();\n    this.originDone = false;\n    this.checkOversign = true;\n    this.checkOverlap = true;\n  }\n\n  static createSponsorSigner(transaction: StacksTransaction, spendingCondition: SpendingCondition) {\n    if (transaction.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot add sponsor to non-sponsored transaction');\n    }\n\n    const tx: StacksTransaction = cloneDeep(transaction);\n    tx.setSponsor(spendingCondition);\n    const originSigHash = tx.verifyOrigin();\n    const signer = new this(tx);\n    signer.originDone = true;\n    signer.sigHash = originSigHash;\n    signer.checkOversign = true;\n    signer.checkOverlap = true;\n    return signer;\n  }\n\n  signOrigin(privateKey: StacksPrivateKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw new SigningError('Cannot sign origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    if (!isSingleSig(this.transaction.auth.spendingCondition)) {\n      const spendingCondition = this.transaction.auth.spendingCondition;\n      if (\n        this.checkOversign &&\n        spendingCondition.fields.length >= spendingCondition.signaturesRequired\n      ) {\n        throw new Error('Origin would have too many signatures');\n      }\n    }\n\n    const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n  }\n\n  appendOrigin(publicKey: StacksPublicKey) {\n    if (this.checkOverlap && this.originDone) {\n      throw Error('Cannot append public key to origin after sponsor key');\n    }\n\n    if (this.transaction.auth === undefined) {\n      throw new Error('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.spendingCondition === undefined) {\n      throw new Error('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    this.transaction.appendPubkey(publicKey);\n  }\n\n  signSponsor(privateKey: StacksPrivateKey) {\n    if (this.transaction.auth === undefined) {\n      throw new SigningError('\"transaction.auth\" is undefined');\n    }\n    if (this.transaction.auth.sponsorSpendingCondition === undefined) {\n      throw new SigningError('\"transaction.auth.spendingCondition\" is undefined');\n    }\n\n    const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);\n    this.sigHash = nextSighash;\n    this.originDone = true;\n  }\n\n  getTxInComplete(): StacksTransaction {\n    return cloneDeep(this.transaction);\n  }\n\n  resume(transaction: StacksTransaction) {\n    this.transaction = cloneDeep(transaction);\n    this.sigHash = transaction.signBegin();\n  }\n}\n","import { StacksTransaction } from './transaction';\n\nimport { StacksNetwork, StacksMainnet, StacksTestnet } from '@stacks/network';\n\nimport {\n  createTokenTransferPayload,\n  createSmartContractPayload,\n  createContractCallPayload,\n} from './payload';\n\nimport {\n  StandardAuthorization,\n  SponsoredAuthorization,\n  createSingleSigSpendingCondition,\n  createMultiSigSpendingCondition,\n} from './authorization';\n\nimport {\n  publicKeyToString,\n  createStacksPrivateKey,\n  getPublicKey,\n  publicKeyToAddress,\n  pubKeyfromPrivKey,\n  publicKeyFromBuffer,\n} from './keys';\n\nimport { TransactionSigner } from './signer';\n\nimport {\n  PostCondition,\n  STXPostCondition,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  createSTXPostCondition,\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n} from './postcondition';\n\nimport {\n  AddressHashMode,\n  AddressVersion,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PostConditionMode,\n  PayloadType,\n  AnchorMode,\n  TransactionVersion,\n  TxRejectedReason,\n  SingleSigHashMode,\n} from './constants';\n\nimport { AssetInfo, createLPList, createStandardPrincipal, createContractPrincipal } from './types';\n\nimport { cvToHex, parseReadOnlyResponse, omit } from './utils';\n\nimport { fetchPrivate } from '@stacks/common';\n\nimport BigNum from 'bn.js';\nimport { ClarityValue, PrincipalCV } from './clarity';\nimport { validateContractCall, ClarityAbi } from './contract-abi';\nimport { c32address } from 'c32check';\n\n/**\n * Lookup the nonce for an address from a core node\n *\n * @param {string} address - the c32check address to look up\n * @param {StacksNetwork} network - the Stacks network to look up address on\n *\n * @return a promise that resolves to an integer\n */\nexport async function getNonce(address: string, network?: StacksNetwork): Promise<BigNum> {\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getAccountApiUrl(address)\n    : defaultNetwork.getAccountApiUrl(address);\n\n  const response = await fetchPrivate(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const result = (await response.json()) as { nonce: string };\n  return new BigNum(result.nonce);\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetwork\n): Promise<BigNum> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getTransferFeeEstimateApiUrl()\n    : defaultNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await fetchPrivate(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = new BigNum(transaction.serialize().byteLength);\n  const feeRate = new BigNum(feeRateResult);\n  return feeRate.mul(txBytes);\n}\n\nexport type TxBroadcastResultOk = string;\nexport type TxBroadcastResultRejected = {\n  error: string;\n  reason: TxRejectedReason;\n  reason_data: any;\n  txid: string;\n};\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network: StacksNetwork\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const url = network.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Buffer} rawTx - the raw serialized transaction buffer to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Buffer,\n  url: string\n): Promise<TxBroadcastResult> {\n  const requestHeaders = {\n    'Content-Type': 'application/octet-stream',\n  };\n\n  const options = {\n    method: 'POST',\n    headers: requestHeaders,\n    body: rawTx,\n  };\n\n  const response = await fetchPrivate(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  try {\n    return JSON.parse(text) as TxBroadcastResult;\n  } catch (e) {\n    return text;\n  }\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const url = network.getAbiApiUrl(address, contractName);\n\n  const response = await fetchPrivate(url, options);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\n/**\n * STX token transfer transaction options\n *\n * @param  {String|PrincipalCV} recipientAddress - the c32check address of the recipient or a\n *                                                  principal clarity value\n * @param  {BigNum} amount - number of tokens to transfer in microstacks\n * @param  {BigNum} fee - transaction fee in microstacks\n * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {anchorMode} anchorMode - identify how the the transaction should be mined\n * @param  {String} memo - an arbitrary string to include with the transaction, must be less than\n *                          34 bytes\n * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all\n *                                                 transferred assets\n * @param  {PostCondition[]} postConditions - an array of post conditions to add to the\n *                                                  transaction\n * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees\n */\nexport interface TokenTransferOptions {\n  recipient: string | PrincipalCV;\n  amount: BigNum;\n  fee?: BigNum;\n  nonce?: BigNum;\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  memo?: string;\n  postConditionMode?: PostConditionMode;\n  postConditions?: PostCondition[];\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param  {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promis<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    nonce: new BigNum(0),\n    network: new StacksMainnet(),\n    anchorMode: AnchorMode.Any,\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization = null;\n  let spendingCondition = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    options.network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    defaultOptions.anchorMode,\n    options.network.chainId\n  );\n\n  if (!txOptions.fee) {\n    const txFee = await estimateTransfer(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (!txOptions.nonce) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param  {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n *\n * @param  {String} contractName - the contract name\n * @param  {String} codeBody - the code body string\n * @param  {String} senderKey - hex string sender private key used to sign transaction\n * @param  {BigNum} fee - transaction fee in microstacks\n * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {anchorMode} anchorMode - identify how the the transaction should be mined\n * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all\n *                                                 transferred assets\n * @param  {PostCondition[]} postConditions - an array of post conditions to add to the\n *                                                  transaction\n * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees\n */\nexport interface ContractDeployOptions {\n  contractName: string;\n  codeBody: string;\n  senderKey: string;\n  fee?: BigNum;\n  nonce?: BigNum;\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  postConditionMode?: PostConditionMode;\n  postConditions?: PostCondition[];\n  sponsored?: boolean;\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetwork\n): Promise<BigNum> {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getTransferFeeEstimateApiUrl()\n    : defaultNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await fetchPrivate(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = new BigNum(transaction.serialize().byteLength);\n  const feeRate = new BigNum(feeRateResult);\n  return feeRate.mul(txBytes);\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param  {ContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: ContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    nonce: new BigNum(0),\n    network: new StacksMainnet(),\n    anchorMode: AnchorMode.Any,\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(options.contractName, options.codeBody);\n\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const privKey = createStacksPrivateKey(options.senderKey);\n  const pubKey = getPublicKey(privKey);\n\n  let authorization = null;\n\n  const spendingCondition = createSingleSigSpendingCondition(\n    addressHashMode,\n    publicKeyToString(pubKey),\n    options.nonce,\n    options.fee\n  );\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    options.network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    options.network.chainId\n  );\n\n  if (!txOptions.fee) {\n    const txFee = await estimateContractDeploy(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (!txOptions.nonce) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  if (options.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n * @param  {String} contractAddress - the c32check address of the contract\n * @param  {String} contractName - the contract name\n * @param  {String} functionName - name of the function to be called\n * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param  {String} senderKey - hex string sender private key used to sign transaction\n * @param  {BigNum} fee - transaction fee in microstacks\n * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {anchorMode} anchorMode - identify how the the transaction should be mined\n * @param  {PostConditionMode} postConditionMode - whether post conditions must fully cover all\n *                                                 transferred assets\n * @param  {PostCondition[]} postConditions - an array of post conditions to add to the\n *                                                  transaction\n * @param  {Boolean} sponsored - true if another account is sponsoring the transaction fees\n */\nexport interface ContractCallOptions {\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  fee?: BigNum;\n  feeEstimateApiUrl?: string;\n  nonce?: BigNum;\n  network?: StacksNetwork;\n  anchorMode?: AnchorMode;\n  postConditionMode?: PostConditionMode;\n  postConditions?: PostCondition[];\n  validateWithAbi?: boolean | ClarityAbi;\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetwork\n): Promise<BigNum> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const defaultNetwork = new StacksMainnet();\n  const url = network\n    ? network.getTransferFeeEstimateApiUrl()\n    : defaultNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await fetchPrivate(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = new BigNum(transaction.serialize().byteLength);\n  const feeRate = new BigNum(feeRateResult);\n  return feeRate.mul(txBytes);\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    nonce: new BigNum(0),\n    network: new StacksMainnet(),\n    anchorMode: AnchorMode.Any,\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition = null;\n  let authorization = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    options.network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    options.network.chainId\n  );\n\n  if (!txOptions.fee) {\n    const txFee = await estimateContractFunctionCall(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (!txOptions.nonce) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param  {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of STX tokens\n *\n * @return {STXPostCondition}\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param  {String} address - the c32check address of the contract\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of STX tokens\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of fungible tokens\n * @param  {AssetInfo} assetInfo - asset info describing the fungible token\n *\n * @return {FungiblePostCondition}\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {BigNum} amount - the amount of fungible tokens\n * @param  {AssetInfo} assetInfo - asset info describing the fungible token\n *\n * @return {FungiblePostCondition}\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: BigNum,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param  {String} address - the c32check address\n * @param  {String} contractName - the name of the contract\n * @param  {FungibleConditionCode} conditionCode - the condition code\n * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param  {ClarityValue} assetName - asset name describing the non-fungible token\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetName: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetName\n  );\n}\n\n/**\n * Read only function options\n *\n * @param  {String} contractAddress - the c32check address of the contract\n * @param  {String} contractName - the contract name\n * @param  {String} functionName - name of the function to be called\n * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param  {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  network?: StacksNetwork;\n  senderAddress: string;\n}\n\n/**\n * Calls a read only function from a contract interface\n *\n * @param  {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const {\n    contractName,\n    contractAddress,\n    functionName,\n    functionArgs,\n    network,\n    senderAddress,\n  } = options;\n\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await fetchPrivate(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\n/**\n * Sponsored transaction options\n *\n * @param  {StacksTransaction} transaction - the origin-signed transaction to sponsor\n * @param  {String} sponsorPrivateKey - the sponsor's private key\n * @param  {BigNum} fee - the transaction fee amount to sponsor\n * @param  {BigNum} sponsorNonce - the nonce of the sponsor account\n * @param  {AddressHashMode} sponsorAddressHashmode - the sponsor address hashmode\n * @param  {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n */\nexport interface SponsorOptions {\n  transaction: StacksTransaction;\n  sponsorPrivateKey: string;\n  fee?: BigNum;\n  sponsorNonce?: BigNum;\n  sponsorAddressHashmode?: AddressHashMode;\n  network?: StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param  {SponsorOptions} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: new BigNum(0),\n    sponsorNonce: new BigNum(0),\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n  const network =\n    sponsorOptions.network ??\n    (options.transaction.version === TransactionVersion.Mainnet\n      ? new StacksMainnet()\n      : new StacksTestnet());\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (!sponsorOptions.fee) {\n    let txFee = new BigNum(0);\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n        txFee = await estimateTransfer(options.transaction, network);\n        break;\n      case PayloadType.SmartContract:\n        txFee = await estimateContractDeploy(options.transaction, network);\n        break;\n      case PayloadType.ContractCall:\n        txFee = await estimateContractFunctionCall(options.transaction, network);\n        break;\n      default:\n        throw new Error(\n          `Spnsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (!sponsorOptions.sponsorNonce) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return options.transaction;\n}\n"],"names":["ChainID","StacksMessageType","PayloadType","AnchorMode","TransactionVersion","DEFAULT_CHAIN_ID","Mainnet","PostConditionMode","PostConditionType","AuthType","AddressHashMode","AddressVersion","PubKeyEncoding","FungibleConditionCode","NonFungibleConditionCode","PostConditionPrincipalID","AssetType","TxRejectedReason","DEFAULT_TRANSACTION_VERSION","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","getAddressFromPublicKey","publicKey","transactionVersion","addressToString","addressFromVersionHash","addressHashModeToVersion","SerializeP2PKH","hashP2PKH","Buffer","from","createStacksPublicKey","PublicKey","data","publicKeyFromSignature","message","messageSignature","ec","EC","messageBN","keyFromPrivate","getPrivate","parsedSignature","parseRecoverableSignature","recoverPubKey","recoveryParam","encodeCompressed","publicKeyFromBuffer","isCompressed","startsWith","publicKeyToString","serializePublicKey","bufferArray","BufferArray","concatBuffer","pubKeyfromPrivKey","privateKey","privKey","createStacksPrivateKey","getPublic","compressed","deserializePublicKey","bufferReader","fieldId","readUInt8","keyLength","concat","readBuffer","signWithKey","input","signature","sign","canonical","r","leftPadHexToLength","coordinateValueBytes","s","createMessageSignature","intToHexString","recoveryParamHex","substr","hexStringToInt","getPublicKey","publicKeyToAddress","version","c32address","hash160","ClarityType","SerializationError","_this2","captureStackTrace","DeserializationError","_this3","NotImplementedError","_this4","SigningError","_this5","createSTXPostCondition","principal","conditionCode","amount","parsePrincipalString","PostCondition","conditionType","STX","createFungiblePostCondition","assetInfo","parseAssetInfoString","Fungible","createNonFungiblePostCondition","assetName","NonFungible","deserializePostCondition","postConditionType","readUInt8Enum","n","deserializePrincipal","BigNum","deserializeAssetInfo","deserializeCV","createTokenTransferPayload","recipient","memo","includes","split","contractPrincipalCV","standardPrincipalCV","principalCV","createMemoString","Payload","payloadType","TokenTransfer","createContractCallPayload","contractAddress","contractName","functionName","functionArgs","createAddress","createLPString","ContractCall","createSmartContractPayload","codeBody","codeBodyString","SmartContract","serializePayload","payload","appendByte","serializeCV","toArrayLike","serializeStacksMessage","numArgs","alloc","writeUInt32BE","PoisonMicroblock","Coinbase","coinbaseBuffer","deserializePayload","deserializeMemoString","deserializeAddress","contractCallName","deserializeLPString","numberOfArgs","readUInt32BE","clarityValue","byteLength","createCoinbasePayload","Address","serializeAddress","Principal","serializePrincipal","LengthPrefixedString","serializeLPString","MemoString","serializeMemoString","AssetInfo","serializeAssetInfo","postCondition","LengthPrefixedList","serializeLPList","TransactionAuthField","serializeTransactionAuthField","MessageSignature","serializeMessageSignature","c32AddressString","addressData","c32addressDecode","createEmptyAddress","MainnetSingleSig","repeat","hash","hashMode","txVersion","Testnet","TestnetSingleSig","JSON","stringify","SerializeP2SH","SerializeP2WPKH","SerializeP2WSH","MainnetMultiSig","TestnetMultiSig","addressFromPublicKeys","numSigs","publicKeys","hashP2SH","map","address","appendHexString","principalString","createContractPrincipal","createStandardPrincipal","addressString","addr","prefix","Standard","Contract","_","content","lengthPrefixBytes","maxLengthBytes","prefixLength","maxLength","exceedsMaxLengthBytes","lps","contentBuffer","prefixBytes","memoString","paddedContent","rightPadHexToLength","MEMO_MAX_LENGTH_BYTES","id","createAssetInfo","createLPList","lpList","list","index","deserializeLPList","l","deserializeTransactionAuthField","principalToString","PrincipalStandard","PrincipalContract","standardPrincipalCVFromAddress","contractPrincipalCVFromAddress","cvToValue","val","BoolTrue","BoolFalse","Int","fromTwos","toNumber","UInt","buffer","OptionalNone","OptionalSome","ResponseErr","ResponseOk","cvToJSON","List","v","Tuple","StringASCII","StringUTF8","getCVTypeString","success","join","trueCV","falseCV","intCV","twos","toTwos","bitLength","uintCV","isNeg","bufferCV","bufferCVFromString","str","noneCV","someCV","responseErrorCV","responseOkCV","listCV","tupleCV","isClarityName","stringAsciiCV","stringUtf8CV","bufferWithTypeID","typeId","serializeStringCV","cv","encoding","buffers","len","serializeBoolCV","serializeBufferCV","serializeIntCV","serializeStandardPrincipalCV","serializeContractPrincipalCV","serializeResponseCV","serializedValue","serializeListCV","sort","a","b","bufA","bufB","compare","nameWithLength","serializeTupleCV","serializeStringAsciiCV","serializeStringUtf8CV","enumCheckFunctions","Map","BufferReader","options","smartBuffer","isBuffer","SmartBuffer","buff","fromBuffer","offset","readUInt16BE","readBigUIntLE","hex","BigInt","readBigUIntBE","readBigUInt64BE","readString","enumVariable","invalidEnumErrorFormatter","num","isEnum","checker","get","newChecker","enumValues","filter","enumValueSet","Set","has","createEnumChecker","set","readOffset","internalBuffer","bufferLength","listLength","listContents","tupleLength","tupleContents","clarityName","asciiStrLen","asciiStr","utf8StrLen","utf8Str","hexString","_value","octet","Number","isInteger","leftPadHex","padStart","padEnd","integer","lengthBytes","parseInt","string","cloneDeep","lodashCloneDeep","omit","prop","clone","sha512_256","assign","_ah","_al","_bh","_bl","_ch","_cl","_dh","_dl","_eh","_el","_fh","_fl","_gh","_gl","_hh","_hl","digest","_sha","sha512","txidFromData","update","sha256Result","sha256","RIPEMD160","pubKeys","pubKey","redeemScript","test","init","fetchOpts","referrer","referrerPolicy","fetch","cvToHex","hexToCV","hexWithoutPrefix","AuthFieldType","parseReadOnlyResponse","Deserializable","deserialize","emptyMessageSignature","deserializeMessageSignature","createTransactionAuthField","contents","field","Signature","authFieldType","createSingleSigSpendingCondition","nonce","fee","signer","keyEncoding","Compressed","Uncompressed","createMultiSigSpendingCondition","fields","signaturesRequired","isSingleSig","condition","clearCondition","cloned","serializeSingleSigSpendingCondition","serializeMultiSigSpendingCondition","writeUInt16BE","deserializeSingleSigSpendingCondition","deserializeMultiSigSpendingCondition","serializeSpendingCondition","deserializeSpendingCondition","makeSigHashPreSign","curSigHash","authType","sigHash","makeSigHashPostSign","pubKeyEncoding","nextSignature","sigHashPreSign","nextSig","nextSigHash","nextVerification","initialSigHash","ClarityAbiTypeId","Authorization","spendingConditions","sponsorSpendingCondition","spendingCondition","intoInitialSighashAuth","Sponsored","setFee","getFee","setNonce","setSponsorNonce","setSponsor","verifyOrigin","verifySingleSig","verify","serialize","StandardAuthorization","_Authorization","SponsoredAuthorization","originSpendingCondition","sponsorSC","_Authorization2","StacksTransaction","auth","postConditions","postConditionMode","anchorMode","chainId","Deny","OnChainOnly","Any","signBegin","tx","txid","verifyBegin","createTxWithSignature","parsedSig","signNextOrigin","signAndAppend","signNextSponsor","appendPubkey","cond","serialized","chainIdBuffer","TransactionSigner","transaction","originDone","checkOversign","checkOverlap","createSponsorSigner","originSigHash","signOrigin","nextSighash","appendOrigin","signSponsor","getTxInComplete","resume","isClarityAbiPrimitive","isClarityAbiBuffer","isClarityAbiStringAscii","isClarityAbiStringUtf8","isClarityAbiResponse","response","isClarityAbiOptional","optional","isClarityAbiTuple","tuple","isClarityAbiList","getTypeUnion","ClarityAbiTypeUInt128","ClarityAbiTypeInt128","ClarityAbiTypeBool","ClarityAbiTypePrincipal","ClarityAbiTypeTraitReference","ClarityAbiTypeNone","ClarityAbiTypeBuffer","ClarityAbiTypeResponse","ClarityAbiTypeOptional","ClarityAbiTypeTuple","ClarityAbiTypeList","ClarityAbiTypeStringAscii","ClarityAbiTypeStringUtf8","getTypeString","ok","t","matchType","abiType","union","every","abiTupleEntry","validateContractCall","abi","filtered","functions","abiArgs","args","payloadArg","abiArg","getNonce","network","defaultNetwork","StacksMainnet","url","getAccountApiUrl","fetchPrivate","msg","text","status","statusText","json","estimateTransfer","fetchOptions","headers","Accept","getTransferFeeEstimateApiUrl","feeRateResult","txBytes","feeRate","mul","rawTx","getBroadcastApiUrl","broadcastRawTransaction","body","_context4","parse","getAbi","getAbiApiUrl","makeUnsignedSTXTokenTransfer","txOptions","defaultOptions","sponsored","numSignatures","authorization","lpPostConditions","addressVersion","senderAddress","senderKey","pk","signerKeys","estimateContractDeploy","addressHashMode","estimateContractFunctionCall","makeUnsignedContractCall","validateWithAbi","readOnlyFunctionOptions","getReadOnlyFunctionCallApiUrl","sender","arguments","responseJson","sponsorOptions","sponsorNonce","sponsorAddressHashmode","StacksTestnet","sponsorPubKey","sponsorPrivateKey","txFee","func","access","sp","lengthPrefixedContractName","cvToString","listType","entropy","randomBytes","genKeyPair","typeString","toLowerCase","stacksAddress","e"],"mappings":"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"}
{"version":3,"file":"keys.esm.js","sources":["../src/keys.ts"],"sourcesContent":["import {\n  COMPRESSED_PUBKEY_LENGTH_BYTES,\n  UNCOMPRESSED_PUBKEY_LENGTH_BYTES,\n  StacksMessageType,\n  AddressHashMode,\n  TransactionVersion,\n} from './constants';\n\nimport {\n  BufferArray,\n  leftPadHexToLength,\n  intToHexString,\n  randomBytes,\n  hash160,\n  hashP2PKH,\n  hexStringToInt,\n} from './utils';\n\nimport { ec as EC } from 'elliptic';\n\nimport { MessageSignature, createMessageSignature } from './authorization';\nimport { BufferReader } from './bufferReader';\nimport { AddressVersion } from './constants';\nimport { c32address } from 'c32check';\nimport { addressHashModeToVersion, addressFromVersionHash, addressToString } from './types';\n\nexport interface StacksPublicKey {\n  readonly type: StacksMessageType.PublicKey;\n  readonly data: Buffer;\n}\n\n/** Creates a P2PKH address string from the given private key and tx version. */\nexport function getAddressFromPrivateKey(\n  /** Private key buffer or hex string */\n  privateKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  const pubKey = pubKeyfromPrivKey(privateKey);\n  return getAddressFromPublicKey(pubKey.data, transactionVersion);\n}\n\n/** Creates a P2PKH address string from the given public key and tx version. */\nexport function getAddressFromPublicKey(\n  /** Public key buffer or hex string */\n  publicKey: string | Buffer,\n  transactionVersion = TransactionVersion.Mainnet\n): string {\n  publicKey = typeof publicKey === 'string' ? publicKey : publicKey.toString('hex');\n  const addrVer = addressHashModeToVersion(AddressHashMode.SerializeP2PKH, transactionVersion);\n  const addr = addressFromVersionHash(addrVer, hashP2PKH(Buffer.from(publicKey, 'hex')));\n  const addrString = addressToString(addr);\n  return addrString;\n}\n\nexport function createStacksPublicKey(key: string): StacksPublicKey {\n  return {\n    type: StacksMessageType.PublicKey,\n    data: Buffer.from(key, 'hex'),\n  };\n}\n\nexport function publicKeyFromSignature(message: string, messageSignature: MessageSignature) {\n  const ec = new EC('secp256k1');\n  const messageBN = ec\n    .keyFromPrivate(message, 'hex')\n    .getPrivate()\n    .toString(10);\n\n  const parsedSignature = parseRecoverableSignature(messageSignature.data);\n\n  const publicKey = ec.recoverPubKey(\n    messageBN,\n    parsedSignature,\n    parsedSignature.recoveryParam,\n    'hex'\n  ) as { encodeCompressed: (enc: string) => string };\n\n  return publicKey.encodeCompressed('hex');\n}\n\nexport function publicKeyFromBuffer(data: Buffer): StacksPublicKey {\n  return { type: StacksMessageType.PublicKey, data };\n}\n\nexport function isCompressed(key: StacksPublicKey): boolean {\n  return !key.data.toString('hex').startsWith('04');\n}\n\nexport function publicKeyToString(key: StacksPublicKey): string {\n  return key.data.toString('hex');\n}\n\nexport function serializePublicKey(key: StacksPublicKey): Buffer {\n  const bufferArray: BufferArray = new BufferArray();\n  bufferArray.push(key.data);\n  return bufferArray.concatBuffer();\n}\n\nexport function pubKeyfromPrivKey(privateKey: string | Buffer): StacksPublicKey {\n  const privKey = createStacksPrivateKey(privateKey);\n  const ec = new EC('secp256k1');\n  const keyPair = ec.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');\n  const pubKey = keyPair.getPublic(privKey.compressed, 'hex');\n  return createStacksPublicKey(pubKey);\n}\n\nexport function deserializePublicKey(bufferReader: BufferReader): StacksPublicKey {\n  const fieldId = bufferReader.readUInt8();\n  const keyLength =\n    fieldId !== 4 ? COMPRESSED_PUBKEY_LENGTH_BYTES : UNCOMPRESSED_PUBKEY_LENGTH_BYTES;\n  return publicKeyFromBuffer(\n    Buffer.concat([Buffer.from([fieldId]), bufferReader.readBuffer(keyLength)])\n  );\n}\n\nexport interface StacksPrivateKey {\n  data: Buffer;\n  compressed: boolean;\n}\n\nexport function createStacksPrivateKey(key: string | Buffer): StacksPrivateKey {\n  const data = typeof key === 'string' ? Buffer.from(key, 'hex') : key;\n  let compressed: boolean;\n  if (data.length === 33) {\n    if (data[data.length - 1] !== 1) {\n      throw new Error(\n        'Improperly formatted private-key. 33 byte length usually ' +\n          'indicates compressed key, but last byte must be == 0x01'\n      );\n    }\n    compressed = true;\n  } else if (data.length === 32) {\n    compressed = false;\n  } else {\n    throw new Error(\n      `Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${data.length}`\n    );\n  }\n  return { data, compressed };\n}\n\nexport function makeRandomPrivKey(entropy?: Buffer): StacksPrivateKey {\n  const ec = new EC('secp256k1');\n  const options = { entropy: entropy || randomBytes(32) };\n  const keyPair = ec.genKeyPair(options);\n  const privateKey = keyPair.getPrivate().toString('hex', 32);\n  return createStacksPrivateKey(privateKey);\n}\n\nexport function signWithKey(privateKey: StacksPrivateKey, input: string): MessageSignature {\n  const ec = new EC('secp256k1');\n  const key = ec.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');\n  const signature = key.sign(input, 'hex', { canonical: true });\n  const coordinateValueBytes = 32;\n  const r = leftPadHexToLength(signature.r.toString('hex'), coordinateValueBytes * 2);\n  const s = leftPadHexToLength(signature.s.toString('hex'), coordinateValueBytes * 2);\n  if (signature.recoveryParam === undefined || signature.recoveryParam === null) {\n    throw new Error('\"signature.recoveryParam\" is not set');\n  }\n  const recoveryParam = intToHexString(signature.recoveryParam, 1);\n  const recoverableSignatureString = recoveryParam + r + s;\n  const recoverableSignature = createMessageSignature(recoverableSignatureString);\n  return recoverableSignature;\n}\n\nexport function getSignatureRecoveryParam(signature: string) {\n  const coordinateValueBytes = 32;\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n  const recoveryParamHex = signature.substr(0, 2);\n  return hexStringToInt(recoveryParamHex);\n}\n\nexport function parseRecoverableSignature(signature: string) {\n  const coordinateValueBytes = 32;\n  if (signature.length < coordinateValueBytes * 2 * 2 + 1) {\n    throw new Error('Invalid signature');\n  }\n  const recoveryParamHex = signature.substr(0, 2);\n  const r = signature.substr(2, coordinateValueBytes * 2);\n  const s = signature.substr(2 + coordinateValueBytes * 2, coordinateValueBytes * 2);\n  return {\n    recoveryParam: hexStringToInt(recoveryParamHex),\n    r,\n    s,\n  };\n}\n\nexport function getPublicKey(privateKey: StacksPrivateKey): StacksPublicKey {\n  return pubKeyfromPrivKey(privateKey.data);\n}\n\nexport function privateKeyToString(privateKey: StacksPrivateKey): string {\n  return privateKey.data.toString('hex');\n}\n\nexport function publicKeyToAddress(version: AddressVersion, publicKey: StacksPublicKey): string {\n  return c32address(version, hash160(publicKey.data).toString('hex'));\n}\n"],"names":["getAddressFromPrivateKey","privateKey","transactionVersion","TransactionVersion","Mainnet","pubKey","pubKeyfromPrivKey","getAddressFromPublicKey","data","publicKey","toString","addrVer","addressHashModeToVersion","AddressHashMode","SerializeP2PKH","addr","addressFromVersionHash","hashP2PKH","Buffer","from","addrString","addressToString","createStacksPublicKey","key","type","StacksMessageType","PublicKey","publicKeyFromSignature","message","messageSignature","ec","EC","messageBN","keyFromPrivate","getPrivate","parsedSignature","parseRecoverableSignature","recoverPubKey","recoveryParam","encodeCompressed","publicKeyFromBuffer","isCompressed","startsWith","publicKeyToString","serializePublicKey","bufferArray","BufferArray","push","concatBuffer","privKey","createStacksPrivateKey","keyPair","slice","getPublic","compressed","deserializePublicKey","bufferReader","fieldId","readUInt8","keyLength","COMPRESSED_PUBKEY_LENGTH_BYTES","UNCOMPRESSED_PUBKEY_LENGTH_BYTES","concat","readBuffer","length","Error","makeRandomPrivKey","entropy","options","randomBytes","genKeyPair","signWithKey","input","signature","sign","canonical","coordinateValueBytes","r","leftPadHexToLength","s","undefined","intToHexString","recoverableSignatureString","recoverableSignature","createMessageSignature","getSignatureRecoveryParam","recoveryParamHex","substr","hexStringToInt","getPublicKey","privateKeyToString","publicKeyToAddress","version","c32address","hash160"],"mappings":"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"}
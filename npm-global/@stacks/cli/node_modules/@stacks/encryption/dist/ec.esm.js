import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';
import runtime_1 from './node_modules/regenerator-runtime/runtime.esm.js';
import { ec } from 'elliptic';
import randomBytes from 'randombytes';
import { FailedDecryptionError } from '@stacks/common';
import { hashSha256Sync, hashSha512Sync } from './sha2Hash.esm.js';
import { getPublicKeyFromPrivate } from './keys.esm.js';
import { createHmacSha256 } from './hmacSha256.esm.js';
import { createCipher } from './aesCipher.esm.js';
import { getBase64OutputLength, getAesCbcOutputLength } from './utils.esm.js';

var ecurve = /*#__PURE__*/new ec('secp256k1');
function aes256CbcEncrypt(_x, _x2, _x3) {
  return _aes256CbcEncrypt.apply(this, arguments);
}

function _aes256CbcEncrypt() {
  _aes256CbcEncrypt = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(iv, key, plaintext) {
    var cipher, result;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return createCipher();

          case 2:
            cipher = _context.sent;
            _context.next = 5;
            return cipher.encrypt('aes-256-cbc', key, iv, plaintext);

          case 5:
            result = _context.sent;
            return _context.abrupt("return", result);

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _aes256CbcEncrypt.apply(this, arguments);
}

function aes256CbcDecrypt(_x4, _x5, _x6) {
  return _aes256CbcDecrypt.apply(this, arguments);
}

function _aes256CbcDecrypt() {
  _aes256CbcDecrypt = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(iv, key, ciphertext) {
    var cipher, result;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return createCipher();

          case 2:
            cipher = _context2.sent;
            _context2.next = 5;
            return cipher.decrypt('aes-256-cbc', key, iv, ciphertext);

          case 5:
            result = _context2.sent;
            return _context2.abrupt("return", result);

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _aes256CbcDecrypt.apply(this, arguments);
}

function hmacSha256(_x7, _x8) {
  return _hmacSha.apply(this, arguments);
}

function _hmacSha() {
  _hmacSha = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(key, content) {
    var hmacSha256;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return createHmacSha256();

          case 2:
            hmacSha256 = _context3.sent;
            return _context3.abrupt("return", hmacSha256.digest(key, content));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _hmacSha.apply(this, arguments);
}

function equalConstTime(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }

  var res = 0;

  for (var i = 0; i < b1.length; i++) {
    res |= b1[i] ^ b2[i];
  }

  return res === 0;
}

function sharedSecretToKeys(sharedSecret) {
  var hashedSecret = hashSha512Sync(sharedSecret);
  return {
    encryptionKey: hashedSecret.slice(0, 32),
    hmacKey: hashedSecret.slice(32)
  };
}

function getHexFromBN(bnInput) {
  var hexOut = bnInput.toString('hex', 64);

  if (hexOut.length === 64) {
    return hexOut;
  } else if (hexOut.length < 64) {
    var padding = '0'.repeat(64 - hexOut.length);
    return "" + padding + hexOut;
  } else {
    throw new Error('Generated a > 32-byte BN for encryption. Failing.');
  }
}
function getBufferFromBN(bnInput) {
  var result = bnInput.toArrayLike(Buffer, 'be', 32);

  if (result.byteLength !== 32) {
    throw new Error('Generated a 32-byte BN for encryption. Failing.');
  }

  return result;
}
function getCipherObjectWrapper(opts) {
  var shell = {
    iv: '',
    ephemeralPK: '',
    mac: '',
    cipherText: '',
    wasString: !!opts.wasString
  };

  if (opts.cipherTextEncoding === 'base64') {
    shell.cipherTextEncoding = 'base64';
  }

  var ivLength = 32;
  var ephemeralPKLength = 66;
  var macLength = 64;
  return {
    payloadValuesLength: ivLength + ephemeralPKLength + macLength,
    payloadShell: JSON.stringify(shell)
  };
}
function getSignedCipherObjectWrapper(payloadShell) {
  var shell = {
    signature: '',
    publicKey: '',
    cipherText: payloadShell
  };
  var signatureLength = 144;
  var publicKeyLength = 66;
  return {
    signedPayloadValuesLength: signatureLength + publicKeyLength,
    signedPayloadShell: JSON.stringify(shell)
  };
}
function eciesGetJsonStringLength(opts) {
  var _getCipherObjectWrapp = getCipherObjectWrapper(opts),
      payloadShell = _getCipherObjectWrapp.payloadShell,
      payloadValuesLength = _getCipherObjectWrapp.payloadValuesLength;

  var cipherTextLength = getAesCbcOutputLength(opts.contentLength);
  var encodedCipherTextLength;

  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {
    encodedCipherTextLength = cipherTextLength * 2;
  } else if (opts.cipherTextEncoding === 'base64') {
    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);
  } else {
    throw new Error("Unexpected cipherTextEncoding \"" + opts.cipherTextEncoding + "\"");
  }

  if (!opts.sign) {
    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;
  } else {
    var _getSignedCipherObjec = getSignedCipherObjectWrapper(payloadShell),
        signedPayloadShell = _getSignedCipherObjec.signedPayloadShell,
        signedPayloadValuesLength = _getSignedCipherObjec.signedPayloadValuesLength;

    return signedPayloadShell.length + signedPayloadValuesLength + payloadValuesLength + encodedCipherTextLength;
  }
}
function encryptECIES(_x9, _x10, _x11, _x12) {
  return _encryptECIES.apply(this, arguments);
}

function _encryptECIES() {
  _encryptECIES = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(publicKey, content, wasString, cipherTextEncoding) {
    var ecPK, ephemeralSK, ephemeralPK, sharedSecret, sharedSecretBuffer, sharedKeys, initializationVector, cipherText, macData, mac, cipherTextString, result;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();
            ephemeralSK = ecurve.genKeyPair();
            ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());
            sharedSecret = ephemeralSK.derive(ecPK);
            sharedSecretBuffer = getBufferFromBN(sharedSecret);
            sharedKeys = sharedSecretToKeys(sharedSecretBuffer);
            initializationVector = randomBytes(16);
            _context4.next = 9;
            return aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);

          case 9:
            cipherText = _context4.sent;
            macData = Buffer.concat([initializationVector, ephemeralPK, cipherText]);
            _context4.next = 13;
            return hmacSha256(sharedKeys.hmacKey, macData);

          case 13:
            mac = _context4.sent;

            if (!(!cipherTextEncoding || cipherTextEncoding === 'hex')) {
              _context4.next = 18;
              break;
            }

            cipherTextString = cipherText.toString('hex');
            _context4.next = 23;
            break;

          case 18:
            if (!(cipherTextEncoding === 'base64')) {
              _context4.next = 22;
              break;
            }

            cipherTextString = cipherText.toString('base64');
            _context4.next = 23;
            break;

          case 22:
            throw new Error("Unexpected cipherTextEncoding \"" + cipherTextEncoding + "\"");

          case 23:
            result = {
              iv: initializationVector.toString('hex'),
              ephemeralPK: ephemeralPK.toString('hex'),
              cipherText: cipherTextString,
              mac: mac.toString('hex'),
              wasString: !!wasString
            };

            if (cipherTextEncoding && cipherTextEncoding !== 'hex') {
              result.cipherTextEncoding = cipherTextEncoding;
            }

            return _context4.abrupt("return", result);

          case 26:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _encryptECIES.apply(this, arguments);
}

function decryptECIES(_x13, _x14) {
  return _decryptECIES.apply(this, arguments);
}

function _decryptECIES() {
  _decryptECIES = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(privateKey, cipherObject) {
    var ecSK, ephemeralPK, sharedSecret, sharedSecretBuffer, sharedKeys, ivBuffer, cipherTextBuffer, macData, actualMac, expectedMac, plainText;
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            ecSK = ecurve.keyFromPrivate(privateKey, 'hex');
            ephemeralPK = null;
            _context5.prev = 2;
            ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();
            _context5.next = 9;
            break;

          case 6:
            _context5.prev = 6;
            _context5.t0 = _context5["catch"](2);
            throw new FailedDecryptionError('Unable to get public key from cipher object. ' + 'You might be trying to decrypt an unencrypted object.');

          case 9:
            sharedSecret = ecSK.derive(ephemeralPK);
            sharedSecretBuffer = getBufferFromBN(sharedSecret);
            sharedKeys = sharedSecretToKeys(sharedSecretBuffer);
            ivBuffer = Buffer.from(cipherObject.iv, 'hex');

            if (!(!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex')) {
              _context5.next = 17;
              break;
            }

            cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');
            _context5.next = 22;
            break;

          case 17:
            if (!(cipherObject.cipherTextEncoding === 'base64')) {
              _context5.next = 21;
              break;
            }

            cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');
            _context5.next = 22;
            break;

          case 21:
            throw new Error("Unexpected cipherTextEncoding \"" + cipherObject.cipherText + "\"");

          case 22:
            macData = Buffer.concat([ivBuffer, Buffer.from(ephemeralPK.encodeCompressed()), cipherTextBuffer]);
            _context5.next = 25;
            return hmacSha256(sharedKeys.hmacKey, macData);

          case 25:
            actualMac = _context5.sent;
            expectedMac = Buffer.from(cipherObject.mac, 'hex');

            if (equalConstTime(expectedMac, actualMac)) {
              _context5.next = 29;
              break;
            }

            throw new FailedDecryptionError('Decryption failed: failure in MAC check');

          case 29:
            _context5.next = 31;
            return aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);

          case 31:
            plainText = _context5.sent;

            if (!cipherObject.wasString) {
              _context5.next = 36;
              break;
            }

            return _context5.abrupt("return", plainText.toString());

          case 36:
            return _context5.abrupt("return", plainText);

          case 37:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[2, 6]]);
  }));
  return _decryptECIES.apply(this, arguments);
}

function signECDSA(privateKey, content) {
  var contentBuffer = content instanceof Buffer ? content : Buffer.from(content);
  var ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');
  var publicKey = getPublicKeyFromPrivate(privateKey);
  var contentHash = hashSha256Sync(contentBuffer);
  var signature = ecPrivate.sign(contentHash);
  var signatureString = signature.toDER('hex');
  return {
    signature: signatureString,
    publicKey: publicKey
  };
}

function getBuffer(content) {
  if (content instanceof Buffer) return content;else if (content instanceof ArrayBuffer) return Buffer.from(content);else return Buffer.from(content);
}

function verifyECDSA(content, publicKey, signature) {
  var contentBuffer = getBuffer(content);
  var ecPublic = ecurve.keyFromPublic(publicKey, 'hex');
  var contentHash = hashSha256Sync(contentBuffer);
  return ecPublic.verify(contentHash, signature);
}

export { aes256CbcEncrypt, decryptECIES, eciesGetJsonStringLength, encryptECIES, getBufferFromBN, getCipherObjectWrapper, getHexFromBN, getSignedCipherObjectWrapper, signECDSA, verifyECDSA };
//# sourceMappingURL=ec.esm.js.map

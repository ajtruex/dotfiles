import { isNodeCryptoAvailable } from './cryptoUtils.esm.js';
import Ripemd160Polyfill from 'ripemd160-min';

var Ripemd160PolyfillDigest = /*#__PURE__*/function () {
  function Ripemd160PolyfillDigest() {}

  var _proto = Ripemd160PolyfillDigest.prototype;

  _proto.digest = function digest(data) {
    var instance = new Ripemd160Polyfill();
    instance.update(data);
    var hash = instance.digest();

    if (Array.isArray(hash)) {
      return Buffer.from(hash);
    } else {
      return Buffer.from(hash.buffer);
    }
  };

  return Ripemd160PolyfillDigest;
}();
var NodeCryptoRipemd160Digest = /*#__PURE__*/function () {
  function NodeCryptoRipemd160Digest(nodeCryptoCreateHash) {
    this.nodeCryptoCreateHash = nodeCryptoCreateHash;
  }

  var _proto2 = NodeCryptoRipemd160Digest.prototype;

  _proto2.digest = function digest(data) {
    try {
      return this.nodeCryptoCreateHash('rmd160').update(data).digest();
    } catch (error) {
      try {
        return this.nodeCryptoCreateHash('ripemd160').update(data).digest();
      } catch (_err) {
        console.log(error);
        console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');
        var polyfill = new Ripemd160PolyfillDigest();
        return polyfill.digest(data);
      }
    }
  };

  return NodeCryptoRipemd160Digest;
}();
function createHashRipemd160() {
  var nodeCryptoCreateHash = isNodeCryptoAvailable(function (nodeCrypto) {
    if (typeof nodeCrypto.createHash === 'function') {
      return nodeCrypto.createHash;
    }

    return false;
  });

  if (nodeCryptoCreateHash) {
    return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);
  } else {
    return new Ripemd160PolyfillDigest();
  }
}
function hashRipemd160(data) {
  var hash = createHashRipemd160();
  return hash.digest(data);
}

export { NodeCryptoRipemd160Digest, Ripemd160PolyfillDigest, createHashRipemd160, hashRipemd160 };
//# sourceMappingURL=hashRipemd160.esm.js.map

{"version":3,"file":"encryption.esm.js","sources":["../src/encryption.ts"],"sourcesContent":["import {\n  CipherTextEncoding,\n  SignedCipherObject,\n  encryptECIES,\n  decryptECIES,\n  signECDSA,\n} from './ec';\n\nimport { getPublicKeyFromPrivate } from './keys';\n\nexport interface EncryptionOptions {\n  /**\n   * If set to `true` the data is signed using ECDSA on SHA256 hashes with the user's\n   * app private key. If a string is specified, it is used as the private key instead\n   * of the user's app private key.\n   * @default false\n   */\n  sign?: boolean | string;\n  /**\n   * String encoding format for the cipherText buffer.\n   * Currently defaults to 'hex' for legacy backwards-compatibility.\n   * Only used if the `encrypt` option is also used.\n   * Note: in the future this should default to 'base64' for the significant\n   * file size reduction.\n   */\n  cipherTextEncoding?: CipherTextEncoding;\n  /**\n   * Specifies if the original unencrypted content is a ASCII or UTF-8 string.\n   * For example stringified JSON.\n   * If true, then when the ciphertext is decrypted, it will be returned as\n   * a `string` type variable, otherwise will be returned as a Buffer.\n   */\n  wasString?: boolean;\n}\n\n/**\n * Specify encryption options, and whether to sign the ciphertext.\n */\nexport interface EncryptContentOptions extends EncryptionOptions {\n  /**\n   * Encrypt the data with this key.\n   */\n  publicKey?: string;\n  /**\n   * Encrypt the data with the public key corresponding to the supplied private key\n   */\n  privateKey?: string;\n}\n\n/**\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\nexport async function encryptContent(\n  content: string | Buffer,\n  options?: EncryptContentOptions\n): Promise<string> {\n  const opts = Object.assign({}, options);\n  let privateKey: string | undefined;\n  if (!opts.publicKey) {\n    if (!opts.privateKey) {\n      throw new Error('Either public key or private key must be supplied for encryption.');\n    }\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n  }\n  let wasString: boolean;\n  if (typeof opts.wasString === 'boolean') {\n    wasString = opts.wasString;\n  } else {\n    wasString = typeof content === 'string';\n  }\n  const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n  const cipherObject = await encryptECIES(\n    opts.publicKey,\n    contentBuffer,\n    wasString,\n    opts.cipherTextEncoding\n  );\n  let cipherPayload = JSON.stringify(cipherObject);\n  if (opts.sign) {\n    if (typeof opts.sign === 'string') {\n      privateKey = opts.sign;\n    } else if (!privateKey) {\n      privateKey = opts.privateKey;\n    }\n    const signatureObject = signECDSA(privateKey!, cipherPayload);\n    const signedCipherObject: SignedCipherObject = {\n      signature: signatureObject.signature,\n      publicKey: signatureObject.publicKey,\n      cipherText: cipherPayload,\n    };\n    cipherPayload = JSON.stringify(signedCipherObject);\n  }\n  return cipherPayload;\n}\n\n/**\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\nexport function decryptContent(\n  content: string,\n  options?: {\n    privateKey?: string;\n  }\n): Promise<string | Buffer> {\n  const opts = Object.assign({}, options);\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error(\n        'Failed to parse encrypted content JSON. The content may not ' +\n          'be encrypted. If using getFile, try passing { decrypt: false }.'\n      );\n    } else {\n      throw err;\n    }\n  }\n}\n"],"names":["encryptContent","content","options","opts","Object","assign","publicKey","privateKey","Error","getPublicKeyFromPrivate","wasString","contentBuffer","Buffer","from","encryptECIES","cipherTextEncoding","cipherObject","cipherPayload","JSON","stringify","sign","signatureObject","signECDSA","signedCipherObject","signature","cipherText","decryptContent","parse","decryptECIES","err","SyntaxError"],"mappings":";;;;;SAyDsBA,cAAtB;AAAA;AAAA;;;mEAAO,iBACLC,OADK,EAELC,OAFK;AAAA;AAAA;AAAA;AAAA;AAAA;AAICC,YAAAA,IAJD,GAIQC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,OAAlB,CAJR;;AAAA,gBAMAC,IAAI,CAACG,SANL;AAAA;AAAA;AAAA;;AAAA,gBAOEH,IAAI,CAACI,UAPP;AAAA;AAAA;AAAA;;AAAA,kBAQK,IAAIC,KAAJ,CAAU,mEAAV,CARL;;AAAA;AAUHL,YAAAA,IAAI,CAACG,SAAL,GAAiBG,uBAAuB,CAACN,IAAI,CAACI,UAAN,CAAxC;;AAVG;AAaL,gBAAI,OAAOJ,IAAI,CAACO,SAAZ,KAA0B,SAA9B,EAAyC;AACvCA,cAAAA,SAAS,GAAGP,IAAI,CAACO,SAAjB;AACD,aAFD,MAEO;AACLA,cAAAA,SAAS,GAAG,OAAOT,OAAP,KAAmB,QAA/B;AACD;;AACKU,YAAAA,aAlBD,GAkBiB,OAAOV,OAAP,KAAmB,QAAnB,GAA8BW,MAAM,CAACC,IAAP,CAAYZ,OAAZ,CAA9B,GAAqDA,OAlBtE;AAAA;AAAA,mBAmBsBa,YAAY,CACrCX,IAAI,CAACG,SADgC,EAErCK,aAFqC,EAGrCD,SAHqC,EAIrCP,IAAI,CAACY,kBAJgC,CAnBlC;;AAAA;AAmBCC,YAAAA,YAnBD;AAyBDC,YAAAA,aAzBC,GAyBeC,IAAI,CAACC,SAAL,CAAeH,YAAf,CAzBf;;AA0BL,gBAAIb,IAAI,CAACiB,IAAT,EAAe;AACb,kBAAI,OAAOjB,IAAI,CAACiB,IAAZ,KAAqB,QAAzB,EAAmC;AACjCb,gBAAAA,UAAU,GAAGJ,IAAI,CAACiB,IAAlB;AACD,eAFD,MAEO,IAAI,CAACb,UAAL,EAAiB;AACtBA,gBAAAA,UAAU,GAAGJ,IAAI,CAACI,UAAlB;AACD;;AACKc,cAAAA,eANO,GAMWC,SAAS,CAACf,UAAD,EAAcU,aAAd,CANpB;AAOPM,cAAAA,kBAPO,GAOkC;AAC7CC,gBAAAA,SAAS,EAAEH,eAAe,CAACG,SADkB;AAE7ClB,gBAAAA,SAAS,EAAEe,eAAe,CAACf,SAFkB;AAG7CmB,gBAAAA,UAAU,EAAER;AAHiC,eAPlC;AAYbA,cAAAA,aAAa,GAAGC,IAAI,CAACC,SAAL,CAAeI,kBAAf,CAAhB;AACD;;AAvCI,6CAwCEN,aAxCF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;SAoDSS,eACdzB,SACAC;AAIA,MAAMC,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,OAAlB,CAAb;;AACA,MAAI,CAACC,IAAI,CAACI,UAAV,EAAsB;AACpB,UAAM,IAAIC,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,MAAI;AACF,QAAMQ,YAAY,GAAGE,IAAI,CAACS,KAAL,CAAW1B,OAAX,CAArB;AACA,WAAO2B,YAAY,CAACzB,IAAI,CAACI,UAAN,EAAkBS,YAAlB,CAAnB;AACD,GAHD,CAGE,OAAOa,GAAP,EAAY;AACZ,QAAIA,GAAG,YAAYC,WAAnB,EAAgC;AAC9B,YAAM,IAAItB,KAAJ,CACJ,iEACE,iEAFE,CAAN;AAID,KALD,MAKO;AACL,YAAMqB,GAAN;AACD;AACF;AACF;;;;"}
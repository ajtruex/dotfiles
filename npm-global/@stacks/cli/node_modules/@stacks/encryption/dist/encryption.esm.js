import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';
import runtime_1 from './node_modules/regenerator-runtime/runtime.esm.js';
import { getPublicKeyFromPrivate } from './keys.esm.js';
import { encryptECIES, decryptECIES, signECDSA } from './ec.esm.js';

function encryptContent(_x, _x2) {
  return _encryptContent.apply(this, arguments);
}

function _encryptContent() {
  _encryptContent = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(content, options) {
    var opts, privateKey, wasString, contentBuffer, cipherObject, cipherPayload, signatureObject, signedCipherObject;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts = Object.assign({}, options);

            if (opts.publicKey) {
              _context.next = 5;
              break;
            }

            if (opts.privateKey) {
              _context.next = 4;
              break;
            }

            throw new Error('Either public key or private key must be supplied for encryption.');

          case 4:
            opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);

          case 5:
            if (typeof opts.wasString === 'boolean') {
              wasString = opts.wasString;
            } else {
              wasString = typeof content === 'string';
            }

            contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;
            _context.next = 9;
            return encryptECIES(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);

          case 9:
            cipherObject = _context.sent;
            cipherPayload = JSON.stringify(cipherObject);

            if (opts.sign) {
              if (typeof opts.sign === 'string') {
                privateKey = opts.sign;
              } else if (!privateKey) {
                privateKey = opts.privateKey;
              }

              signatureObject = signECDSA(privateKey, cipherPayload);
              signedCipherObject = {
                signature: signatureObject.signature,
                publicKey: signatureObject.publicKey,
                cipherText: cipherPayload
              };
              cipherPayload = JSON.stringify(signedCipherObject);
            }

            return _context.abrupt("return", cipherPayload);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _encryptContent.apply(this, arguments);
}

function decryptContent(content, options) {
  var opts = Object.assign({}, options);

  if (!opts.privateKey) {
    throw new Error('Private key is required for decryption.');
  }

  try {
    var cipherObject = JSON.parse(content);
    return decryptECIES(opts.privateKey, cipherObject);
  } catch (err) {
    if (err instanceof SyntaxError) {
      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');
    } else {
      throw err;
    }
  }
}

export { decryptContent, encryptContent };
//# sourceMappingURL=encryption.esm.js.map

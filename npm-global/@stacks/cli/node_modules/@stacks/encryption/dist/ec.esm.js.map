{"version":3,"file":"ec.esm.js","sources":["../src/ec.ts"],"sourcesContent":["import { ec as EllipticCurve } from 'elliptic';\nimport * as BN from 'bn.js';\nimport { randomBytes } from './cryptoRandom';\nimport { FailedDecryptionError } from '@stacks/common';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\n\nconst ecurve = new EllipticCurve('secp256k1');\n\n/**\n * Controls how the encrypted data buffer will be encoded as a string in the JSON payload.\n * Options:\n *    `hex` -- the legacy default, file size increase 100% (2x).\n *    `base64` -- file size increased ~33%.\n * @ignore\n */\nexport type CipherTextEncoding = 'hex' | 'base64';\n\n/**\n * @ignore\n */\nexport type CipherObject = {\n  iv: string;\n  ephemeralPK: string;\n  cipherText: string;\n  /** If undefined then hex encoding is used for the `cipherText` string. */\n  cipherTextEncoding?: CipherTextEncoding;\n  mac: string;\n  wasString: boolean;\n};\n\n/**\n * @ignore\n */\nexport type SignedCipherObject = {\n  /** Hex encoded DER signature (up to 144 chars) */\n  signature: string;\n  /** Hex encoded public key (66 char length) */\n  publicKey: string;\n  /** The stringified json of a `CipherObject` */\n  cipherText: string;\n};\n\n/**\n * @ignore\n */\nexport async function aes256CbcEncrypt(\n  iv: Buffer,\n  key: Buffer,\n  plaintext: Buffer\n): Promise<Buffer> {\n  const cipher = await createCipher();\n  const result = await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n  return result;\n}\n\n/**\n * @ignore\n */\nasync function aes256CbcDecrypt(iv: Buffer, key: Buffer, ciphertext: Buffer): Promise<Buffer> {\n  const cipher = await createCipher();\n  const result = await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n  return result;\n}\n\n/**\n * @ignore\n */\nasync function hmacSha256(key: Buffer, content: Buffer) {\n  const hmacSha256 = await createHmacSha256();\n  return hmacSha256.digest(key, content);\n}\n\n/**\n * @ignore\n */\nfunction equalConstTime(b1: Buffer, b2: Buffer) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/**\n * @ignore\n */\nfunction sharedSecretToKeys(sharedSecret: Buffer): { encryptionKey: Buffer; hmacKey: Buffer } {\n  // generate mac and encryption key from shared secret\n  const hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32),\n  };\n}\n\n/**\n * Hex encodes a 32-byte BN.js instance.\n * The result string is zero padded and always 64 characters in length.\n * @ignore\n */\nexport function getHexFromBN(bnInput: BN): string {\n  const hexOut = bnInput.toString('hex', 64);\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n\n/**\n * Returns a big-endian encoded 32-byte BN.js instance.\n * The result Buffer is zero padded and always 32 bytes in length.\n * @ignore\n */\nexport function getBufferFromBN(bnInput: BN): Buffer {\n  const result = bnInput.toArrayLike(Buffer, 'be', 32);\n  if (result.byteLength !== 32) {\n    throw new Error('Generated a 32-byte BN for encryption. Failing.');\n  }\n  return result;\n}\n\n/**\n * Get details about the JSON envelope size overhead for ciphertext payloads.\n * @ignore\n */\nexport function getCipherObjectWrapper(opts: {\n  wasString: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): {\n  /** The stringified JSON string of an empty `CipherObject`. */\n  payloadShell: string;\n  /** Total string length of all the `CipherObject` values that always have constant lengths. */\n  payloadValuesLength: number;\n} {\n  // Placeholder structure of the ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: CipherObject = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString,\n  };\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n  // Hex encoded 16 byte buffer.\n  const ivLength = 32;\n  // Hex encoded, compressed EC pubkey of 33 bytes.\n  const ephemeralPKLength = 66;\n  // Hex encoded 32 byte hmac-sha256.\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Get details about the JSON envelope size overhead for signed ciphertext payloads.\n * @param payloadShell - The JSON stringified empty `CipherObject`\n * @ignore\n */\nexport function getSignedCipherObjectWrapper(\n  payloadShell: string\n): {\n  /** The stringified JSON string of an empty `SignedCipherObject`. */\n  signedPayloadValuesLength: number;\n  /** Total string length of all the `SignedCipherObject` values\n   * that always have constant lengths */\n  signedPayloadShell: string;\n} {\n  // Placeholder structure of the signed ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: SignedCipherObject = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell,\n  };\n  // Hex encoded DER signature, up to 72 byte length.\n  const signatureLength = 144;\n  // Hex encoded 33 byte public key.\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Fast function that determines the final ASCII string byte length of the\n * JSON stringified ECIES encrypted payload.\n * @ignore\n */\nexport function eciesGetJsonStringLength(opts: {\n  contentLength: number;\n  wasString: boolean;\n  sign: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): number {\n  const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);\n\n  // Calculate the AES output length given the input length.\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n\n  // Get the encoded string length of the cipherText.\n  let encodedCipherTextLength: number;\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n\n  if (!opts.sign) {\n    // Add the length of the JSON envelope, ciphertext length, and length of const values.\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    // Get the signed version of the JSON envelope\n    const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(\n      payloadShell\n    );\n    // Add length of the JSON envelope, ciphertext length, and length of the const values.\n    return (\n      signedPayloadShell.length +\n      signedPayloadValuesLength +\n      payloadValuesLength +\n      encodedCipherTextLength\n    );\n  }\n}\n\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param publicKey - secp256k1 public key hex string\n * @param content - content to encrypt\n * @return Object containing:\n *  iv (initialization vector, hex encoding),\n *  cipherText (cipher text either hex or base64 encoded),\n *  mac (message authentication code, hex encoded),\n *  ephemeral public key (hex encoded),\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @private\n * @ignore\n */\nexport async function encryptECIES(\n  publicKey: string,\n  content: Buffer,\n  wasString: boolean,\n  cipherTextEncoding?: CipherTextEncoding\n): Promise<CipherObject> {\n  const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n  const ephemeralSK = ecurve.genKeyPair();\n  const ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());\n  const sharedSecret = ephemeralSK.derive(ecPK) as BN;\n  const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n  const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n\n  const initializationVector = randomBytes(16);\n\n  const cipherText = await aes256CbcEncrypt(\n    initializationVector,\n    sharedKeys.encryptionKey,\n    content\n  );\n\n  const macData = Buffer.concat([initializationVector, ephemeralPK, cipherText]);\n  const mac = await hmacSha256(sharedKeys.hmacKey, macData);\n\n  let cipherTextString: string;\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n    cipherTextString = cipherText.toString('hex');\n  } else if (cipherTextEncoding === 'base64') {\n    cipherTextString = cipherText.toString('base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n  }\n\n  const result: CipherObject = {\n    iv: initializationVector.toString('hex'),\n    ephemeralPK: ephemeralPK.toString('hex'),\n    cipherText: cipherTextString,\n    mac: mac.toString('hex'),\n    wasString: !!wasString,\n  };\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n    result.cipherTextEncoding = cipherTextEncoding;\n  }\n  return result;\n}\n\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @return {Buffer} plaintext\n * @throws {FailedDecryptionError} if unable to decrypt\n * @private\n * @ignore\n */\nexport async function decryptECIES(\n  privateKey: string,\n  cipherObject: CipherObject\n): Promise<Buffer | string> {\n  const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n  let ephemeralPK = null;\n  try {\n    ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n  } catch (error) {\n    throw new FailedDecryptionError(\n      'Unable to get public key from cipher object. ' +\n        'You might be trying to decrypt an unencrypted object.'\n    );\n  }\n\n  const sharedSecret = ecSK.derive(ephemeralPK) as BN;\n  const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n\n  const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n\n  const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n  let cipherTextBuffer: Buffer;\n\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n  }\n\n  const macData = Buffer.concat([\n    ivBuffer,\n    Buffer.from(ephemeralPK.encodeCompressed()),\n    cipherTextBuffer,\n  ]);\n  const actualMac = await hmacSha256(sharedKeys.hmacKey, macData);\n  const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n  if (!equalConstTime(expectedMac, actualMac)) {\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n  }\n  const plainText = await aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n\n  if (cipherObject.wasString) {\n    return plainText.toString();\n  } else {\n    return plainText;\n  }\n}\n\n/**\n * Sign content using ECDSA\n *\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @private\n * @ignore\n */\nexport function signECDSA(\n  privateKey: string,\n  content: string | Buffer\n): {\n  publicKey: string;\n  signature: string;\n} {\n  const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n  const publicKey = getPublicKeyFromPrivate(privateKey);\n  const contentHash = hashSha256Sync(contentBuffer);\n  const signature = ecPrivate.sign(contentHash);\n  const signatureString: string = signature.toDER('hex');\n  return {\n    signature: signatureString,\n    publicKey,\n  };\n}\n\n/**\n * @ignore\n */\nfunction getBuffer(content: string | ArrayBuffer | Buffer) {\n  if (content instanceof Buffer) return content;\n  else if (content instanceof ArrayBuffer) return Buffer.from(content);\n  else return Buffer.from(content);\n}\n\n/**\n * Verify content using ECDSA\n * @param {String | Buffer} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @private\n * @ignore\n */\nexport function verifyECDSA(\n  content: string | ArrayBuffer | Buffer,\n  publicKey: string,\n  signature: string\n): boolean {\n  const contentBuffer = getBuffer(content);\n  const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n  const contentHash = hashSha256Sync(contentBuffer);\n\n  return ecPublic.verify(contentHash, <any>signature);\n}\n"],"names":["ecurve","EllipticCurve","aes256CbcEncrypt","iv","key","plaintext","createCipher","cipher","encrypt","result","aes256CbcDecrypt","ciphertext","decrypt","hmacSha256","content","createHmacSha256","digest","equalConstTime","b1","b2","length","res","i","sharedSecretToKeys","sharedSecret","hashedSecret","hashSha512Sync","encryptionKey","slice","hmacKey","getHexFromBN","bnInput","hexOut","toString","padding","repeat","Error","getBufferFromBN","toArrayLike","Buffer","byteLength","getCipherObjectWrapper","opts","shell","ephemeralPK","mac","cipherText","wasString","cipherTextEncoding","ivLength","ephemeralPKLength","macLength","payloadValuesLength","payloadShell","JSON","stringify","getSignedCipherObjectWrapper","signature","publicKey","signatureLength","publicKeyLength","signedPayloadValuesLength","signedPayloadShell","eciesGetJsonStringLength","cipherTextLength","getAesCbcOutputLength","contentLength","encodedCipherTextLength","getBase64OutputLength","sign","encryptECIES","ecPK","keyFromPublic","getPublic","ephemeralSK","genKeyPair","from","encodeCompressed","derive","sharedSecretBuffer","sharedKeys","initializationVector","randomBytes","macData","concat","cipherTextString","decryptECIES","privateKey","cipherObject","ecSK","keyFromPrivate","FailedDecryptionError","ivBuffer","cipherTextBuffer","actualMac","expectedMac","plainText","signECDSA","contentBuffer","ecPrivate","getPublicKeyFromPrivate","contentHash","hashSha256Sync","signatureString","toDER","getBuffer","ArrayBuffer","verifyECDSA","ecPublic","verify"],"mappings":"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"}
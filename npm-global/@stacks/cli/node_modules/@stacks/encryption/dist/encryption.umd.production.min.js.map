{"version":3,"file":"encryption.umd.production.min.js","sources":["../../../node_modules/regenerator-runtime/runtime.js","../src/cryptoUtils.ts","../src/sha2Hash.ts","../src/hashRipemd160.ts","../src/keys.ts","../src/hmacSha256.ts","../src/aesCipher.ts","../src/utils.ts","../src/ec.ts","../src/pbkdf2.ts","../src/wallet.ts","../src/encryption.ts"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","export function isSubtleCryptoAvailable(): boolean {\n  return typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';\n}\n\nexport function isNodeCryptoAvailable<T>(\n  withFeature: (nodeCrypto: typeof import('crypto')) => boolean | T\n): false | T;\nexport function isNodeCryptoAvailable<T>(\n  withFeature?: (nodeCrypto: typeof import('crypto')) => boolean | T\n): boolean | T {\n  try {\n    const resolvedResult = require.resolve('crypto');\n    if (!resolvedResult) {\n      return false;\n    }\n    // eslint-disable-next-line import/no-nodejs-modules,no-restricted-modules,global-require\n    const cryptoModule = require('crypto') as typeof import('crypto');\n    if (!cryptoModule) {\n      return false;\n    }\n    if (withFeature) {\n      const features = withFeature(cryptoModule);\n      return features;\n    }\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport const NO_CRYPTO_LIB =\n  'Crypto lib not found. Either the WebCrypto \"crypto.subtle\" or Node.js \"crypto\" module must be available.';\n\nexport type TriplesecDecryptSignature = (\n  arg: { data: Buffer; key: Buffer },\n  cb: (err: Error | null, buff: Buffer | null) => void\n) => void;\n\nexport interface WebCryptoLib {\n  lib: SubtleCrypto;\n  name: 'subtleCrypto';\n}\n\nexport interface NodeCryptoLib {\n  lib: typeof import('crypto');\n  name: 'nodeCrypto';\n}\n\n// Make async for future version which may lazy load.\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function getCryptoLib(): Promise<WebCryptoLib | NodeCryptoLib> {\n  if (isSubtleCryptoAvailable()) {\n    return {\n      lib: crypto.subtle,\n      name: 'subtleCrypto',\n    };\n  } else {\n    try {\n      // eslint-disable-next-line max-len\n      // eslint-disable-next-line import/no-nodejs-modules,no-restricted-modules,global-require,@typescript-eslint/no-var-requires\n      const nodeCrypto = require('crypto') as typeof import('crypto');\n      return {\n        lib: nodeCrypto,\n        name: 'nodeCrypto',\n      };\n    } catch (error) {\n      throw new Error(NO_CRYPTO_LIB);\n    }\n  }\n}\n","import { sha256, sha512 } from 'sha.js';\nimport { getCryptoLib } from './cryptoUtils';\n\ntype NodeCryptoCreateHash = typeof import('crypto').createHash;\n\nexport interface Sha2Hash {\n  digest(data: Buffer, algorithm?: 'sha256' | 'sha512'): Promise<Buffer>;\n}\n\nexport class NodeCryptoSha2Hash {\n  createHash: NodeCryptoCreateHash;\n\n  constructor(createHash: NodeCryptoCreateHash) {\n    this.createHash = createHash;\n  }\n\n  async digest(data: Buffer, algorithm = 'sha256'): Promise<Buffer> {\n    try {\n      const result = this.createHash(algorithm)\n        .update(data)\n        .digest();\n      return Promise.resolve(result);\n    } catch (error) {\n      console.log(error);\n      console.log(\n        `Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`\n      );\n      return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n    }\n  }\n}\n\nexport class WebCryptoSha2Hash implements Sha2Hash {\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async digest(data: Buffer, algorithm = 'sha256'): Promise<Buffer> {\n    let algo: string;\n    if (algorithm === 'sha256') {\n      algo = 'SHA-256';\n    } else if (algorithm === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported hash algorithm ${algorithm}`);\n    }\n    try {\n      const hash = await this.subtleCrypto.digest(algo, data);\n      return Buffer.from(hash);\n    } catch (error) {\n      console.log(error);\n      console.log(\n        `Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`\n      );\n      return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n    }\n  }\n}\n\nexport async function createSha2Hash(): Promise<Sha2Hash> {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoSha2Hash(cryptoLib.lib);\n  } else {\n    return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);\n  }\n}\n\nexport function hashSha256Sync(data: Buffer) {\n  const hash = new sha256();\n  hash.update(data);\n  return hash.digest();\n}\n\nexport function hashSha512Sync(data: Buffer) {\n  const hash = new sha512();\n  hash.update(data);\n  return hash.digest();\n}\n","import Ripemd160Polyfill from 'ripemd160-min';\nimport { isNodeCryptoAvailable } from './cryptoUtils';\n\ntype NodeCryptoCreateHash = typeof import('crypto').createHash;\n\nexport interface Ripemd160Digest {\n  digest(data: Buffer): Buffer;\n}\n\nexport class Ripemd160PolyfillDigest implements Ripemd160Digest {\n  digest(data: Buffer): Buffer {\n    const instance = new Ripemd160Polyfill();\n    instance.update(data);\n    const hash = instance.digest();\n    if (Array.isArray(hash)) {\n      return Buffer.from(hash);\n    } else {\n      return Buffer.from(hash.buffer);\n    }\n  }\n}\n\nexport class NodeCryptoRipemd160Digest implements Ripemd160Digest {\n  nodeCryptoCreateHash: NodeCryptoCreateHash;\n\n  constructor(nodeCryptoCreateHash: NodeCryptoCreateHash) {\n    this.nodeCryptoCreateHash = nodeCryptoCreateHash;\n  }\n\n  digest(data: Buffer): Buffer {\n    try {\n      return this.nodeCryptoCreateHash('rmd160')\n        .update(data)\n        .digest();\n    } catch (error) {\n      try {\n        return this.nodeCryptoCreateHash('ripemd160')\n          .update(data)\n          .digest();\n      } catch (_err) {\n        console.log(error);\n        console.log(\n          'Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation'\n        );\n        const polyfill = new Ripemd160PolyfillDigest();\n        return polyfill.digest(data);\n      }\n    }\n  }\n}\n\nexport function createHashRipemd160() {\n  const nodeCryptoCreateHash = isNodeCryptoAvailable(nodeCrypto => {\n    if (typeof nodeCrypto.createHash === 'function') {\n      return nodeCrypto.createHash;\n    }\n    return false;\n  });\n  if (nodeCryptoCreateHash) {\n    return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);\n  } else {\n    return new Ripemd160PolyfillDigest();\n  }\n}\n\nexport function hashRipemd160(data: Buffer) {\n  const hash = createHashRipemd160();\n  return hash.digest(data);\n}\n","import { ECPair, address, networks, Network } from 'bitcoinjs-lib';\nimport { randomBytes } from './cryptoRandom';\nimport { hashSha256Sync } from './sha2Hash';\nimport { hashRipemd160 } from './hashRipemd160';\n\n/**\n *\n * @param numberOfBytes\n *\n * @ignore\n */\nexport function getEntropy(arg: number): Buffer {\n  if (!arg) {\n    arg = 32;\n  }\n  return randomBytes(arg);\n}\n\n/**\n * @ignore\n */\nexport function makeECPrivateKey() {\n  const keyPair = ECPair.makeRandom({ rng: getEntropy });\n  return keyPair.privateKey!.toString('hex');\n}\n\n/**\n * @ignore\n */\nexport function publicKeyToAddress(publicKey: string | Buffer) {\n  const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));\n  const result = address.toBase58Check(publicKeyHash160, networks.bitcoin.pubKeyHash);\n  return result;\n}\n\n/**\n * @ignore\n */\nexport function getPublicKeyFromPrivate(privateKey: string | Buffer) {\n  const privateKeyBuffer = Buffer.isBuffer(privateKey)\n    ? privateKey\n    : Buffer.from(privateKey, 'hex');\n  const keyPair = ECPair.fromPrivateKey(privateKeyBuffer);\n  return keyPair.publicKey.toString('hex');\n}\n\n/**\n * Time\n * @private\n * @ignore\n */\nexport function hexStringToECPair(skHex: string, network?: Network): ECPair.ECPairInterface {\n  const ecPairOptions = {\n    network: network || networks.bitcoin,\n    compressed: true,\n  };\n\n  if (skHex.length === 66) {\n    if (skHex.slice(64) !== '01') {\n      throw new Error(\n        'Improperly formatted private-key hex string. 66-length hex usually ' +\n          'indicates compressed key, but last byte must be == 1'\n      );\n    }\n    return ECPair.fromPrivateKey(Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);\n  } else if (skHex.length === 64) {\n    ecPairOptions.compressed = false;\n    return ECPair.fromPrivateKey(Buffer.from(skHex, 'hex'), ecPairOptions);\n  } else {\n    throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');\n  }\n}\n\n/**\n *\n * @ignore\n */\nexport function ecPairToHexString(secretKey: ECPair.ECPairInterface) {\n  const ecPointHex = secretKey.privateKey!.toString('hex');\n  if (secretKey.compressed) {\n    return `${ecPointHex}01`;\n  } else {\n    return ecPointHex;\n  }\n}\n\n/**\n * Creates a bitcoin address string from an ECPair\n * @private\n * @ignore\n */\nexport function ecPairToAddress(keyPair: ECPair.ECPairInterface) {\n  const sha256 = hashSha256Sync(keyPair.publicKey);\n  const hash160 = hashRipemd160(sha256);\n  return address.toBase58Check(hash160, keyPair.network.pubKeyHash);\n}\n","import { getCryptoLib } from './cryptoUtils';\n\nexport interface Hmac {\n  digest(key: Buffer, data: Buffer): Promise<Buffer>;\n}\n\ntype NodeCryptoCreateHmac = typeof import('crypto').createHmac;\n\nexport class NodeCryptoHmacSha256 implements Hmac {\n  createHmac: NodeCryptoCreateHmac;\n\n  constructor(createHmac: NodeCryptoCreateHmac) {\n    this.createHmac = createHmac;\n  }\n\n  async digest(key: Buffer, data: Buffer): Promise<Buffer> {\n    const result = this.createHmac('sha256', key)\n      .update(data)\n      .digest();\n    return Promise.resolve(result);\n  }\n}\n\nexport class WebCryptoHmacSha256 implements Hmac {\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async digest(key: Buffer, data: Buffer): Promise<Buffer> {\n    const cryptoKey = await this.subtleCrypto.importKey(\n      'raw',\n      key,\n      { name: 'HMAC', hash: 'SHA-256' },\n      true,\n      ['sign']\n    );\n    const sig = await this.subtleCrypto.sign(\n      // The `hash` is only specified for non-compliant browsers like Edge.\n      { name: 'HMAC', hash: 'SHA-256' },\n      cryptoKey,\n      data\n    );\n    return Buffer.from(sig);\n  }\n}\n\nexport async function createHmacSha256(): Promise<Hmac> {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoHmacSha256(cryptoLib.lib);\n  } else {\n    return new NodeCryptoHmacSha256(cryptoLib.lib.createHmac);\n  }\n}\n","import { getCryptoLib } from './cryptoUtils';\n\ntype NodeCryptoCreateCipher = typeof import('crypto').createCipheriv;\ntype NodeCryptoCreateDecipher = typeof import('crypto').createDecipheriv;\n\nexport type CipherAlgorithm = 'aes-256-cbc' | 'aes-128-cbc';\n\nexport interface AesCipher {\n  encrypt(algorithm: CipherAlgorithm, key: Buffer, iv: Buffer, data: Buffer): Promise<Buffer>;\n\n  decrypt(algorithm: CipherAlgorithm, key: Buffer, iv: Buffer, data: Buffer): Promise<Buffer>;\n}\n\nexport class NodeCryptoAesCipher implements AesCipher {\n  createCipher: NodeCryptoCreateCipher;\n\n  createDecipher: NodeCryptoCreateDecipher;\n\n  constructor(createCipher: NodeCryptoCreateCipher, createDecipher: NodeCryptoCreateDecipher) {\n    this.createCipher = createCipher;\n    this.createDecipher = createDecipher;\n  }\n\n  async encrypt(\n    algorithm: CipherAlgorithm,\n    key: Buffer,\n    iv: Buffer,\n    data: Buffer\n  ): Promise<Buffer> {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createCipher(algorithm, key, iv);\n    const result = Buffer.concat([cipher.update(data), cipher.final()]);\n    return Promise.resolve(result);\n  }\n\n  async decrypt(\n    algorithm: CipherAlgorithm,\n    key: Buffer,\n    iv: Buffer,\n    data: Buffer\n  ): Promise<Buffer> {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cipher = this.createDecipher(algorithm, key, iv);\n    const result = Buffer.concat([cipher.update(data), cipher.final()]);\n    return Promise.resolve(result);\n  }\n}\n\nexport class WebCryptoAesCipher implements AesCipher {\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async encrypt(\n    algorithm: CipherAlgorithm,\n    key: Buffer,\n    iv: Buffer,\n    data: Buffer\n  ): Promise<Buffer> {\n    let algo: string;\n    let length: number;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n      'encrypt',\n    ]);\n    const result = await this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);\n    return Buffer.from(result);\n  }\n\n  async decrypt(\n    algorithm: CipherAlgorithm,\n    key: Buffer,\n    iv: Buffer,\n    data: Buffer\n  ): Promise<Buffer> {\n    let algo: string;\n    let length: number;\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n      'decrypt',\n    ]);\n    const result = await this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);\n    return Buffer.from(result);\n  }\n}\n\nexport async function createCipher(): Promise<AesCipher> {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoAesCipher(cryptoLib.lib);\n  } else {\n    return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\n  }\n}\n","/**\n * Calculate the AES-CBC ciphertext output byte length a given input length.\n * AES has a fixed block size of 16-bytes regardless key size.\n * @ignore\n */\nexport function getAesCbcOutputLength(inputByteLength: number) {\n  // AES-CBC block mode rounds up to the next block size.\n  const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;\n  return cipherTextLength;\n}\n\n/**\n * Calculate the base64 encoded string length for a given input length.\n * This is equivalent to the byte length when the string is ASCII or UTF8-8\n * encoded.\n * @param number\n */\nexport function getBase64OutputLength(inputByteLength: number) {\n  const encodedLength = Math.ceil(inputByteLength / 3) * 4;\n  return encodedLength;\n}\n\n/**\n *\n * @ignore\n */\nexport function hashCode(string: string) {\n  let hash = 0;\n  if (string.length === 0) return hash;\n  for (let i = 0; i < string.length; i++) {\n    const character = string.charCodeAt(i);\n    hash = (hash << 5) - hash + character;\n    hash &= hash;\n  }\n  return hash & 0x7fffffff;\n}\n","import { ec as EllipticCurve } from 'elliptic';\nimport * as BN from 'bn.js';\nimport { randomBytes } from './cryptoRandom';\nimport { FailedDecryptionError } from '@stacks/common';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\n\nconst ecurve = new EllipticCurve('secp256k1');\n\n/**\n * Controls how the encrypted data buffer will be encoded as a string in the JSON payload.\n * Options:\n *    `hex` -- the legacy default, file size increase 100% (2x).\n *    `base64` -- file size increased ~33%.\n * @ignore\n */\nexport type CipherTextEncoding = 'hex' | 'base64';\n\n/**\n * @ignore\n */\nexport type CipherObject = {\n  iv: string;\n  ephemeralPK: string;\n  cipherText: string;\n  /** If undefined then hex encoding is used for the `cipherText` string. */\n  cipherTextEncoding?: CipherTextEncoding;\n  mac: string;\n  wasString: boolean;\n};\n\n/**\n * @ignore\n */\nexport type SignedCipherObject = {\n  /** Hex encoded DER signature (up to 144 chars) */\n  signature: string;\n  /** Hex encoded public key (66 char length) */\n  publicKey: string;\n  /** The stringified json of a `CipherObject` */\n  cipherText: string;\n};\n\n/**\n * @ignore\n */\nexport async function aes256CbcEncrypt(\n  iv: Buffer,\n  key: Buffer,\n  plaintext: Buffer\n): Promise<Buffer> {\n  const cipher = await createCipher();\n  const result = await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n  return result;\n}\n\n/**\n * @ignore\n */\nasync function aes256CbcDecrypt(iv: Buffer, key: Buffer, ciphertext: Buffer): Promise<Buffer> {\n  const cipher = await createCipher();\n  const result = await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n  return result;\n}\n\n/**\n * @ignore\n */\nasync function hmacSha256(key: Buffer, content: Buffer) {\n  const hmacSha256 = await createHmacSha256();\n  return hmacSha256.digest(key, content);\n}\n\n/**\n * @ignore\n */\nfunction equalConstTime(b1: Buffer, b2: Buffer) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/**\n * @ignore\n */\nfunction sharedSecretToKeys(sharedSecret: Buffer): { encryptionKey: Buffer; hmacKey: Buffer } {\n  // generate mac and encryption key from shared secret\n  const hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32),\n  };\n}\n\n/**\n * Hex encodes a 32-byte BN.js instance.\n * The result string is zero padded and always 64 characters in length.\n * @ignore\n */\nexport function getHexFromBN(bnInput: BN): string {\n  const hexOut = bnInput.toString('hex', 64);\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n\n/**\n * Returns a big-endian encoded 32-byte BN.js instance.\n * The result Buffer is zero padded and always 32 bytes in length.\n * @ignore\n */\nexport function getBufferFromBN(bnInput: BN): Buffer {\n  const result = bnInput.toArrayLike(Buffer, 'be', 32);\n  if (result.byteLength !== 32) {\n    throw new Error('Generated a 32-byte BN for encryption. Failing.');\n  }\n  return result;\n}\n\n/**\n * Get details about the JSON envelope size overhead for ciphertext payloads.\n * @ignore\n */\nexport function getCipherObjectWrapper(opts: {\n  wasString: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): {\n  /** The stringified JSON string of an empty `CipherObject`. */\n  payloadShell: string;\n  /** Total string length of all the `CipherObject` values that always have constant lengths. */\n  payloadValuesLength: number;\n} {\n  // Placeholder structure of the ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: CipherObject = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString,\n  };\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n  // Hex encoded 16 byte buffer.\n  const ivLength = 32;\n  // Hex encoded, compressed EC pubkey of 33 bytes.\n  const ephemeralPKLength = 66;\n  // Hex encoded 32 byte hmac-sha256.\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Get details about the JSON envelope size overhead for signed ciphertext payloads.\n * @param payloadShell - The JSON stringified empty `CipherObject`\n * @ignore\n */\nexport function getSignedCipherObjectWrapper(\n  payloadShell: string\n): {\n  /** The stringified JSON string of an empty `SignedCipherObject`. */\n  signedPayloadValuesLength: number;\n  /** Total string length of all the `SignedCipherObject` values\n   * that always have constant lengths */\n  signedPayloadShell: string;\n} {\n  // Placeholder structure of the signed ciphertext payload, used to determine the\n  // stringified JSON overhead length.\n  const shell: SignedCipherObject = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell,\n  };\n  // Hex encoded DER signature, up to 72 byte length.\n  const signatureLength = 144;\n  // Hex encoded 33 byte public key.\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell),\n  };\n}\n\n/**\n * Fast function that determines the final ASCII string byte length of the\n * JSON stringified ECIES encrypted payload.\n * @ignore\n */\nexport function eciesGetJsonStringLength(opts: {\n  contentLength: number;\n  wasString: boolean;\n  sign: boolean;\n  cipherTextEncoding: CipherTextEncoding;\n}): number {\n  const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);\n\n  // Calculate the AES output length given the input length.\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n\n  // Get the encoded string length of the cipherText.\n  let encodedCipherTextLength: number;\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n\n  if (!opts.sign) {\n    // Add the length of the JSON envelope, ciphertext length, and length of const values.\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    // Get the signed version of the JSON envelope\n    const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(\n      payloadShell\n    );\n    // Add length of the JSON envelope, ciphertext length, and length of the const values.\n    return (\n      signedPayloadShell.length +\n      signedPayloadValuesLength +\n      payloadValuesLength +\n      encodedCipherTextLength\n    );\n  }\n}\n\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param publicKey - secp256k1 public key hex string\n * @param content - content to encrypt\n * @return Object containing:\n *  iv (initialization vector, hex encoding),\n *  cipherText (cipher text either hex or base64 encoded),\n *  mac (message authentication code, hex encoded),\n *  ephemeral public key (hex encoded),\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @private\n * @ignore\n */\nexport async function encryptECIES(\n  publicKey: string,\n  content: Buffer,\n  wasString: boolean,\n  cipherTextEncoding?: CipherTextEncoding\n): Promise<CipherObject> {\n  const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n  const ephemeralSK = ecurve.genKeyPair();\n  const ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());\n  const sharedSecret = ephemeralSK.derive(ecPK) as BN;\n  const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n  const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n\n  const initializationVector = randomBytes(16);\n\n  const cipherText = await aes256CbcEncrypt(\n    initializationVector,\n    sharedKeys.encryptionKey,\n    content\n  );\n\n  const macData = Buffer.concat([initializationVector, ephemeralPK, cipherText]);\n  const mac = await hmacSha256(sharedKeys.hmacKey, macData);\n\n  let cipherTextString: string;\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n    cipherTextString = cipherText.toString('hex');\n  } else if (cipherTextEncoding === 'base64') {\n    cipherTextString = cipherText.toString('base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n  }\n\n  const result: CipherObject = {\n    iv: initializationVector.toString('hex'),\n    ephemeralPK: ephemeralPK.toString('hex'),\n    cipherText: cipherTextString,\n    mac: mac.toString('hex'),\n    wasString: !!wasString,\n  };\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n    result.cipherTextEncoding = cipherTextEncoding;\n  }\n  return result;\n}\n\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @return {Buffer} plaintext\n * @throws {FailedDecryptionError} if unable to decrypt\n * @private\n * @ignore\n */\nexport async function decryptECIES(\n  privateKey: string,\n  cipherObject: CipherObject\n): Promise<Buffer | string> {\n  const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n  let ephemeralPK = null;\n  try {\n    ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n  } catch (error) {\n    throw new FailedDecryptionError(\n      'Unable to get public key from cipher object. ' +\n        'You might be trying to decrypt an unencrypted object.'\n    );\n  }\n\n  const sharedSecret = ecSK.derive(ephemeralPK) as BN;\n  const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n\n  const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n\n  const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n  let cipherTextBuffer: Buffer;\n\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n  }\n\n  const macData = Buffer.concat([\n    ivBuffer,\n    Buffer.from(ephemeralPK.encodeCompressed()),\n    cipherTextBuffer,\n  ]);\n  const actualMac = await hmacSha256(sharedKeys.hmacKey, macData);\n  const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n  if (!equalConstTime(expectedMac, actualMac)) {\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n  }\n  const plainText = await aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n\n  if (cipherObject.wasString) {\n    return plainText.toString();\n  } else {\n    return plainText;\n  }\n}\n\n/**\n * Sign content using ECDSA\n *\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @private\n * @ignore\n */\nexport function signECDSA(\n  privateKey: string,\n  content: string | Buffer\n): {\n  publicKey: string;\n  signature: string;\n} {\n  const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n  const publicKey = getPublicKeyFromPrivate(privateKey);\n  const contentHash = hashSha256Sync(contentBuffer);\n  const signature = ecPrivate.sign(contentHash);\n  const signatureString: string = signature.toDER('hex');\n  return {\n    signature: signatureString,\n    publicKey,\n  };\n}\n\n/**\n * @ignore\n */\nfunction getBuffer(content: string | ArrayBuffer | Buffer) {\n  if (content instanceof Buffer) return content;\n  else if (content instanceof ArrayBuffer) return Buffer.from(content);\n  else return Buffer.from(content);\n}\n\n/**\n * Verify content using ECDSA\n * @param {String | Buffer} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @private\n * @ignore\n */\nexport function verifyECDSA(\n  content: string | ArrayBuffer | Buffer,\n  publicKey: string,\n  signature: string\n): boolean {\n  const contentBuffer = getBuffer(content);\n  const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n  const contentHash = hashSha256Sync(contentBuffer);\n\n  return ecPublic.verify(contentHash, <any>signature);\n}\n","import { getCryptoLib } from './cryptoUtils';\n\nexport type Pbkdf2Digests = 'sha512' | 'sha256';\n\nexport interface Pbkdf2 {\n  derive(\n    password: string,\n    salt: Buffer,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Buffer>;\n}\n\ntype NodePbkdf2Fn = typeof import('crypto').pbkdf2;\n\nexport class NodeCryptoPbkdf2 implements Pbkdf2 {\n  nodePbkdf2: NodePbkdf2Fn;\n\n  constructor(nodePbkdf2: NodePbkdf2Fn) {\n    this.nodePbkdf2 = nodePbkdf2;\n  }\n\n  async derive(\n    password: string,\n    salt: Buffer,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Buffer> {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n    return new Promise((resolve, reject) => {\n      this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n        if (error) {\n          reject(error);\n        }\n        resolve(result);\n      });\n    });\n  }\n}\n\nexport class WebCryptoPbkdf2 implements Pbkdf2 {\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(\n    password: string,\n    salt: Buffer,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Buffer> {\n    let algo: string;\n    if (digest === 'sha256') {\n      algo = 'SHA-256';\n    } else if (digest === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n    }\n    let result: ArrayBuffer;\n    const passwordBytes = Buffer.from(password, 'utf8');\n    try {\n      const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, [\n        'deriveBits',\n      ]);\n      result = await this.subtleCrypto.deriveBits(\n        {\n          name: 'PBKDF2',\n          salt,\n          iterations,\n          hash: { name: algo },\n        },\n        key,\n        keyLength * 8\n      );\n    } catch (error) {\n      // Browser appears to support WebCrypto but missing pbkdf2 support.\n      const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n      return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n    }\n    return Buffer.from(result);\n  }\n}\n\nexport class WebCryptoPartialPbkdf2 implements Pbkdf2 {\n  // An async implementation for browsers that support WebCrypto hmac\n  // but not pbkdf2. Extracted from crypto-browserify/pbkdf2 and modified to\n  // use WebCrypto for hmac operations.\n  // Original: https://github.com/crypto-browserify/pbkdf2/tree/v3.0.17/lib\n\n  subtleCrypto: SubtleCrypto;\n\n  constructor(subtleCrypto: SubtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(\n    password: string,\n    salt: Buffer,\n    iterations: number,\n    keyLength: number,\n    digest: Pbkdf2Digests\n  ): Promise<Buffer> {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n    const key = Buffer.from(password, 'utf8');\n    const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n    const algoOpts = { name: 'HMAC', hash: algo };\n    const hmacDigest = (key: ArrayBuffer, data: ArrayBuffer) =>\n      this.subtleCrypto\n        .importKey('raw', key, algoOpts, true, ['sign'])\n        .then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data))\n        .then(result => new Uint8Array(result));\n\n    const DK = new Uint8Array(keyLength);\n    const saltLength = salt.length;\n    const block1 = new Uint8Array(saltLength + 4);\n    block1.set(salt);\n    let destPos = 0;\n    const hLen = digest === 'sha512' ? 64 : 32;\n    const l = Math.ceil(keyLength / hLen);\n\n    function writeUInt32BE(data: Uint8Array, value: number, offset: number) {\n      value = +value;\n      offset >>>= 0;\n      data[offset] = value >>> 24;\n      data[offset + 1] = value >>> 16;\n      data[offset + 2] = value >>> 8;\n      data[offset + 3] = value & 0xff;\n      return offset + 4;\n    }\n\n    for (let i = 1; i <= l; i++) {\n      writeUInt32BE(block1, i, saltLength);\n      // eslint-disable-next-line no-await-in-loop\n      const T = await hmacDigest(key, block1);\n      let U = T;\n      for (let j = 1; j < iterations; j++) {\n        // eslint-disable-next-line no-await-in-loop\n        U = await hmacDigest(key, U);\n        for (let k = 0; k < hLen; k++) {\n          T[k] ^= U[k];\n        }\n      }\n      DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n      destPos += hLen;\n    }\n    return Buffer.from(DK.buffer);\n  }\n}\n\nexport async function createPbkdf2(): Promise<Pbkdf2> {\n  const cryptoLib = await getCryptoLib();\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoPbkdf2(cryptoLib.lib);\n  } else {\n    return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n  }\n}\n","import { validateMnemonic, mnemonicToEntropy, entropyToMnemonic } from 'bip39';\nimport { randomBytes, GetRandomBytes } from './cryptoRandom';\nimport { createSha2Hash } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { createPbkdf2 } from './pbkdf2';\nimport { TriplesecDecryptSignature } from './cryptoUtils';\n\n/**\n * Encrypt a raw mnemonic phrase to be password protected\n * @param {string} phrase - Raw mnemonic phrase\n * @param {string} password - Password to encrypt mnemonic with\n * @return {Promise<Buffer>} The encrypted phrase\n * @private\n * @ignore\n * */\nexport async function encryptMnemonic(\n  phrase: string,\n  password: string,\n  opts?: {\n    getRandomBytes?: GetRandomBytes;\n  }\n): Promise<Buffer> {\n  // hex encoded mnemonic string\n  let mnemonicEntropy: string;\n  try {\n    // must be bip39 mnemonic\n    mnemonicEntropy = mnemonicToEntropy(phrase);\n  } catch (error) {\n    console.error('Invalid mnemonic phrase provided');\n    console.error(error);\n    throw new Error('Not a valid bip39 mnemonic');\n  }\n\n  // normalize plaintext to fixed length byte string\n  const plaintextNormalized = Buffer.from(mnemonicEntropy, 'hex');\n\n  // AES-128-CBC with SHA256 HMAC\n  const pbkdf2 = await createPbkdf2();\n  let salt: Buffer;\n  if (opts && opts.getRandomBytes) {\n    salt = opts.getRandomBytes(16);\n  } else {\n    salt = randomBytes(16);\n  }\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n\n  const cipher = await createCipher();\n  const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);\n\n  const hmacPayload = Buffer.concat([salt, cipherText]);\n  const hmacSha256 = await createHmacSha256();\n  const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n\n  const payload = Buffer.concat([salt, hmacDigest, cipherText]);\n  return payload;\n}\n\n// Used to distinguish bad password during decrypt vs invalid format\nclass PasswordError extends Error {}\n\n/**\n * @ignore\n */\nasync function decryptMnemonicBuffer(dataBuffer: Buffer, password: string): Promise<string> {\n  const salt = dataBuffer.slice(0, 16);\n  const hmacSig = dataBuffer.slice(16, 48); // 32 bytes\n  const cipherText = dataBuffer.slice(48);\n  const hmacPayload = Buffer.concat([salt, cipherText]);\n\n  const pbkdf2 = await createPbkdf2();\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n\n  const decipher = await createCipher();\n  const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);\n\n  const hmacSha256 = await createHmacSha256();\n  const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n\n  // hash both hmacSig and hmacDigest so string comparison time\n  // is uncorrelated to the ciphertext\n  const sha2Hash = await createSha2Hash();\n  const hmacSigHash = await sha2Hash.digest(hmacSig);\n  const hmacDigestHash = await sha2Hash.digest(hmacDigest);\n\n  if (!hmacSigHash.equals(hmacDigestHash)) {\n    // not authentic\n    throw new PasswordError('Wrong password (HMAC mismatch)');\n  }\n\n  let mnemonic: string;\n  try {\n    mnemonic = entropyToMnemonic(decryptedResult);\n  } catch (error) {\n    console.error('Error thrown by `entropyToMnemonic`');\n    console.error(error);\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n  if (!validateMnemonic(mnemonic)) {\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n\n  return mnemonic;\n}\n\n/**\n * Decrypt legacy triplesec keys\n * @param {Buffer} dataBuffer - The encrypted key\n * @param {String} password - Password for data\n * @return {Promise<Buffer>} Decrypted seed\n * @private\n * @ignore\n */\nfunction decryptLegacy(\n  dataBuffer: Buffer,\n  password: string,\n  triplesecDecrypt?: TriplesecDecryptSignature\n): Promise<Buffer> {\n  return new Promise<Buffer>((resolve, reject) => {\n    if (!triplesecDecrypt) {\n      reject(new Error('The `triplesec.decrypt` function must be provided'));\n    }\n    triplesecDecrypt!(\n      {\n        key: Buffer.from(password),\n        data: dataBuffer,\n      },\n      (err, plaintextBuffer) => {\n        if (!err) {\n          resolve(plaintextBuffer!);\n        } else {\n          reject(err);\n        }\n      }\n    );\n  });\n}\n\n/**\n * Decrypt an encrypted mnemonic phrase with a password.\n * Legacy triplesec encrypted payloads are also supported.\n * @param data - Buffer or hex-encoded string of the encrypted mnemonic\n * @param password - Password for data\n * @return the raw mnemonic phrase\n * @private\n * @ignore\n */\nexport async function decryptMnemonic(\n  data: string | Buffer,\n  password: string,\n  triplesecDecrypt?: TriplesecDecryptSignature\n) {\n  const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n  try {\n    return await decryptMnemonicBuffer(dataBuffer, password);\n  } catch (err) {\n    if (err instanceof PasswordError) {\n      throw err;\n    }\n    const data = await decryptLegacy(dataBuffer, password, triplesecDecrypt);\n    return data.toString();\n  }\n}\n","import {\n  CipherTextEncoding,\n  SignedCipherObject,\n  encryptECIES,\n  decryptECIES,\n  signECDSA,\n} from './ec';\n\nimport { getPublicKeyFromPrivate } from './keys';\n\nexport interface EncryptionOptions {\n  /**\n   * If set to `true` the data is signed using ECDSA on SHA256 hashes with the user's\n   * app private key. If a string is specified, it is used as the private key instead\n   * of the user's app private key.\n   * @default false\n   */\n  sign?: boolean | string;\n  /**\n   * String encoding format for the cipherText buffer.\n   * Currently defaults to 'hex' for legacy backwards-compatibility.\n   * Only used if the `encrypt` option is also used.\n   * Note: in the future this should default to 'base64' for the significant\n   * file size reduction.\n   */\n  cipherTextEncoding?: CipherTextEncoding;\n  /**\n   * Specifies if the original unencrypted content is a ASCII or UTF-8 string.\n   * For example stringified JSON.\n   * If true, then when the ciphertext is decrypted, it will be returned as\n   * a `string` type variable, otherwise will be returned as a Buffer.\n   */\n  wasString?: boolean;\n}\n\n/**\n * Specify encryption options, and whether to sign the ciphertext.\n */\nexport interface EncryptContentOptions extends EncryptionOptions {\n  /**\n   * Encrypt the data with this key.\n   */\n  publicKey?: string;\n  /**\n   * Encrypt the data with the public key corresponding to the supplied private key\n   */\n  privateKey?: string;\n}\n\n/**\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\nexport async function encryptContent(\n  content: string | Buffer,\n  options?: EncryptContentOptions\n): Promise<string> {\n  const opts = Object.assign({}, options);\n  let privateKey: string | undefined;\n  if (!opts.publicKey) {\n    if (!opts.privateKey) {\n      throw new Error('Either public key or private key must be supplied for encryption.');\n    }\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n  }\n  let wasString: boolean;\n  if (typeof opts.wasString === 'boolean') {\n    wasString = opts.wasString;\n  } else {\n    wasString = typeof content === 'string';\n  }\n  const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n  const cipherObject = await encryptECIES(\n    opts.publicKey,\n    contentBuffer,\n    wasString,\n    opts.cipherTextEncoding\n  );\n  let cipherPayload = JSON.stringify(cipherObject);\n  if (opts.sign) {\n    if (typeof opts.sign === 'string') {\n      privateKey = opts.sign;\n    } else if (!privateKey) {\n      privateKey = opts.privateKey;\n    }\n    const signatureObject = signECDSA(privateKey!, cipherPayload);\n    const signedCipherObject: SignedCipherObject = {\n      signature: signatureObject.signature,\n      publicKey: signatureObject.publicKey,\n      cipherText: cipherPayload,\n    };\n    cipherPayload = JSON.stringify(signedCipherObject);\n  }\n  return cipherPayload;\n}\n\n/**\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\nexport function decryptContent(\n  content: string,\n  options?: {\n    privateKey?: string;\n  }\n): Promise<string | Buffer> {\n  const opts = Object.assign({}, options);\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error(\n        'Failed to parse encrypted content JSON. The content may not ' +\n          'be encrypted. If using getFile, try passing { decrypt: false }.'\n      );\n    } else {\n      throw err;\n    }\n  }\n}\n"],"names":["runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","isSubtleCryptoAvailable","crypto","subtle","NO_CRYPTO_LIB","getCryptoLib","lib","nodeCrypto","require","NodeCryptoSha2Hash","createHash","digest","data","algorithm","update","console","log","hashSha256Sync","hashSha512Sync","WebCryptoSha2Hash","subtleCrypto","algo","Buffer","from","createSha2Hash","cryptoLib","hash","sha256","sha512","Ripemd160PolyfillDigest","instance","Ripemd160Polyfill","Array","isArray","buffer","NodeCryptoRipemd160Digest","nodeCryptoCreateHash","_err","hashRipemd160","withFeature","cryptoModule","isNodeCryptoAvailable","getEntropy","randomBytes","getPublicKeyFromPrivate","privateKey","privateKeyBuffer","isBuffer","ECPair","fromPrivateKey","publicKey","NodeCryptoHmacSha256","createHmac","WebCryptoHmacSha256","importKey","cryptoKey","sign","createHmacSha256","NodeCryptoAesCipher","createCipher","createDecipher","encrypt","iv","cipher","concat","decrypt","WebCryptoAesCipher","createCipheriv","createDecipheriv","getAesCbcOutputLength","inputByteLength","Math","floor","getBase64OutputLength","ceil","ecurve","EllipticCurve","aes256CbcEncrypt","plaintext","aes256CbcDecrypt","ciphertext","hmacSha256","content","equalConstTime","b1","b2","res","sharedSecretToKeys","sharedSecret","hashedSecret","encryptionKey","hmacKey","getBufferFromBN","bnInput","toArrayLike","byteLength","getCipherObjectWrapper","opts","shell","ephemeralPK","mac","cipherText","wasString","cipherTextEncoding","payloadValuesLength","ivLength","payloadShell","JSON","stringify","getSignedCipherObjectWrapper","signedPayloadValuesLength","signatureLength","signedPayloadShell","signature","encryptECIES","ecPK","keyFromPublic","getPublic","ephemeralSK","genKeyPair","encodeCompressed","derive","sharedSecretBuffer","sharedKeys","initializationVector","macData","cipherTextString","decryptECIES","cipherObject","ecSK","keyFromPrivate","FailedDecryptionError","ivBuffer","cipherTextBuffer","actualMac","plainText","signECDSA","contentBuffer","ecPrivate","contentHash","toDER","NodeCryptoPbkdf2","nodePbkdf2","password","salt","iterations","keyLength","_this","WebCryptoPbkdf2","passwordBytes","deriveBits","partialWebCrypto","WebCryptoPartialPbkdf2","writeUInt32BE","offset","algoOpts","hmacDigest","_this2","Uint8Array","DK","saltLength","block1","set","destPos","hLen","l","U","T","j","k","subarray","createPbkdf2","pbkdf2","phrase","mnemonicEntropy","mnemonicToEntropy","plaintextNormalized","getRandomBytes","encKey","keysAndIV","macKey","hmacPayload","payload","PasswordError","decryptMnemonicBuffer","dataBuffer","hmacSig","decipher","decryptedResult","sha2Hash","hmacSigHash","equals","mnemonic","entropyToMnemonic","validateMnemonic","decryptLegacy","triplesecDecrypt","plaintextBuffer","_context3","options","assign","cipherPayload","signatureObject","parse","SyntaxError","keyPair","hash160","address","toBase58Check","network","pubKeyHash","secretKey","ecPointHex","compressed","encodedCipherTextLength","cipherTextLength","contentLength","hexOut","repeat","string","charCodeAt","skHex","ecPairOptions","networks","bitcoin","makeRandom","rng","publicKeyHash160","ArrayBuffer","getBuffer","ecPublic","verify"],"mappings":"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"}
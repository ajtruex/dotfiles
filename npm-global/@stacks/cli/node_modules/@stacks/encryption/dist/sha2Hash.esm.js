import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';
import runtime_1 from './node_modules/regenerator-runtime/runtime.esm.js';
import { sha256, sha512 } from 'sha.js';
import { getCryptoLib } from './cryptoUtils.esm.js';

var NodeCryptoSha2Hash = /*#__PURE__*/function () {
  function NodeCryptoSha2Hash(createHash) {
    this.createHash = createHash;
  }

  var _proto = NodeCryptoSha2Hash.prototype;

  _proto.digest = /*#__PURE__*/function () {
    var _digest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(data, algorithm) {
      var result;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (algorithm === void 0) {
                algorithm = 'sha256';
              }

              _context.prev = 1;
              result = this.createHash(algorithm).update(data).digest();
              return _context.abrupt("return", Promise.resolve(result));

            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](1);
              console.log(_context.t0);
              console.log("Error performing " + algorithm + " digest with Node.js 'crypto.createHash', falling back to JS implementation.");
              return _context.abrupt("return", Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data)));

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 6]]);
    }));

    function digest(_x, _x2) {
      return _digest.apply(this, arguments);
    }

    return digest;
  }();

  return NodeCryptoSha2Hash;
}();
var WebCryptoSha2Hash = /*#__PURE__*/function () {
  function WebCryptoSha2Hash(subtleCrypto) {
    this.subtleCrypto = subtleCrypto;
  }

  var _proto2 = WebCryptoSha2Hash.prototype;

  _proto2.digest = /*#__PURE__*/function () {
    var _digest2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(data, algorithm) {
      var algo, hash;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (algorithm === void 0) {
                algorithm = 'sha256';
              }

              if (!(algorithm === 'sha256')) {
                _context2.next = 5;
                break;
              }

              algo = 'SHA-256';
              _context2.next = 10;
              break;

            case 5:
              if (!(algorithm === 'sha512')) {
                _context2.next = 9;
                break;
              }

              algo = 'SHA-512';
              _context2.next = 10;
              break;

            case 9:
              throw new Error("Unsupported hash algorithm " + algorithm);

            case 10:
              _context2.prev = 10;
              _context2.next = 13;
              return this.subtleCrypto.digest(algo, data);

            case 13:
              hash = _context2.sent;
              return _context2.abrupt("return", Buffer.from(hash));

            case 17:
              _context2.prev = 17;
              _context2.t0 = _context2["catch"](10);
              console.log(_context2.t0);
              console.log("Error performing " + algorithm + " digest with WebCrypto, falling back to JS implementation.");
              return _context2.abrupt("return", Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data)));

            case 22:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[10, 17]]);
    }));

    function digest(_x3, _x4) {
      return _digest2.apply(this, arguments);
    }

    return digest;
  }();

  return WebCryptoSha2Hash;
}();
function createSha2Hash() {
  return _createSha2Hash.apply(this, arguments);
}

function _createSha2Hash() {
  _createSha2Hash = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
    var cryptoLib;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return getCryptoLib();

          case 2:
            cryptoLib = _context3.sent;

            if (!(cryptoLib.name === 'subtleCrypto')) {
              _context3.next = 7;
              break;
            }

            return _context3.abrupt("return", new WebCryptoSha2Hash(cryptoLib.lib));

          case 7:
            return _context3.abrupt("return", new NodeCryptoSha2Hash(cryptoLib.lib.createHash));

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _createSha2Hash.apply(this, arguments);
}

function hashSha256Sync(data) {
  var hash = new sha256();
  hash.update(data);
  return hash.digest();
}
function hashSha512Sync(data) {
  var hash = new sha512();
  hash.update(data);
  return hash.digest();
}

export { NodeCryptoSha2Hash, WebCryptoSha2Hash, createSha2Hash, hashSha256Sync, hashSha512Sync };
//# sourceMappingURL=sha2Hash.esm.js.map

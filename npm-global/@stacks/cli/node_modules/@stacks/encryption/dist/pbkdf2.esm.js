import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';
import runtime_1 from './node_modules/regenerator-runtime/runtime.esm.js';
import { getCryptoLib } from './cryptoUtils.esm.js';

var NodeCryptoPbkdf2 = /*#__PURE__*/function () {
  function NodeCryptoPbkdf2(nodePbkdf2) {
    this.nodePbkdf2 = nodePbkdf2;
  }

  var _proto = NodeCryptoPbkdf2.prototype;

  _proto.derive = /*#__PURE__*/function () {
    var _derive = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(password, salt, iterations, keyLength, digest) {
      var _this = this;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(digest !== 'sha512' && digest !== 'sha256')) {
                _context.next = 2;
                break;
              }

              throw new Error("Unsupported digest \"" + digest + "\" for Pbkdf2");

            case 2:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                _this.nodePbkdf2(password, salt, iterations, keyLength, digest, function (error, result) {
                  if (error) {
                    reject(error);
                  }

                  resolve(result);
                });
              }));

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function derive(_x, _x2, _x3, _x4, _x5) {
      return _derive.apply(this, arguments);
    }

    return derive;
  }();

  return NodeCryptoPbkdf2;
}();
var WebCryptoPbkdf2 = /*#__PURE__*/function () {
  function WebCryptoPbkdf2(subtleCrypto) {
    this.subtleCrypto = subtleCrypto;
  }

  var _proto2 = WebCryptoPbkdf2.prototype;

  _proto2.derive = /*#__PURE__*/function () {
    var _derive2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(password, salt, iterations, keyLength, digest) {
      var algo, result, passwordBytes, key, partialWebCrypto;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(digest === 'sha256')) {
                _context2.next = 4;
                break;
              }

              algo = 'SHA-256';
              _context2.next = 9;
              break;

            case 4:
              if (!(digest === 'sha512')) {
                _context2.next = 8;
                break;
              }

              algo = 'SHA-512';
              _context2.next = 9;
              break;

            case 8:
              throw new Error("Unsupported Pbkdf2 digest algorithm \"" + digest + "\"");

            case 9:
              passwordBytes = Buffer.from(password, 'utf8');
              _context2.prev = 10;
              _context2.next = 13;
              return this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, ['deriveBits']);

            case 13:
              key = _context2.sent;
              _context2.next = 16;
              return this.subtleCrypto.deriveBits({
                name: 'PBKDF2',
                salt: salt,
                iterations: iterations,
                hash: {
                  name: algo
                }
              }, key, keyLength * 8);

            case 16:
              result = _context2.sent;
              _context2.next = 23;
              break;

            case 19:
              _context2.prev = 19;
              _context2.t0 = _context2["catch"](10);
              partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);
              return _context2.abrupt("return", partialWebCrypto.derive(password, salt, iterations, keyLength, digest));

            case 23:
              return _context2.abrupt("return", Buffer.from(result));

            case 24:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[10, 19]]);
    }));

    function derive(_x6, _x7, _x8, _x9, _x10) {
      return _derive2.apply(this, arguments);
    }

    return derive;
  }();

  return WebCryptoPbkdf2;
}();
var WebCryptoPartialPbkdf2 = /*#__PURE__*/function () {
  function WebCryptoPartialPbkdf2(subtleCrypto) {
    this.subtleCrypto = subtleCrypto;
  }

  var _proto3 = WebCryptoPartialPbkdf2.prototype;

  _proto3.derive = /*#__PURE__*/function () {
    var _derive3 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(password, salt, iterations, keyLength, digest) {
      var _this2 = this;

      var key, algo, algoOpts, hmacDigest, DK, saltLength, block1, destPos, hLen, l, writeUInt32BE, i, T, U, j, k;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              writeUInt32BE = function _writeUInt32BE(data, value, offset) {
                value = +value;
                offset >>>= 0;
                data[offset] = value >>> 24;
                data[offset + 1] = value >>> 16;
                data[offset + 2] = value >>> 8;
                data[offset + 3] = value & 0xff;
                return offset + 4;
              };

              if (!(digest !== 'sha512' && digest !== 'sha256')) {
                _context3.next = 3;
                break;
              }

              throw new Error("Unsupported digest \"" + digest + "\" for Pbkdf2");

            case 3:
              key = Buffer.from(password, 'utf8');
              algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';
              algoOpts = {
                name: 'HMAC',
                hash: algo
              };

              hmacDigest = function hmacDigest(key, data) {
                return _this2.subtleCrypto.importKey('raw', key, algoOpts, true, ['sign']).then(function (cryptoKey) {
                  return _this2.subtleCrypto.sign(algoOpts, cryptoKey, data);
                }).then(function (result) {
                  return new Uint8Array(result);
                });
              };

              DK = new Uint8Array(keyLength);
              saltLength = salt.length;
              block1 = new Uint8Array(saltLength + 4);
              block1.set(salt);
              destPos = 0;
              hLen = digest === 'sha512' ? 64 : 32;
              l = Math.ceil(keyLength / hLen);
              i = 1;

            case 15:
              if (!(i <= l)) {
                _context3.next = 35;
                break;
              }

              writeUInt32BE(block1, i, saltLength);
              _context3.next = 19;
              return hmacDigest(key, block1);

            case 19:
              T = _context3.sent;
              U = T;
              j = 1;

            case 22:
              if (!(j < iterations)) {
                _context3.next = 30;
                break;
              }

              _context3.next = 25;
              return hmacDigest(key, U);

            case 25:
              U = _context3.sent;

              for (k = 0; k < hLen; k++) {
                T[k] ^= U[k];
              }

            case 27:
              j++;
              _context3.next = 22;
              break;

            case 30:
              DK.set(T.subarray(0, DK.byteLength - destPos), destPos);
              destPos += hLen;

            case 32:
              i++;
              _context3.next = 15;
              break;

            case 35:
              return _context3.abrupt("return", Buffer.from(DK.buffer));

            case 36:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function derive(_x11, _x12, _x13, _x14, _x15) {
      return _derive3.apply(this, arguments);
    }

    return derive;
  }();

  return WebCryptoPartialPbkdf2;
}();
function createPbkdf2() {
  return _createPbkdf.apply(this, arguments);
}

function _createPbkdf() {
  _createPbkdf = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
    var cryptoLib;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return getCryptoLib();

          case 2:
            cryptoLib = _context4.sent;

            if (!(cryptoLib.name === 'subtleCrypto')) {
              _context4.next = 7;
              break;
            }

            return _context4.abrupt("return", new WebCryptoPbkdf2(cryptoLib.lib));

          case 7:
            return _context4.abrupt("return", new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2));

          case 8:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _createPbkdf.apply(this, arguments);
}

export { NodeCryptoPbkdf2, WebCryptoPartialPbkdf2, WebCryptoPbkdf2, createPbkdf2 };
//# sourceMappingURL=pbkdf2.esm.js.map

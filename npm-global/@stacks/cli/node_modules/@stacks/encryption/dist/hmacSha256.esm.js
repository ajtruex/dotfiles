import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';
import runtime_1 from './node_modules/regenerator-runtime/runtime.esm.js';
import { getCryptoLib } from './cryptoUtils.esm.js';

var NodeCryptoHmacSha256 = /*#__PURE__*/function () {
  function NodeCryptoHmacSha256(createHmac) {
    this.createHmac = createHmac;
  }

  var _proto = NodeCryptoHmacSha256.prototype;

  _proto.digest = /*#__PURE__*/function () {
    var _digest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(key, data) {
      var result;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              result = this.createHmac('sha256', key).update(data).digest();
              return _context.abrupt("return", Promise.resolve(result));

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function digest(_x, _x2) {
      return _digest.apply(this, arguments);
    }

    return digest;
  }();

  return NodeCryptoHmacSha256;
}();
var WebCryptoHmacSha256 = /*#__PURE__*/function () {
  function WebCryptoHmacSha256(subtleCrypto) {
    this.subtleCrypto = subtleCrypto;
  }

  var _proto2 = WebCryptoHmacSha256.prototype;

  _proto2.digest = /*#__PURE__*/function () {
    var _digest2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(key, data) {
      var cryptoKey, sig;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.subtleCrypto.importKey('raw', key, {
                name: 'HMAC',
                hash: 'SHA-256'
              }, true, ['sign']);

            case 2:
              cryptoKey = _context2.sent;
              _context2.next = 5;
              return this.subtleCrypto.sign({
                name: 'HMAC',
                hash: 'SHA-256'
              }, cryptoKey, data);

            case 5:
              sig = _context2.sent;
              return _context2.abrupt("return", Buffer.from(sig));

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function digest(_x3, _x4) {
      return _digest2.apply(this, arguments);
    }

    return digest;
  }();

  return WebCryptoHmacSha256;
}();
function createHmacSha256() {
  return _createHmacSha.apply(this, arguments);
}

function _createHmacSha() {
  _createHmacSha = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
    var cryptoLib;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return getCryptoLib();

          case 2:
            cryptoLib = _context3.sent;

            if (!(cryptoLib.name === 'subtleCrypto')) {
              _context3.next = 7;
              break;
            }

            return _context3.abrupt("return", new WebCryptoHmacSha256(cryptoLib.lib));

          case 7:
            return _context3.abrupt("return", new NodeCryptoHmacSha256(cryptoLib.lib.createHmac));

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _createHmacSha.apply(this, arguments);
}

export { NodeCryptoHmacSha256, WebCryptoHmacSha256, createHmacSha256 };
//# sourceMappingURL=hmacSha256.esm.js.map

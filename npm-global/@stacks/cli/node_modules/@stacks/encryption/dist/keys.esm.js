import randomBytes from 'randombytes';
import { ECPair, address, networks } from 'bitcoinjs-lib';
import { hashSha256Sync } from './sha2Hash.esm.js';
import { hashRipemd160 } from './hashRipemd160.esm.js';

function getEntropy(arg) {
  if (!arg) {
    arg = 32;
  }

  return randomBytes(arg);
}
function makeECPrivateKey() {
  var keyPair = ECPair.makeRandom({
    rng: getEntropy
  });
  return keyPair.privateKey.toString('hex');
}
function publicKeyToAddress(publicKey) {
  var publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');
  var publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));
  var result = address.toBase58Check(publicKeyHash160, networks.bitcoin.pubKeyHash);
  return result;
}
function getPublicKeyFromPrivate(privateKey) {
  var privateKeyBuffer = Buffer.isBuffer(privateKey) ? privateKey : Buffer.from(privateKey, 'hex');
  var keyPair = ECPair.fromPrivateKey(privateKeyBuffer);
  return keyPair.publicKey.toString('hex');
}
function hexStringToECPair(skHex, network) {
  var ecPairOptions = {
    network: network || networks.bitcoin,
    compressed: true
  };

  if (skHex.length === 66) {
    if (skHex.slice(64) !== '01') {
      throw new Error('Improperly formatted private-key hex string. 66-length hex usually ' + 'indicates compressed key, but last byte must be == 1');
    }

    return ECPair.fromPrivateKey(Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);
  } else if (skHex.length === 64) {
    ecPairOptions.compressed = false;
    return ECPair.fromPrivateKey(Buffer.from(skHex, 'hex'), ecPairOptions);
  } else {
    throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');
  }
}
function ecPairToHexString(secretKey) {
  var ecPointHex = secretKey.privateKey.toString('hex');

  if (secretKey.compressed) {
    return ecPointHex + "01";
  } else {
    return ecPointHex;
  }
}
function ecPairToAddress(keyPair) {
  var sha256 = hashSha256Sync(keyPair.publicKey);
  var hash160 = hashRipemd160(sha256);
  return address.toBase58Check(hash160, keyPair.network.pubKeyHash);
}

export { ecPairToAddress, ecPairToHexString, getEntropy, getPublicKeyFromPrivate, hexStringToECPair, makeECPrivateKey, publicKeyToAddress };
//# sourceMappingURL=keys.esm.js.map

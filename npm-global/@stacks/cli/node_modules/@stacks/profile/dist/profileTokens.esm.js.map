{"version":3,"file":"profileTokens.esm.js","sources":["../src/profileTokens.ts"],"sourcesContent":["import { ECPair } from 'bitcoinjs-lib';\nimport { decodeToken, SECP256K1Client, TokenSigner, TokenVerifier } from 'jsontokens';\nimport { TokenInterface } from 'jsontokens/lib/decode';\nimport { nextYear, makeUUID4 } from '@stacks/common';\nimport { ecPairToAddress } from '@stacks/encryption';\n\n/**\n * Signs a profile token\n * @param {Object} profile - the JSON of the profile to be signed\n * @param {String} privateKey - the signing private key\n * @param {Object} subject - the entity that the information is about\n * @param {Object} issuer - the entity that is issuing the token\n * @param {String} signingAlgorithm - the signing algorithm to use\n * @param {Date} issuedAt - the time of issuance of the token\n * @param {Date} expiresAt - the time of expiration of the token\n * @returns {Object} - the signed profile token\n *\n */\nexport function signProfileToken(\n  profile: any,\n  privateKey: string,\n  subject?: any,\n  issuer?: any,\n  signingAlgorithm = 'ES256K',\n  issuedAt = new Date(),\n  expiresAt = nextYear()\n): string {\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n\n  if (!subject) {\n    subject = { publicKey };\n  }\n\n  if (!issuer) {\n    issuer = { publicKey };\n  }\n\n  const tokenSigner = new TokenSigner(signingAlgorithm, privateKey);\n\n  const payload = {\n    jti: makeUUID4(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject,\n    issuer,\n    claim: profile,\n  };\n\n  return tokenSigner.sign(payload);\n}\n\n/**\n * Wraps a token for a profile token file\n * @param {String} token - the token to be wrapped\n * @returns {Object} - including `token` and `decodedToken`\n */\nexport function wrapProfileToken(token: string) {\n  return {\n    token,\n    decodedToken: decodeToken(token),\n  };\n}\n\n/**\n * Verifies a profile token\n * @param {String} token - the token to be verified\n * @param {String} publicKeyOrAddress - the public key or address of the\n *   keypair that is thought to have signed the token\n * @returns {Object} - the verified, decoded profile token\n * @throws {Error} - throws an error if token verification fails\n */\nexport function verifyProfileToken(token: string, publicKeyOrAddress: string): TokenInterface {\n  const decodedToken = decodeToken(token);\n  const payload = decodedToken.payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  // Inspect and verify the subject\n  if (payload.hasOwnProperty('subject') && payload.subject) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have a subject public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have a subject\");\n  }\n\n  // Inspect and verify the issuer\n  if (payload.hasOwnProperty('issuer') && payload.issuer) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have an issuer public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have an issuer\");\n  }\n\n  // Inspect and verify the claim\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error(\"Token doesn't have a claim\");\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  const issuerPublicKey = (payload.issuer as Record<string, string>).publicKey as string;\n  const publicKeyBuffer = Buffer.from(issuerPublicKey, 'hex');\n\n  const compressedKeyPair = ECPair.fromPublicKey(publicKeyBuffer, { compressed: true });\n  const compressedAddress = ecPairToAddress(compressedKeyPair);\n  const uncompressedKeyPair = ECPair.fromPublicKey(publicKeyBuffer, { compressed: false });\n  const uncompressedAddress = ecPairToAddress(uncompressedKeyPair);\n\n  if (publicKeyOrAddress === issuerPublicKey) {\n    // pass\n  } else if (publicKeyOrAddress === compressedAddress) {\n    // pass\n  } else if (publicKeyOrAddress === uncompressedAddress) {\n    // pass\n  } else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  const tokenVerifier = new TokenVerifier(decodedToken.header.alg as string, issuerPublicKey);\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  const tokenVerified = tokenVerifier.verify(token);\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\n\n/**\n * Extracts a profile from an encoded token and optionally verifies it,\n * if `publicKeyOrAddress` is provided.\n * @param {String} token - the token to be extracted\n * @param {String} publicKeyOrAddress - the public key or address of the\n *   keypair that is thought to have signed the token\n * @returns {Object} - the profile extracted from the encoded token\n * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\n */\nexport function extractProfile(\n  token: string,\n  publicKeyOrAddress: string | null = null\n): Record<string, any> {\n  let decodedToken;\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = decodeToken(token);\n  }\n\n  let profile = {};\n  if (decodedToken.hasOwnProperty('payload')) {\n    const payload = decodedToken.payload;\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.hasOwnProperty('claim')) {\n      profile = payload.claim as object;\n    }\n  }\n\n  return profile;\n}\n"],"names":["signProfileToken","profile","privateKey","subject","issuer","signingAlgorithm","issuedAt","expiresAt","Date","nextYear","Error","publicKey","SECP256K1Client","derivePublicKey","tokenSigner","TokenSigner","payload","jti","makeUUID4","iat","toISOString","exp","claim","sign","wrapProfileToken","token","decodedToken","decodeToken","verifyProfileToken","publicKeyOrAddress","hasOwnProperty","issuerPublicKey","publicKeyBuffer","Buffer","from","compressedKeyPair","ECPair","fromPublicKey","compressed","compressedAddress","ecPairToAddress","uncompressedKeyPair","uncompressedAddress","tokenVerifier","TokenVerifier","header","alg","tokenVerified","verify","extractProfile"],"mappings":"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"}
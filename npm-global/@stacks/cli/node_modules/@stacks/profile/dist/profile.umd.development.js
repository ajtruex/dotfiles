(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('bitcoinjs-lib'), require('jsontokens'), require('@stacks/common'), require('@stacks/encryption'), require('zone-file'), require('schema-inspector')) :
  typeof define === 'function' && define.amd ? define(['exports', 'bitcoinjs-lib', 'jsontokens', '@stacks/common', '@stacks/encryption', 'zone-file', 'schema-inspector'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@stacks/profile'] = {}, global.bitcoinjsLib, global.jsontokens, global.common, global.encryption, global.zoneFile, global.inspector));
}(this, (function (exports, bitcoinjsLib, jsontokens, common, encryption, zoneFile, inspector) { 'use strict';

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm, issuedAt, expiresAt) {
    if (signingAlgorithm === void 0) {
      signingAlgorithm = 'ES256K';
    }

    if (issuedAt === void 0) {
      issuedAt = new Date();
    }

    if (expiresAt === void 0) {
      expiresAt = common.nextYear();
    }

    if (signingAlgorithm !== 'ES256K') {
      throw new Error('Signing algorithm not supported');
    }

    var publicKey = jsontokens.SECP256K1Client.derivePublicKey(privateKey);

    if (!subject) {
      subject = {
        publicKey: publicKey
      };
    }

    if (!issuer) {
      issuer = {
        publicKey: publicKey
      };
    }

    var tokenSigner = new jsontokens.TokenSigner(signingAlgorithm, privateKey);
    var payload = {
      jti: common.makeUUID4(),
      iat: issuedAt.toISOString(),
      exp: expiresAt.toISOString(),
      subject: subject,
      issuer: issuer,
      claim: profile
    };
    return tokenSigner.sign(payload);
  }
  function wrapProfileToken(token) {
    return {
      token: token,
      decodedToken: jsontokens.decodeToken(token)
    };
  }
  function verifyProfileToken(token, publicKeyOrAddress) {
    var decodedToken = jsontokens.decodeToken(token);
    var payload = decodedToken.payload;

    if (typeof payload === 'string') {
      throw new Error('Unexpected token payload type of string');
    }

    if (payload.hasOwnProperty('subject') && payload.subject) {
      if (!payload.subject.hasOwnProperty('publicKey')) {
        throw new Error("Token doesn't have a subject public key");
      }
    } else {
      throw new Error("Token doesn't have a subject");
    }

    if (payload.hasOwnProperty('issuer') && payload.issuer) {
      if (!payload.issuer.hasOwnProperty('publicKey')) {
        throw new Error("Token doesn't have an issuer public key");
      }
    } else {
      throw new Error("Token doesn't have an issuer");
    }

    if (!payload.hasOwnProperty('claim')) {
      throw new Error("Token doesn't have a claim");
    }

    var issuerPublicKey = payload.issuer.publicKey;
    var publicKeyBuffer = Buffer.from(issuerPublicKey, 'hex');
    var compressedKeyPair = bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer, {
      compressed: true
    });
    var compressedAddress = encryption.ecPairToAddress(compressedKeyPair);
    var uncompressedKeyPair = bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer, {
      compressed: false
    });
    var uncompressedAddress = encryption.ecPairToAddress(uncompressedKeyPair);

    if (publicKeyOrAddress === issuerPublicKey) ; else if (publicKeyOrAddress === compressedAddress) ; else if (publicKeyOrAddress === uncompressedAddress) ; else {
      throw new Error('Token issuer public key does not match the verifying value');
    }

    var tokenVerifier = new jsontokens.TokenVerifier(decodedToken.header.alg, issuerPublicKey);

    if (!tokenVerifier) {
      throw new Error('Invalid token verifier');
    }

    var tokenVerified = tokenVerifier.verify(token);

    if (!tokenVerified) {
      throw new Error('Token verification failed');
    }

    return decodedToken;
  }
  function extractProfile(token, publicKeyOrAddress) {
    if (publicKeyOrAddress === void 0) {
      publicKeyOrAddress = null;
    }

    var decodedToken;

    if (publicKeyOrAddress) {
      decodedToken = verifyProfileToken(token, publicKeyOrAddress);
    } else {
      decodedToken = jsontokens.decodeToken(token);
    }

    var profile = {};

    if (decodedToken.hasOwnProperty('payload')) {
      var payload = decodedToken.payload;

      if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
      }

      if (payload.hasOwnProperty('claim')) {
        profile = payload.claim;
      }
    }

    return profile;
  }

  function formatAccount(serviceName, data) {
    var proofUrl;

    if (data.proof && data.proof.url) {
      proofUrl = data.proof.url;
    }

    return {
      '@type': 'Account',
      service: serviceName,
      identifier: data.username,
      proofType: 'http',
      proofUrl: proofUrl
    };
  }

  function getPersonFromLegacyFormat(profile) {
    var profileData = {
      '@type': 'Person'
    };

    if (profile) {
      if (profile.name && profile.name.formatted) {
        profileData.name = profile.name.formatted;
      }

      if (profile.bio) {
        profileData.description = profile.bio;
      }

      if (profile.location && profile.location.formatted) {
        profileData.address = {
          '@type': 'PostalAddress',
          addressLocality: profile.location.formatted
        };
      }

      var images = [];

      if (profile.avatar && profile.avatar.url) {
        images.push({
          '@type': 'ImageObject',
          name: 'avatar',
          contentUrl: profile.avatar.url
        });
      }

      if (profile.cover && profile.cover.url) {
        images.push({
          '@type': 'ImageObject',
          name: 'cover',
          contentUrl: profile.cover.url
        });
      }

      if (images.length) {
        profileData.image = images;
      }

      if (profile.website) {
        profileData.website = [{
          '@type': 'WebSite',
          url: profile.website
        }];
      }

      var accounts = [];

      if (profile.bitcoin && profile.bitcoin.address) {
        accounts.push({
          '@type': 'Account',
          role: 'payment',
          service: 'bitcoin',
          identifier: profile.bitcoin.address
        });
      }

      if (profile.twitter && profile.twitter.username) {
        accounts.push(formatAccount('twitter', profile.twitter));
      }

      if (profile.facebook && profile.facebook.username) {
        accounts.push(formatAccount('facebook', profile.facebook));
      }

      if (profile.github && profile.github.username) {
        accounts.push(formatAccount('github', profile.github));
      }

      if (profile.auth) {
        if (profile.auth.length > 0) {
          if (profile.auth[0] && profile.auth[0].publicKeychain) {
            accounts.push({
              '@type': 'Account',
              role: 'key',
              service: 'bip32',
              identifier: profile.auth[0].publicKeychain
            });
          }
        }
      }

      if (profile.pgp && profile.pgp.url) {
        accounts.push({
          '@type': 'Account',
          role: 'key',
          service: 'pgp',
          identifier: profile.pgp.fingerprint,
          contentUrl: profile.pgp.url
        });
      }

      profileData.account = accounts;
    }

    return profileData;
  }

  function resolveZoneFileToPerson(zoneFile$1, publicKeyOrAddress, callback) {
    var zoneFileJson = null;

    try {
      zoneFileJson = zoneFile.parseZoneFile(zoneFile$1);

      if (!zoneFileJson.hasOwnProperty('$origin')) {
        zoneFileJson = null;
        throw new Error('zone file is missing an origin');
      }
    } catch (e) {
      console.error(e);
    }

    var tokenFileUrl = null;

    if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {
      tokenFileUrl = getTokenFileUrl(zoneFileJson);
    } else {
      var profile = null;

      try {
        profile = JSON.parse(zoneFile$1);
        var person = Person.fromLegacyFormat(profile);
        profile = person.profile();
      } catch (error) {
        console.warn(error);
      }

      callback(profile);
      return;
    }

    if (tokenFileUrl) {
      common.fetchPrivate(tokenFileUrl).then(function (response) {
        return response.text();
      }).then(function (responseText) {
        return JSON.parse(responseText);
      }).then(function (responseJson) {
        var tokenRecords = responseJson;
        var token = tokenRecords[0].token;
        var profile = extractProfile(token, publicKeyOrAddress);
        callback(profile);
      })["catch"](function (error) {
        console.warn(error);
      });
    } else {
      console.warn('Token file url not found');
      callback({});
    }
  }

  function getName(profile) {
    if (!profile) {
      return null;
    }

    var name = null;

    if (profile.name) {
      name = profile.name;
    } else if (profile.givenName || profile.familyName) {
      name = '';

      if (profile.givenName) {
        name = profile.givenName;
      }

      if (profile.familyName) {
        name += " " + profile.familyName;
      }
    }

    return name;
  }
  function getGivenName(profile) {
    if (!profile) {
      return null;
    }

    var givenName = null;

    if (profile.givenName) {
      givenName = profile.givenName;
    } else if (profile.name) {
      var nameParts = profile.name.split(' ');
      givenName = nameParts.slice(0, -1).join(' ');
    }

    return givenName;
  }
  function getFamilyName(profile) {
    if (!profile) {
      return null;
    }

    var familyName = null;

    if (profile.familyName) {
      familyName = profile.familyName;
    } else if (profile.name) {
      var nameParts = profile.name.split(' ');
      familyName = nameParts.pop();
    }

    return familyName;
  }
  function getDescription(profile) {
    if (!profile) {
      return null;
    }

    var description = null;

    if (profile.description) {
      description = profile.description;
    }

    return description;
  }
  function getAvatarUrl(profile) {
    if (!profile) {
      return null;
    }

    var avatarContentUrl = null;

    if (profile.image) {
      profile.image.map(function (image) {
        if (image.name === 'avatar') {
          avatarContentUrl = image.contentUrl;
          return avatarContentUrl;
        } else {
          return null;
        }
      });
    }

    return avatarContentUrl;
  }
  function getVerifiedAccounts(profile, verifications) {
    if (!profile) {
      return null;
    }

    var filteredAccounts = [];

    if (profile.hasOwnProperty('account') && verifications) {
      profile.account.map(function (account) {
        var accountIsValid = false;
        var proofUrl = null;
        verifications.map(function (verification) {
          if (verification.hasOwnProperty('proof_url')) {
            verification.proofUrl = verification.proof_url;
          }

          if (verification.valid && verification.service === account.service && verification.identifier === account.identifier && verification.proofUrl) {
            accountIsValid = true;
            proofUrl = verification.proofUrl;
            return true;
          } else {
            return false;
          }
        });

        if (accountIsValid) {
          account.proofUrl = proofUrl;
          filteredAccounts.push(account);
          return account;
        } else {
          return null;
        }
      });
    }

    return filteredAccounts;
  }
  function getOrganizations(profile) {
    if (!profile) {
      return null;
    }

    var organizations = [];

    if (profile.hasOwnProperty('worksFor')) {
      return profile.worksFor;
    }

    return organizations;
  }
  function getConnections(profile) {
    if (!profile) {
      return null;
    }

    var connections = [];

    if (profile.hasOwnProperty('knows')) {
      connections = profile.knows;
    }

    return connections;
  }
  function getAddress(profile) {
    if (!profile) {
      return null;
    }

    var addressString = null;

    if (profile.hasOwnProperty('address')) {
      var addressParts = [];

      if (profile.address.hasOwnProperty('streetAddress')) {
        addressParts.push(profile.address.streetAddress);
      }

      if (profile.address.hasOwnProperty('addressLocality')) {
        addressParts.push(profile.address.addressLocality);
      }

      if (profile.address.hasOwnProperty('postalCode')) {
        addressParts.push(profile.address.postalCode);
      }

      if (profile.address.hasOwnProperty('addressCountry')) {
        addressParts.push(profile.address.addressCountry);
      }

      if (addressParts.length) {
        addressString = addressParts.join(', ');
      }
    }

    return addressString;
  }
  function getBirthDate(profile) {
    if (!profile) {
      return null;
    }

    var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var birthDateString = null;

    if (profile.hasOwnProperty('birthDate')) {
      var date = new Date(profile.birthDate);
      birthDateString = monthNames[date.getMonth()] + " " + date.getDate() + ", " + date.getFullYear();
    }

    return birthDateString;
  }

  var schemaDefinition = {
    type: 'object',
    properties: {
      '@context': {
        type: 'string',
        optional: true
      },
      '@type': {
        type: 'string'
      }
    }
  };
  var Profile = /*#__PURE__*/function () {
    function Profile(profile) {
      if (profile === void 0) {
        profile = {};
      }

      this._profile = Object.assign({}, {
        '@context': 'http://schema.org/'
      }, profile);
    }

    var _proto = Profile.prototype;

    _proto.toJSON = function toJSON() {
      return Object.assign({}, this._profile);
    };

    _proto.toToken = function toToken(privateKey) {
      return signProfileToken(this.toJSON(), privateKey);
    };

    Profile.validateSchema = function validateSchema(profile, strict) {
      if (strict === void 0) {
        strict = false;
      }

      schemaDefinition.strict = strict;
      return inspector.validate(schemaDefinition, profile);
    };

    Profile.fromToken = function fromToken(token, publicKeyOrAddress) {
      if (publicKeyOrAddress === void 0) {
        publicKeyOrAddress = null;
      }

      var profile = extractProfile(token, publicKeyOrAddress);
      return new Profile(profile);
    };

    Profile.makeZoneFile = function makeZoneFile(domainName, tokenFileURL) {
      return makeProfileZoneFile(domainName, tokenFileURL);
    };

    return Profile;
  }();
  var Person = /*#__PURE__*/function (_Profile) {
    _inheritsLoose(Person, _Profile);

    function Person(profile) {
      var _this;

      if (profile === void 0) {
        profile = {};
      }

      _this = _Profile.call(this, profile) || this;
      _this._profile = Object.assign({}, {
        '@type': 'Person'
      }, _this._profile);
      return _this;
    }

    Person.validateSchema = function validateSchema(profile, strict) {
      return inspector.validate(schemaDefinition, profile);
    };

    Person.fromToken = function fromToken(token, publicKeyOrAddress) {
      if (publicKeyOrAddress === void 0) {
        publicKeyOrAddress = null;
      }

      var profile = extractProfile(token, publicKeyOrAddress);
      return new Person(profile);
    };

    Person.fromLegacyFormat = function fromLegacyFormat(legacyProfile) {
      var profile = getPersonFromLegacyFormat(legacyProfile);
      return new Person(profile);
    };

    var _proto2 = Person.prototype;

    _proto2.toJSON = function toJSON() {
      return {
        profile: this.profile(),
        name: this.name(),
        givenName: this.givenName(),
        familyName: this.familyName(),
        description: this.description(),
        avatarUrl: this.avatarUrl(),
        verifiedAccounts: this.verifiedAccounts(),
        address: this.address(),
        birthDate: this.birthDate(),
        connections: this.connections(),
        organizations: this.organizations()
      };
    };

    _proto2.profile = function profile() {
      return Object.assign({}, this._profile);
    };

    _proto2.name = function name() {
      return getName(this.profile());
    };

    _proto2.givenName = function givenName() {
      return getGivenName(this.profile());
    };

    _proto2.familyName = function familyName() {
      return getFamilyName(this.profile());
    };

    _proto2.description = function description() {
      return getDescription(this.profile());
    };

    _proto2.avatarUrl = function avatarUrl() {
      return getAvatarUrl(this.profile());
    };

    _proto2.verifiedAccounts = function verifiedAccounts(verifications) {
      return getVerifiedAccounts(this.profile(), verifications);
    };

    _proto2.address = function address() {
      return getAddress(this.profile());
    };

    _proto2.birthDate = function birthDate() {
      return getBirthDate(this.profile());
    };

    _proto2.connections = function connections() {
      return getConnections(this.profile());
    };

    _proto2.organizations = function organizations() {
      return getOrganizations(this.profile());
    };

    return Person;
  }(Profile);
  function makeProfileZoneFile(origin, tokenFileUrl) {
    if (!tokenFileUrl.includes('://')) {
      throw new Error('Invalid token file url');
    }

    var urlScheme = tokenFileUrl.split('://')[0];
    var urlParts = tokenFileUrl.split('://')[1].split('/');
    var domain = urlParts[0];
    var pathname = "/" + urlParts.slice(1).join('/');
    var zoneFile$1 = {
      $origin: origin,
      $ttl: 3600,
      uri: [{
        name: '_http._tcp',
        priority: 10,
        weight: 1,
        target: urlScheme + "://" + domain + pathname
      }]
    };
    var zoneFileTemplate = '{$origin}\n{$ttl}\n{uri}\n';
    return zoneFile.makeZoneFile(zoneFile$1, zoneFileTemplate);
  }
  function getTokenFileUrl(zoneFileJson) {
    if (!zoneFileJson.hasOwnProperty('uri')) {
      return null;
    }

    if (!Array.isArray(zoneFileJson.uri)) {
      return null;
    }

    if (zoneFileJson.uri.length < 1) {
      return null;
    }

    var firstUriRecord = zoneFileJson.uri[0];

    if (!firstUriRecord.hasOwnProperty('target')) {
      return null;
    }

    var tokenFileUrl = firstUriRecord.target;

    if (tokenFileUrl.startsWith('https')) ; else if (tokenFileUrl.startsWith('http')) ; else {
      tokenFileUrl = "https://" + tokenFileUrl;
    }

    return tokenFileUrl;
  }
  function resolveZoneFileToProfile(zoneFile$1, publicKeyOrAddress) {
    return new Promise(function (resolve, reject) {
      var zoneFileJson = null;

      try {
        zoneFileJson = zoneFile.parseZoneFile(zoneFile$1);

        if (!zoneFileJson.hasOwnProperty('$origin')) {
          zoneFileJson = null;
        }
      } catch (e) {
        reject(e);
      }

      var tokenFileUrl = null;

      if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {
        tokenFileUrl = getTokenFileUrl(zoneFileJson);
      } else {
        var profile = null;

        try {
          profile = JSON.parse(zoneFile$1);
          profile = Person.fromLegacyFormat(profile).profile();
        } catch (error) {
          reject(error);
        }

        resolve(profile);
        return;
      }

      if (tokenFileUrl) {
        common.fetchPrivate(tokenFileUrl).then(function (response) {
          return response.text();
        }).then(function (responseText) {
          return JSON.parse(responseText);
        }).then(function (responseJson) {
          var tokenRecords = responseJson;
          var profile = extractProfile(tokenRecords[0].token, publicKeyOrAddress);
          resolve(profile);
        })["catch"](function (error) {
          common.Logger.error("resolveZoneFileToProfile: error fetching token file " + tokenFileUrl + ": " + error);
          reject(error);
        });
      } else {
        common.Logger.debug('Token file url not found. Resolving to blank profile.');
        resolve({});
      }
    });
  }

  exports.Person = Person;
  exports.Profile = Profile;
  exports.extractProfile = extractProfile;
  exports.getTokenFileUrl = getTokenFileUrl;
  exports.makeProfileZoneFile = makeProfileZoneFile;
  exports.resolveZoneFileToPerson = resolveZoneFileToPerson;
  exports.resolveZoneFileToProfile = resolveZoneFileToProfile;
  exports.signProfileToken = signProfileToken;
  exports.verifyProfileToken = verifyProfileToken;
  exports.wrapProfileToken = wrapProfileToken;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=profile.umd.development.js.map

{"version":3,"file":"profile.umd.production.min.js","sources":["../src/profileTokens.ts","../src/profileSchemas/personLegacy.ts","../src/profile.ts","../src/profileSchemas/personUtils.ts","../src/profileSchemas/personZoneFiles.ts"],"sourcesContent":["import { ECPair } from 'bitcoinjs-lib';\nimport { decodeToken, SECP256K1Client, TokenSigner, TokenVerifier } from 'jsontokens';\nimport { TokenInterface } from 'jsontokens/lib/decode';\nimport { nextYear, makeUUID4 } from '@stacks/common';\nimport { ecPairToAddress } from '@stacks/encryption';\n\n/**\n * Signs a profile token\n * @param {Object} profile - the JSON of the profile to be signed\n * @param {String} privateKey - the signing private key\n * @param {Object} subject - the entity that the information is about\n * @param {Object} issuer - the entity that is issuing the token\n * @param {String} signingAlgorithm - the signing algorithm to use\n * @param {Date} issuedAt - the time of issuance of the token\n * @param {Date} expiresAt - the time of expiration of the token\n * @returns {Object} - the signed profile token\n *\n */\nexport function signProfileToken(\n  profile: any,\n  privateKey: string,\n  subject?: any,\n  issuer?: any,\n  signingAlgorithm = 'ES256K',\n  issuedAt = new Date(),\n  expiresAt = nextYear()\n): string {\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n\n  if (!subject) {\n    subject = { publicKey };\n  }\n\n  if (!issuer) {\n    issuer = { publicKey };\n  }\n\n  const tokenSigner = new TokenSigner(signingAlgorithm, privateKey);\n\n  const payload = {\n    jti: makeUUID4(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject,\n    issuer,\n    claim: profile,\n  };\n\n  return tokenSigner.sign(payload);\n}\n\n/**\n * Wraps a token for a profile token file\n * @param {String} token - the token to be wrapped\n * @returns {Object} - including `token` and `decodedToken`\n */\nexport function wrapProfileToken(token: string) {\n  return {\n    token,\n    decodedToken: decodeToken(token),\n  };\n}\n\n/**\n * Verifies a profile token\n * @param {String} token - the token to be verified\n * @param {String} publicKeyOrAddress - the public key or address of the\n *   keypair that is thought to have signed the token\n * @returns {Object} - the verified, decoded profile token\n * @throws {Error} - throws an error if token verification fails\n */\nexport function verifyProfileToken(token: string, publicKeyOrAddress: string): TokenInterface {\n  const decodedToken = decodeToken(token);\n  const payload = decodedToken.payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  // Inspect and verify the subject\n  if (payload.hasOwnProperty('subject') && payload.subject) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have a subject public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have a subject\");\n  }\n\n  // Inspect and verify the issuer\n  if (payload.hasOwnProperty('issuer') && payload.issuer) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error(\"Token doesn't have an issuer public key\");\n    }\n  } else {\n    throw new Error(\"Token doesn't have an issuer\");\n  }\n\n  // Inspect and verify the claim\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error(\"Token doesn't have a claim\");\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  const issuerPublicKey = (payload.issuer as Record<string, string>).publicKey as string;\n  const publicKeyBuffer = Buffer.from(issuerPublicKey, 'hex');\n\n  const compressedKeyPair = ECPair.fromPublicKey(publicKeyBuffer, { compressed: true });\n  const compressedAddress = ecPairToAddress(compressedKeyPair);\n  const uncompressedKeyPair = ECPair.fromPublicKey(publicKeyBuffer, { compressed: false });\n  const uncompressedAddress = ecPairToAddress(uncompressedKeyPair);\n\n  if (publicKeyOrAddress === issuerPublicKey) {\n    // pass\n  } else if (publicKeyOrAddress === compressedAddress) {\n    // pass\n  } else if (publicKeyOrAddress === uncompressedAddress) {\n    // pass\n  } else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  const tokenVerifier = new TokenVerifier(decodedToken.header.alg as string, issuerPublicKey);\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  const tokenVerified = tokenVerifier.verify(token);\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\n\n/**\n * Extracts a profile from an encoded token and optionally verifies it,\n * if `publicKeyOrAddress` is provided.\n * @param {String} token - the token to be extracted\n * @param {String} publicKeyOrAddress - the public key or address of the\n *   keypair that is thought to have signed the token\n * @returns {Object} - the profile extracted from the encoded token\n * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\n */\nexport function extractProfile(\n  token: string,\n  publicKeyOrAddress: string | null = null\n): Record<string, any> {\n  let decodedToken;\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = decodeToken(token);\n  }\n\n  let profile = {};\n  if (decodedToken.hasOwnProperty('payload')) {\n    const payload = decodedToken.payload;\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.hasOwnProperty('claim')) {\n      profile = payload.claim as object;\n    }\n  }\n\n  return profile;\n}\n","/**\n *\n * @param serviceName\n * @param data\n *\n * @ignore\n */\nfunction formatAccount(serviceName: string, data: any) {\n  let proofUrl;\n  if (data.proof && data.proof.url) {\n    proofUrl = data.proof.url;\n  }\n  return {\n    '@type': 'Account',\n    service: serviceName,\n    identifier: data.username,\n    proofType: 'http',\n    proofUrl,\n  };\n}\n\n/**\n *\n * @param profile\n *\n * @ignore\n */\nexport function getPersonFromLegacyFormat(profile: any) {\n  const profileData: {\n    ['@type']: string;\n    account?: any[];\n    name?: string;\n    description?: string;\n    address?: {\n      ['@type']: string;\n      addressLocality: string;\n    };\n    image?: any[];\n    website?: Array<{\n      ['@type']: string;\n      url: string;\n    }>;\n  } = {\n    '@type': 'Person',\n  };\n\n  if (profile) {\n    if (profile.name && profile.name.formatted) {\n      profileData.name = profile.name.formatted;\n    }\n\n    if (profile.bio) {\n      profileData.description = profile.bio;\n    }\n\n    if (profile.location && profile.location.formatted) {\n      profileData.address = {\n        '@type': 'PostalAddress',\n        addressLocality: profile.location.formatted,\n      };\n    }\n\n    const images = [];\n    if (profile.avatar && profile.avatar.url) {\n      images.push({\n        '@type': 'ImageObject',\n        name: 'avatar',\n        contentUrl: profile.avatar.url,\n      });\n    }\n    if (profile.cover && profile.cover.url) {\n      images.push({\n        '@type': 'ImageObject',\n        name: 'cover',\n        contentUrl: profile.cover.url,\n      });\n    }\n    if (images.length) {\n      profileData.image = images;\n    }\n\n    if (profile.website) {\n      profileData.website = [\n        {\n          '@type': 'WebSite',\n          url: profile.website,\n        },\n      ];\n    }\n\n    const accounts = [];\n    if (profile.bitcoin && profile.bitcoin.address) {\n      accounts.push({\n        '@type': 'Account',\n        role: 'payment',\n        service: 'bitcoin',\n        identifier: profile.bitcoin.address,\n      });\n    }\n    if (profile.twitter && profile.twitter.username) {\n      accounts.push(formatAccount('twitter', profile.twitter));\n    }\n    if (profile.facebook && profile.facebook.username) {\n      accounts.push(formatAccount('facebook', profile.facebook));\n    }\n    if (profile.github && profile.github.username) {\n      accounts.push(formatAccount('github', profile.github));\n    }\n\n    if (profile.auth) {\n      if (profile.auth.length > 0) {\n        if (profile.auth[0] && profile.auth[0].publicKeychain) {\n          accounts.push({\n            '@type': 'Account',\n            role: 'key',\n            service: 'bip32',\n            identifier: profile.auth[0].publicKeychain,\n          });\n        }\n      }\n    }\n    if (profile.pgp && profile.pgp.url) {\n      accounts.push({\n        '@type': 'Account',\n        role: 'key',\n        service: 'pgp',\n        identifier: profile.pgp.fingerprint,\n        contentUrl: profile.pgp.url,\n      });\n    }\n\n    profileData.account = accounts;\n  }\n\n  return profileData;\n}\n","import { signProfileToken, extractProfile } from './profileTokens';\n\nimport { getPersonFromLegacyFormat } from './profileSchemas';\nimport {\n  getName,\n  getFamilyName,\n  getGivenName,\n  getAvatarUrl,\n  getDescription,\n  getVerifiedAccounts,\n  getAddress,\n  getBirthDate,\n  getConnections,\n  getOrganizations,\n} from './profileSchemas/personUtils';\n\n// TODO: bring into this monorepo/convert to ts\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport { makeZoneFile, parseZoneFile } from 'zone-file';\n\n// Could not find a declaration file for module\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport * as inspector from 'schema-inspector';\n\nimport { Logger, fetchPrivate } from '@stacks/common';\n\nconst schemaDefinition: { [key: string]: any } = {\n  type: 'object',\n  properties: {\n    '@context': { type: 'string', optional: true },\n    '@type': { type: 'string' },\n  },\n};\n\n/**\n * Represents a user profile\n *\n */\nexport class Profile {\n  _profile: { [key: string]: any };\n\n  constructor(profile = {}) {\n    this._profile = Object.assign(\n      {},\n      {\n        '@context': 'http://schema.org/',\n      },\n      profile\n    );\n  }\n\n  toJSON() {\n    return Object.assign({}, this._profile);\n  }\n\n  toToken(privateKey: string): string {\n    return signProfileToken(this.toJSON(), privateKey);\n  }\n\n  static validateSchema(profile: any, strict = false): any {\n    schemaDefinition.strict = strict;\n    return inspector.validate(schemaDefinition, profile);\n  }\n\n  static fromToken(token: string, publicKeyOrAddress: string | null = null): Profile {\n    const profile = extractProfile(token, publicKeyOrAddress);\n    return new Profile(profile);\n  }\n\n  static makeZoneFile(domainName: string, tokenFileURL: string): string {\n    return makeProfileZoneFile(domainName, tokenFileURL);\n  }\n}\n\nconst personSchemaDefinition = {\n  type: 'object',\n  strict: false,\n  properties: {\n    '@context': { type: 'string', optional: true },\n    '@type': { type: 'string' },\n    '@id': { type: 'string', optional: true },\n    name: { type: 'string', optional: true },\n    givenName: { type: 'string', optional: true },\n    familyName: { type: 'string', optional: true },\n    description: { type: 'string', optional: true },\n    image: {\n      type: 'array',\n      optional: true,\n      items: {\n        type: 'object',\n        properties: {\n          '@type': { type: 'string' },\n          name: { type: 'string', optional: true },\n          contentUrl: { type: 'string', optional: true },\n        },\n      },\n    },\n    website: {\n      type: 'array',\n      optional: true,\n      items: {\n        type: 'object',\n        properties: {\n          '@type': { type: 'string' },\n          url: { type: 'string', optional: true },\n        },\n      },\n    },\n    account: {\n      type: 'array',\n      optional: true,\n      items: {\n        type: 'object',\n        properties: {\n          '@type': { type: 'string' },\n          service: { type: 'string', optional: true },\n          identifier: { type: 'string', optional: true },\n          proofType: { type: 'string', optional: true },\n          proofUrl: { type: 'string', optional: true },\n          proofMessage: { type: 'string', optional: true },\n          proofSignature: { type: 'string', optional: true },\n        },\n      },\n    },\n    worksFor: {\n      type: 'array',\n      optional: true,\n      items: {\n        type: 'object',\n        properties: {\n          '@type': { type: 'string' },\n          '@id': { type: 'string', optional: true },\n        },\n      },\n    },\n    knows: {\n      type: 'array',\n      optional: true,\n      items: {\n        type: 'object',\n        properties: {\n          '@type': { type: 'string' },\n          '@id': { type: 'string', optional: true },\n        },\n      },\n    },\n    address: {\n      type: 'object',\n      optional: true,\n      properties: {\n        '@type': { type: 'string' },\n        streetAddress: { type: 'string', optional: true },\n        addressLocality: { type: 'string', optional: true },\n        postalCode: { type: 'string', optional: true },\n        addressCountry: { type: 'string', optional: true },\n      },\n    },\n    birthDate: { type: 'string', optional: true },\n    taxID: { type: 'string', optional: true },\n  },\n};\n\n/**\n * @ignore\n */\nexport class Person extends Profile {\n  constructor(profile = {}) {\n    super(profile);\n    this._profile = Object.assign(\n      {},\n      {\n        '@type': 'Person',\n      },\n      this._profile\n    );\n  }\n\n  static validateSchema(profile: any, strict = false) {\n    personSchemaDefinition.strict = strict;\n    return inspector.validate(schemaDefinition, profile);\n  }\n\n  static fromToken(token: string, publicKeyOrAddress: string | null = null): Person {\n    const profile = extractProfile(token, publicKeyOrAddress);\n    return new Person(profile);\n  }\n\n  static fromLegacyFormat(legacyProfile: any) {\n    const profile = getPersonFromLegacyFormat(legacyProfile);\n    return new Person(profile);\n  }\n\n  toJSON() {\n    return {\n      profile: this.profile(),\n      name: this.name(),\n      givenName: this.givenName(),\n      familyName: this.familyName(),\n      description: this.description(),\n      avatarUrl: this.avatarUrl(),\n      verifiedAccounts: this.verifiedAccounts(),\n      address: this.address(),\n      birthDate: this.birthDate(),\n      connections: this.connections(),\n      organizations: this.organizations(),\n    };\n  }\n\n  profile() {\n    return Object.assign({}, this._profile);\n  }\n\n  name() {\n    return getName(this.profile());\n  }\n\n  givenName() {\n    return getGivenName(this.profile());\n  }\n\n  familyName() {\n    return getFamilyName(this.profile());\n  }\n\n  description() {\n    return getDescription(this.profile());\n  }\n\n  avatarUrl() {\n    return getAvatarUrl(this.profile());\n  }\n\n  verifiedAccounts(verifications?: any[]) {\n    return getVerifiedAccounts(this.profile(), verifications);\n  }\n\n  address() {\n    return getAddress(this.profile());\n  }\n\n  birthDate() {\n    return getBirthDate(this.profile());\n  }\n\n  connections() {\n    return getConnections(this.profile());\n  }\n\n  organizations() {\n    return getOrganizations(this.profile());\n  }\n}\n\n/**\n *\n * @param origin\n * @param tokenFileUrl\n *\n * @ignore\n */\nexport function makeProfileZoneFile(origin: string, tokenFileUrl: string): string {\n  if (!tokenFileUrl.includes('://')) {\n    throw new Error('Invalid token file url');\n  }\n\n  const urlScheme = tokenFileUrl.split('://')[0];\n  const urlParts = tokenFileUrl.split('://')[1].split('/');\n  const domain = urlParts[0];\n  const pathname = `/${urlParts.slice(1).join('/')}`;\n\n  const zoneFile = {\n    $origin: origin,\n    $ttl: 3600,\n    uri: [\n      {\n        name: '_http._tcp',\n        priority: 10,\n        weight: 1,\n        target: `${urlScheme}://${domain}${pathname}`,\n      },\n    ],\n  };\n\n  const zoneFileTemplate = '{$origin}\\n{$ttl}\\n{uri}\\n';\n\n  return makeZoneFile(zoneFile, zoneFileTemplate);\n}\n\n/**\n *\n * @param zoneFileJson\n *\n * @ignore\n */\nexport function getTokenFileUrl(zoneFileJson: any): string | null {\n  if (!zoneFileJson.hasOwnProperty('uri')) {\n    return null;\n  }\n  if (!Array.isArray(zoneFileJson.uri)) {\n    return null;\n  }\n  if (zoneFileJson.uri.length < 1) {\n    return null;\n  }\n  const firstUriRecord = zoneFileJson.uri[0];\n\n  if (!firstUriRecord.hasOwnProperty('target')) {\n    return null;\n  }\n  let tokenFileUrl = firstUriRecord.target;\n\n  if (tokenFileUrl.startsWith('https')) {\n    // pass\n  } else if (tokenFileUrl.startsWith('http')) {\n    // pass\n  } else {\n    tokenFileUrl = `https://${tokenFileUrl}`;\n  }\n\n  return tokenFileUrl;\n}\n\n/**\n *\n * @param zoneFile\n * @param publicKeyOrAddress\n *\n * @ignore\n */\nexport function resolveZoneFileToProfile(zoneFile: any, publicKeyOrAddress: string) {\n  return new Promise((resolve, reject) => {\n    let zoneFileJson = null;\n    try {\n      zoneFileJson = parseZoneFile(zoneFile);\n      if (!zoneFileJson.hasOwnProperty('$origin')) {\n        zoneFileJson = null;\n      }\n    } catch (e) {\n      reject(e);\n    }\n\n    let tokenFileUrl: string | null = null;\n    if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {\n      tokenFileUrl = getTokenFileUrl(zoneFileJson);\n    } else {\n      let profile = null;\n      try {\n        profile = JSON.parse(zoneFile);\n        profile = Person.fromLegacyFormat(profile).profile();\n      } catch (error) {\n        reject(error);\n      }\n      resolve(profile);\n      return;\n    }\n\n    if (tokenFileUrl) {\n      fetchPrivate(tokenFileUrl)\n        .then(response => response.text())\n        .then(responseText => JSON.parse(responseText))\n        .then(responseJson => {\n          const tokenRecords = responseJson;\n          const profile = extractProfile(tokenRecords[0].token, publicKeyOrAddress);\n          resolve(profile);\n        })\n        .catch(error => {\n          Logger.error(\n            `resolveZoneFileToProfile: error fetching token file ${tokenFileUrl}: ${error}`\n          );\n          reject(error);\n        });\n    } else {\n      Logger.debug('Token file url not found. Resolving to blank profile.');\n      resolve({});\n    }\n  });\n}\n","export function getName(profile: any) {\n  if (!profile) {\n    return null;\n  }\n\n  let name = null;\n  if (profile.name) {\n    name = profile.name;\n  } else if (profile.givenName || profile.familyName) {\n    name = '';\n    if (profile.givenName) {\n      name = profile.givenName;\n    }\n    if (profile.familyName) {\n      name += ` ${profile.familyName}`;\n    }\n  }\n  return name;\n}\n\n/**\n *\n * @ignore\n */\nexport function getGivenName(profile: any) {\n  if (!profile) {\n    return null;\n  }\n\n  let givenName = null;\n  if (profile.givenName) {\n    givenName = profile.givenName;\n  } else if (profile.name) {\n    const nameParts = profile.name.split(' ');\n    givenName = nameParts.slice(0, -1).join(' ');\n  }\n  return givenName;\n}\n\n/**\n *\n * @ignore\n */\nexport function getFamilyName(profile: any) {\n  if (!profile) {\n    return null;\n  }\n\n  let familyName = null;\n  if (profile.familyName) {\n    familyName = profile.familyName;\n  } else if (profile.name) {\n    const nameParts = profile.name.split(' ');\n    familyName = nameParts.pop();\n  }\n  return familyName;\n}\n\n/**\n *\n * @ignore\n */\nexport function getDescription(profile: any) {\n  if (!profile) {\n    return null;\n  }\n\n  let description = null;\n  if (profile.description) {\n    description = profile.description;\n  }\n  return description;\n}\n\n/**\n *\n * @ignore\n */\nexport function getAvatarUrl(profile: any) {\n  if (!profile) {\n    return null;\n  }\n\n  let avatarContentUrl: string | null = null;\n  if (profile.image) {\n    profile.image.map((image: any) => {\n      if (image.name === 'avatar') {\n        avatarContentUrl = image.contentUrl;\n        return avatarContentUrl;\n      } else {\n        return null;\n      }\n    });\n  }\n  return avatarContentUrl;\n}\n\n/**\n *\n * @ignore\n */\nexport function getVerifiedAccounts(profile: any, verifications?: any[]) {\n  if (!profile) {\n    return null;\n  }\n\n  const filteredAccounts: any[] = [];\n  if (profile.hasOwnProperty('account') && verifications) {\n    profile.account.map((account: any) => {\n      let accountIsValid = false;\n      let proofUrl = null;\n\n      verifications.map(verification => {\n        if (verification.hasOwnProperty('proof_url')) {\n          verification.proofUrl = verification.proof_url;\n        }\n        if (\n          verification.valid &&\n          verification.service === account.service &&\n          verification.identifier === account.identifier &&\n          verification.proofUrl\n        ) {\n          accountIsValid = true;\n          proofUrl = verification.proofUrl;\n          return true;\n        } else {\n          return false;\n        }\n      });\n\n      if (accountIsValid) {\n        account.proofUrl = proofUrl;\n        filteredAccounts.push(account);\n        return account;\n      } else {\n        return null;\n      }\n    });\n  }\n  return filteredAccounts;\n}\n\n/**\n *\n * @ignore\n */\nexport function getOrganizations(profile: any) {\n  if (!profile) {\n    return null;\n  }\n\n  const organizations: any[] = [];\n\n  if (profile.hasOwnProperty('worksFor')) {\n    return profile.worksFor;\n  }\n\n  return organizations;\n}\n\n/**\n *\n * @ignore\n */\nexport function getConnections(profile: any) {\n  if (!profile) {\n    return null;\n  }\n\n  let connections = [];\n\n  if (profile.hasOwnProperty('knows')) {\n    connections = profile.knows;\n  }\n\n  return connections;\n}\n\n/**\n *\n * @ignore\n */\nexport function getAddress(profile: any) {\n  if (!profile) {\n    return null;\n  }\n\n  let addressString = null;\n\n  if (profile.hasOwnProperty('address')) {\n    const addressParts = [];\n\n    if (profile.address.hasOwnProperty('streetAddress')) {\n      addressParts.push(profile.address.streetAddress);\n    }\n    if (profile.address.hasOwnProperty('addressLocality')) {\n      addressParts.push(profile.address.addressLocality);\n    }\n    if (profile.address.hasOwnProperty('postalCode')) {\n      addressParts.push(profile.address.postalCode);\n    }\n    if (profile.address.hasOwnProperty('addressCountry')) {\n      addressParts.push(profile.address.addressCountry);\n    }\n\n    if (addressParts.length) {\n      addressString = addressParts.join(', ');\n    }\n  }\n\n  return addressString;\n}\n\n/**\n *\n * @ignore\n */\nexport function getBirthDate(profile: any) {\n  if (!profile) {\n    return null;\n  }\n\n  const monthNames = [\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December',\n  ];\n\n  let birthDateString = null;\n\n  if (profile.hasOwnProperty('birthDate')) {\n    const date = new Date(profile.birthDate);\n    birthDateString = `${monthNames[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;\n  }\n\n  return birthDateString;\n}\n","// @ts-ignore: Could not find a declaration file for module\nimport { parseZoneFile } from 'zone-file';\n\nimport { getTokenFileUrl, Person } from '../profile';\nimport { extractProfile } from '../profileTokens';\nimport { fetchPrivate } from '@stacks/common';\n\n/**\n *\n * @param zoneFile\n * @param publicKeyOrAddress\n * @param callback\n *\n * @ignore\n */\nexport function resolveZoneFileToPerson(\n  zoneFile: any,\n  publicKeyOrAddress: string,\n  callback: (profile: any) => void\n) {\n  let zoneFileJson = null;\n  try {\n    zoneFileJson = parseZoneFile(zoneFile);\n    if (!zoneFileJson.hasOwnProperty('$origin')) {\n      zoneFileJson = null;\n      throw new Error('zone file is missing an origin');\n    }\n  } catch (e) {\n    console.error(e);\n  }\n\n  let tokenFileUrl = null;\n  if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {\n    tokenFileUrl = getTokenFileUrl(zoneFileJson);\n  } else {\n    let profile = null;\n    try {\n      profile = JSON.parse(zoneFile);\n      const person = Person.fromLegacyFormat(profile);\n      profile = person.profile();\n    } catch (error) {\n      console.warn(error);\n    }\n    callback(profile);\n    return;\n  }\n\n  if (tokenFileUrl) {\n    fetchPrivate(tokenFileUrl)\n      .then(response => response.text())\n      .then(responseText => JSON.parse(responseText))\n      .then(responseJson => {\n        const tokenRecords = responseJson;\n        const token = tokenRecords[0].token;\n        const profile = extractProfile(token, publicKeyOrAddress);\n\n        callback(profile);\n      })\n      .catch(error => {\n        console.warn(error);\n      });\n  } else {\n    console.warn('Token file url not found');\n    callback({});\n  }\n}\n"],"names":["signProfileToken","profile","privateKey","subject","issuer","signingAlgorithm","issuedAt","expiresAt","Date","nextYear","Error","publicKey","SECP256K1Client","derivePublicKey","tokenSigner","TokenSigner","payload","jti","makeUUID4","iat","toISOString","exp","claim","sign","verifyProfileToken","token","publicKeyOrAddress","decodedToken","decodeToken","hasOwnProperty","issuerPublicKey","publicKeyBuffer","Buffer","from","compressedKeyPair","ECPair","fromPublicKey","compressed","compressedAddress","ecPairToAddress","uncompressedKeyPair","uncompressedAddress","tokenVerifier","TokenVerifier","header","alg","verify","extractProfile","formatAccount","serviceName","data","proofUrl","proof","url","service","identifier","username","proofType","schemaDefinition","type","properties","optional","Profile","_profile","Object","assign","toJSON","this","toToken","validateSchema","strict","inspector","fromToken","makeZoneFile","domainName","tokenFileURL","makeProfileZoneFile","Person","_this","fromLegacyFormat","legacyProfile","profileData","name","formatted","bio","description","location","address","addressLocality","images","avatar","push","contentUrl","cover","length","image","website","accounts","bitcoin","role","twitter","facebook","github","auth","publicKeychain","pgp","fingerprint","account","getPersonFromLegacyFormat","givenName","familyName","avatarUrl","verifiedAccounts","birthDate","connections","organizations","getName","split","slice","join","getGivenName","pop","getFamilyName","getDescription","avatarContentUrl","map","getAvatarUrl","verifications","filteredAccounts","accountIsValid","verification","proof_url","valid","getVerifiedAccounts","addressString","addressParts","streetAddress","postalCode","addressCountry","getAddress","birthDateString","date","getMonth","getDate","getFullYear","getBirthDate","knows","getConnections","worksFor","origin","tokenFileUrl","includes","urlScheme","urlParts","domain","pathname","$origin","$ttl","uri","priority","weight","target","getTokenFileUrl","zoneFileJson","Array","isArray","firstUriRecord","startsWith","zoneFile","callback","parseZoneFile","e","console","error","keys","fetchPrivate","then","response","text","responseText","JSON","parse","responseJson","warn","Promise","resolve","reject","Logger","debug"],"mappings":"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"}
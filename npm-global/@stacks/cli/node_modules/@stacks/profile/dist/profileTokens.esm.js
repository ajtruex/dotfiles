import { ECPair } from 'bitcoinjs-lib';
import { SECP256K1Client, TokenSigner, decodeToken, TokenVerifier } from 'jsontokens';
import { nextYear, makeUUID4 } from '@stacks/common';
import { ecPairToAddress } from '@stacks/encryption';

function signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm, issuedAt, expiresAt) {
  if (signingAlgorithm === void 0) {
    signingAlgorithm = 'ES256K';
  }

  if (issuedAt === void 0) {
    issuedAt = new Date();
  }

  if (expiresAt === void 0) {
    expiresAt = nextYear();
  }

  if (signingAlgorithm !== 'ES256K') {
    throw new Error('Signing algorithm not supported');
  }

  var publicKey = SECP256K1Client.derivePublicKey(privateKey);

  if (!subject) {
    subject = {
      publicKey: publicKey
    };
  }

  if (!issuer) {
    issuer = {
      publicKey: publicKey
    };
  }

  var tokenSigner = new TokenSigner(signingAlgorithm, privateKey);
  var payload = {
    jti: makeUUID4(),
    iat: issuedAt.toISOString(),
    exp: expiresAt.toISOString(),
    subject: subject,
    issuer: issuer,
    claim: profile
  };
  return tokenSigner.sign(payload);
}
function wrapProfileToken(token) {
  return {
    token: token,
    decodedToken: decodeToken(token)
  };
}
function verifyProfileToken(token, publicKeyOrAddress) {
  var decodedToken = decodeToken(token);
  var payload = decodedToken.payload;

  if (typeof payload === 'string') {
    throw new Error('Unexpected token payload type of string');
  }

  if (payload.hasOwnProperty('subject') && payload.subject) {
    if (!payload.subject.hasOwnProperty('publicKey')) {
      throw new Error("Token doesn't have a subject public key");
    }
  } else {
    throw new Error("Token doesn't have a subject");
  }

  if (payload.hasOwnProperty('issuer') && payload.issuer) {
    if (!payload.issuer.hasOwnProperty('publicKey')) {
      throw new Error("Token doesn't have an issuer public key");
    }
  } else {
    throw new Error("Token doesn't have an issuer");
  }

  if (!payload.hasOwnProperty('claim')) {
    throw new Error("Token doesn't have a claim");
  }

  var issuerPublicKey = payload.issuer.publicKey;
  var publicKeyBuffer = Buffer.from(issuerPublicKey, 'hex');
  var compressedKeyPair = ECPair.fromPublicKey(publicKeyBuffer, {
    compressed: true
  });
  var compressedAddress = ecPairToAddress(compressedKeyPair);
  var uncompressedKeyPair = ECPair.fromPublicKey(publicKeyBuffer, {
    compressed: false
  });
  var uncompressedAddress = ecPairToAddress(uncompressedKeyPair);

  if (publicKeyOrAddress === issuerPublicKey) ; else if (publicKeyOrAddress === compressedAddress) ; else if (publicKeyOrAddress === uncompressedAddress) ; else {
    throw new Error('Token issuer public key does not match the verifying value');
  }

  var tokenVerifier = new TokenVerifier(decodedToken.header.alg, issuerPublicKey);

  if (!tokenVerifier) {
    throw new Error('Invalid token verifier');
  }

  var tokenVerified = tokenVerifier.verify(token);

  if (!tokenVerified) {
    throw new Error('Token verification failed');
  }

  return decodedToken;
}
function extractProfile(token, publicKeyOrAddress) {
  if (publicKeyOrAddress === void 0) {
    publicKeyOrAddress = null;
  }

  var decodedToken;

  if (publicKeyOrAddress) {
    decodedToken = verifyProfileToken(token, publicKeyOrAddress);
  } else {
    decodedToken = decodeToken(token);
  }

  var profile = {};

  if (decodedToken.hasOwnProperty('payload')) {
    var payload = decodedToken.payload;

    if (typeof payload === 'string') {
      throw new Error('Unexpected token payload type of string');
    }

    if (payload.hasOwnProperty('claim')) {
      profile = payload.claim;
    }
  }

  return profile;
}

export { extractProfile, signProfileToken, verifyProfileToken, wrapProfileToken };
//# sourceMappingURL=profileTokens.esm.js.map

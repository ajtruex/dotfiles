/// <reference types="node" />
import { ContractCallOptions, StacksTransaction } from '@stacks/transactions';
import { StacksNetwork } from '@stacks/network';
import BN from 'bn.js';
export interface PoxInfo {
    contract_id: string;
    first_burnchain_block_height: number;
    min_amount_ustx: string;
    registration_window_length: 250;
    rejection_fraction: number;
    reward_cycle_id: number;
    reward_cycle_length: number;
    rejection_votes_left_required: number;
}
export interface StackerInfo {
    stacked: boolean;
    details?: {
        amount_microstx: string;
        first_reward_cycle: number;
        lock_period: number;
        unlock_height: number;
        pox_address: {
            version: Buffer;
            hashbytes: Buffer;
        };
    };
}
export interface BlockTimeInfo {
    mainnet: {
        target_block_time: number;
    };
    testnet: {
        target_block_time: number;
    };
}
export interface CoreInfo {
    burn_block_height: number;
    stable_pox_consensus: string;
}
export interface BalanceInfo {
    balance: string;
    nonce: number;
}
export interface StackingEligibility {
    eligible: boolean;
    reason?: string;
}
export interface CanLockStxOptions {
    poxAddress: string;
    cycles: number;
}
export interface LockStxOptions {
    privateKey: string;
    cycles: number;
    poxAddress: string;
    amountMicroStx: BN;
    burnBlockHeight: number;
}
export declare class StackingClient {
    address: string;
    network: StacksNetwork;
    constructor(address: string, network: StacksNetwork);
    getCoreInfo(): Promise<CoreInfo>;
    getPoxInfo(): Promise<PoxInfo>;
    getTargetBlockTime(): Promise<number>;
    getAccountStatus(): Promise<any>;
    getAccountBalance(): Promise<BN>;
    getCycleDuration(): Promise<number>;
    getSecondsUntilNextCycle(): Promise<number>;
    isStackingEnabledNextCycle(): Promise<boolean>;
    hasMinimumStx(): Promise<boolean>;
    canStack({ poxAddress, cycles }: CanLockStxOptions): Promise<StackingEligibility>;
    stack({ amountMicroStx, poxAddress, cycles, privateKey, burnBlockHeight }: LockStxOptions): Promise<string>;
    getStackOptions({ amountMicroStx, poxAddress, cycles, contract, burnBlockHeight, }: {
        cycles: number;
        poxAddress: string;
        amountMicroStx: BN;
        contract: string;
        burnBlockHeight: number;
    }): ContractCallOptions;
    getStatus(): Promise<StackerInfo>;
    modifyLockTxFee({ tx, amountMicroStx }: {
        tx: StacksTransaction;
        amountMicroStx: BN;
    }): StacksTransaction;
}

{"version":3,"file":"verification.esm.js","sources":["../src/verification.ts"],"sourcesContent":["import { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { publicKeyToAddress } from '@stacks/encryption';\nimport { fetchPrivate, isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { fetchAppManifest } from './provider';\n\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n * @ignore\n */\nexport function doSignaturesMatchPublicKeys(token: string): boolean {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys as string[];\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n    try {\n      const tokenVerifier = new TokenVerifier('ES256k', publicKey);\n      return tokenVerifier.verify(token);\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n * @ignore\n */\nexport function doPublicKeysMatchIssuer(token: string): boolean {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys as string[];\n  const addressFromIssuer = getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = publicKeyToAddress(publicKeys[0]);\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n\n/**\n * Looks up the identity address that owns the claimed username\n * in `token` using the lookup endpoint provided in `nameLookupURL`\n * to determine if the username is owned by the identity address\n * that matches the claimed public key\n *\n * @param  {String} token  encoded and signed authentication token\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\n * `true` if the username is owned by the public key, otherwise the\n * `Promise` resolves to `false`\n * @private\n * @ignore\n */\nexport async function doPublicKeysMatchUsername(\n  token: string,\n  nameLookupURL: string\n): Promise<boolean> {\n  try {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n    if (!payload.username) {\n      return true;\n    }\n\n    if (payload.username === null) {\n      return true;\n    }\n\n    if (nameLookupURL === null) {\n      return false;\n    }\n\n    const username = payload.username;\n    const url = `${nameLookupURL.replace(/\\/$/, '')}/${username}`;\n    const response = await fetchPrivate(url);\n    const responseText = await response.text();\n    const responseJSON = JSON.parse(responseText);\n    if (responseJSON.hasOwnProperty('address')) {\n      const nameOwningAddress = responseJSON.address;\n      const addressFromIssuer = getAddressFromDID(payload.iss);\n      if (nameOwningAddress === addressFromIssuer) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  } catch (error) {\n    console.log(error);\n    console.log('Error checking `doPublicKeysMatchUsername`');\n    return false;\n  }\n}\n\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n * @ignore\n */\nexport function isIssuanceDateValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n    const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n * @ignore\n */\nexport function isExpirationDateValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n    const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nexport function isManifestUriValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.manifest_uri as string);\n}\n\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nexport function isRedirectUriValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.redirect_uri as string);\n}\n\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n * @private\n * @ignore\n */\nexport async function verifyAuthRequest(token: string): Promise<boolean> {\n  if (decodeToken(token).header.alg === 'none') {\n    throw new Error('Token must be signed in order to be verified');\n  }\n  const values = await Promise.all([\n    isExpirationDateValid(token),\n    isIssuanceDateValid(token),\n    doSignaturesMatchPublicKeys(token),\n    doPublicKeysMatchIssuer(token),\n    isManifestUriValid(token),\n    isRedirectUriValid(token),\n  ]);\n  return values.every(val => val);\n}\n\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n * @ignore\n */\nexport async function verifyAuthRequestAndLoadManifest(token: string): Promise<any> {\n  const valid = await verifyAuthRequest(token);\n  if (!valid) {\n    throw new Error('Token is an invalid auth request');\n  }\n  return fetchAppManifest(token);\n}\n\n/**\n * Verify the authentication response is valid\n * @param {String} token the authentication response token\n * @param {String} nameLookupURL the url use to verify owner of a username\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n * @ignore\n */\nexport async function verifyAuthResponse(token: string, nameLookupURL: string): Promise<boolean> {\n  const values = await Promise.all([\n    isExpirationDateValid(token),\n    isIssuanceDateValid(token),\n    doSignaturesMatchPublicKeys(token),\n    doPublicKeysMatchIssuer(token),\n    doPublicKeysMatchUsername(token, nameLookupURL),\n  ]);\n  return values.every(val => val);\n}\n"],"names":["doSignaturesMatchPublicKeys","token","payload","decodeToken","Error","publicKeys","public_keys","length","publicKey","tokenVerifier","TokenVerifier","verify","e","doPublicKeysMatchIssuer","addressFromIssuer","getAddressFromDID","iss","addressFromPublicKeys","publicKeyToAddress","doPublicKeysMatchUsername","nameLookupURL","username","url","replace","fetchPrivate","response","text","responseText","responseJSON","JSON","parse","hasOwnProperty","nameOwningAddress","address","console","log","isIssuanceDateValid","iat","issuedAt","Date","getTime","isExpirationDateValid","exp","expiresAt","isManifestUriValid","isSameOriginAbsoluteUrl","domain_name","manifest_uri","isRedirectUriValid","redirect_uri","verifyAuthRequest","header","alg","Promise","all","values","every","val","verifyAuthRequestAndLoadManifest","valid","fetchAppManifest","verifyAuthResponse"],"mappings":"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"}
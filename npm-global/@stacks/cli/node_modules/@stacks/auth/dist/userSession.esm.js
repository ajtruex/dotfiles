import { DEFAULT_PROFILE, NAME_LOOKUP_PATH } from './constants.esm.js';
import { nextHour, InvalidStateError, getGlobalObject, Logger, MissingParameterError, isLaterVersion, fetchPrivate, LoginFailedError, BLOCKSTACK_DEFAULT_GAIA_HUB_URL } from '@stacks/common';
import { AppConfig } from './appConfig.esm.js';
import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';
import runtime_1 from './node_modules/regenerator-runtime/runtime.esm.js';
import { decodeToken } from 'jsontokens';
import { getAddressFromDID } from './dids.esm.js';
import { encryptContent, decryptContent, hexStringToECPair } from '@stacks/encryption';
import { makeAuthRequest, generateTransitKey, decryptPrivateKey } from './messages.esm.js';
import { parse } from 'query-string';
import { verifyAuthResponse } from './verification.esm.js';
import { LocalStorageStore, InstanceDataStore } from './sessionStore.esm.js';
import { extractProfile } from '@stacks/profile';
import { StacksMainnet } from '@stacks/network';
import { protocolEchoReplyDetection } from './protocolEchoDetection.esm.js';

var UserSession = /*#__PURE__*/function () {
  function UserSession(options) {
    var runningInBrowser = true;

    if (typeof window === 'undefined' && typeof self === 'undefined') {
      runningInBrowser = false;
    }

    if (options && options.appConfig) {
      this.appConfig = options.appConfig;
    } else if (runningInBrowser) {
      this.appConfig = new AppConfig();
    } else {
      throw new MissingParameterError('You need to specify options.appConfig');
    }

    if (options && options.sessionStore) {
      this.store = options.sessionStore;
    } else if (runningInBrowser) {
      if (options) {
        this.store = new LocalStorageStore(options.sessionOptions);
      } else {
        this.store = new LocalStorageStore();
      }
    } else if (options) {
      this.store = new InstanceDataStore(options.sessionOptions);
    } else {
      this.store = new InstanceDataStore();
    }
  }

  var _proto = UserSession.prototype;

  _proto.makeAuthRequest = function makeAuthRequest$1(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams) {
    if (expiresAt === void 0) {
      expiresAt = nextHour().getTime();
    }

    if (extraParams === void 0) {
      extraParams = {};
    }

    var appConfig = this.appConfig;

    if (!appConfig) {
      throw new InvalidStateError('Missing AppConfig');
    }

    transitKey = transitKey || this.generateAndStoreTransitKey();
    redirectURI = redirectURI || appConfig.redirectURI();
    manifestURI = manifestURI || appConfig.manifestURI();
    scopes = scopes || appConfig.scopes;
    appDomain = appDomain || appConfig.appDomain;
    return makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);
  };

  _proto.generateAndStoreTransitKey = function generateAndStoreTransitKey() {
    var sessionData = this.store.getSessionData();
    var transitKey = generateTransitKey();
    sessionData.transitKey = transitKey;
    this.store.setSessionData(sessionData);
    return transitKey;
  };

  _proto.getAuthResponseToken = function getAuthResponseToken() {
    var _getGlobalObject;

    var search = (_getGlobalObject = getGlobalObject('location', {
      throwIfUnavailable: true,
      usageDesc: 'getAuthResponseToken'
    })) == null ? void 0 : _getGlobalObject.search;

    if (search) {
      var queryDict = parse(search);
      return queryDict.authResponse ? queryDict.authResponse : '';
    }

    return '';
  };

  _proto.isSignInPending = function isSignInPending() {
    try {
      var isProtocolEcho = protocolEchoReplyDetection();

      if (isProtocolEcho) {
        Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');
        return true;
      }
    } catch (error) {
      Logger.error("Error checking for protocol echo reply isSignInPending: " + error);
    }

    return !!this.getAuthResponseToken();
  };

  _proto.isUserSignedIn = function isUserSignedIn() {
    return !!this.store.getSessionData().userData;
  };

  _proto.handlePendingSignIn = /*#__PURE__*/function () {
    var _handlePendingSignIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(authResponseToken) {
      var sessionData, transitKey, coreNode, network, tokenPayload, nameLookupURL, isValid, appPrivateKey, coreSessionToken, hubUrl, gaiaAssociationToken, userData, profileURL, response, responseText, wrappedProfile;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (authResponseToken === void 0) {
                authResponseToken = /*#__PURE__*/this.getAuthResponseToken();
              }

              sessionData = this.store.getSessionData();

              if (!sessionData.userData) {
                _context.next = 4;
                break;
              }

              throw new LoginFailedError('Existing user session found.');

            case 4:
              transitKey = this.store.getSessionData().transitKey;
              coreNode = this.appConfig && this.appConfig.coreNode;

              if (!coreNode) {
                network = new StacksMainnet();
                coreNode = network.coreApiUrl;
              }

              tokenPayload = decodeToken(authResponseToken).payload;

              if (!(typeof tokenPayload === 'string')) {
                _context.next = 10;
                break;
              }

              throw new Error('Unexpected token payload type of string');

            case 10:
              nameLookupURL = "" + coreNode + NAME_LOOKUP_PATH;
              _context.next = 13;
              return verifyAuthResponse(authResponseToken, nameLookupURL);

            case 13:
              isValid = _context.sent;

              if (isValid) {
                _context.next = 16;
                break;
              }

              throw new LoginFailedError('Invalid authentication response.');

            case 16:
              appPrivateKey = tokenPayload.private_key;
              coreSessionToken = tokenPayload.core_token;

              if (!isLaterVersion(tokenPayload.version, '1.1.0')) {
                _context.next = 50;
                break;
              }

              if (!(transitKey !== undefined && transitKey != null)) {
                _context.next = 49;
                break;
              }

              if (!(tokenPayload.private_key !== undefined && tokenPayload.private_key !== null)) {
                _context.next = 37;
                break;
              }

              _context.prev = 21;
              _context.next = 24;
              return decryptPrivateKey(transitKey, tokenPayload.private_key);

            case 24:
              appPrivateKey = _context.sent;
              _context.next = 37;
              break;

            case 27:
              _context.prev = 27;
              _context.t0 = _context["catch"](21);
              Logger.warn('Failed decryption of appPrivateKey, will try to use as given');
              _context.prev = 30;
              hexStringToECPair(tokenPayload.private_key);
              _context.next = 37;
              break;

            case 34:
              _context.prev = 34;
              _context.t1 = _context["catch"](30);
              throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');

            case 37:
              if (!(coreSessionToken !== undefined && coreSessionToken !== null)) {
                _context.next = 47;
                break;
              }

              _context.prev = 38;
              _context.next = 41;
              return decryptPrivateKey(transitKey, coreSessionToken);

            case 41:
              coreSessionToken = _context.sent;
              _context.next = 47;
              break;

            case 44:
              _context.prev = 44;
              _context.t2 = _context["catch"](38);
              Logger.info('Failed decryption of coreSessionToken, will try to use as given');

            case 47:
              _context.next = 50;
              break;

            case 49:
              throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');

            case 50:
              hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;

              if (isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {
                hubUrl = tokenPayload.hubUrl;
              }

              if (isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {
                gaiaAssociationToken = tokenPayload.associationToken;
              }

              userData = {
                username: tokenPayload.username,
                profile: tokenPayload.profile,
                email: tokenPayload.email,
                decentralizedID: tokenPayload.iss,
                identityAddress: getAddressFromDID(tokenPayload.iss),
                appPrivateKey: appPrivateKey,
                coreSessionToken: coreSessionToken,
                authResponseToken: authResponseToken,
                hubUrl: hubUrl,
                coreNode: tokenPayload.blockstackAPIUrl,
                gaiaAssociationToken: gaiaAssociationToken
              };
              profileURL = tokenPayload.profile_url;

              if (!(!userData.profile && profileURL)) {
                _context.next = 70;
                break;
              }

              _context.next = 58;
              return fetchPrivate(profileURL);

            case 58:
              response = _context.sent;

              if (response.ok) {
                _context.next = 63;
                break;
              }

              userData.profile = Object.assign({}, DEFAULT_PROFILE);
              _context.next = 68;
              break;

            case 63:
              _context.next = 65;
              return response.text();

            case 65:
              responseText = _context.sent;
              wrappedProfile = JSON.parse(responseText);
              userData.profile = extractProfile(wrappedProfile[0].token);

            case 68:
              _context.next = 71;
              break;

            case 70:
              userData.profile = tokenPayload.profile;

            case 71:
              sessionData.userData = userData;
              this.store.setSessionData(sessionData);
              return _context.abrupt("return", userData);

            case 74:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[21, 27], [30, 34], [38, 44]]);
    }));

    function handlePendingSignIn(_x) {
      return _handlePendingSignIn.apply(this, arguments);
    }

    return handlePendingSignIn;
  }();

  _proto.loadUserData = function loadUserData() {
    var userData = this.store.getSessionData().userData;

    if (!userData) {
      throw new InvalidStateError('No user data found. Did the user sign in?');
    }

    return userData;
  };

  _proto.encryptContent = function encryptContent$1(content, options) {
    var opts = Object.assign({}, options);

    if (!opts.privateKey) {
      opts.privateKey = this.loadUserData().appPrivateKey;
    }

    return encryptContent(content, opts);
  };

  _proto.decryptContent = function decryptContent$1(content, options) {
    var opts = Object.assign({}, options);

    if (!opts.privateKey) {
      opts.privateKey = this.loadUserData().appPrivateKey;
    }

    return decryptContent(content, opts);
  };

  _proto.signUserOut = function signUserOut(redirectURL) {
    this.store.deleteSessionData();

    if (redirectURL) {
      if (typeof location !== 'undefined' && location.href) {
        location.href = redirectURL;
      }
    }
  };

  return UserSession;
}();

export { UserSession };
//# sourceMappingURL=userSession.esm.js.map

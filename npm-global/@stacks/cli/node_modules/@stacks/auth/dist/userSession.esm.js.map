{"version":3,"file":"userSession.esm.js","sources":["../src/userSession.ts"],"sourcesContent":["import { AppConfig } from './appConfig';\nimport { SessionOptions } from './sessionData';\nimport { InstanceDataStore, LocalStorageStore, SessionDataStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport {\n  decryptContent,\n  encryptContent,\n  EncryptContentOptions,\n  hexStringToECPair,\n} from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport {\n  BLOCKSTACK_DEFAULT_GAIA_HUB_URL,\n  fetchPrivate,\n  getGlobalObject,\n  InvalidStateError,\n  isLaterVersion,\n  Logger,\n  LoginFailedError,\n  MissingParameterError,\n  nextHour,\n} from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { AuthScope, DEFAULT_PROFILE, NAME_LOOKUP_PATH } from './constants';\nimport * as queryString from 'query-string';\nimport { UserData } from './userData';\nimport { StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\n\n/**\n *\n * Represents an instance of a signed in user for a particular app.\n *\n * A signed in user has access to two major pieces of information\n * about the user, the user's private key for that app and the location\n * of the user's gaia storage bucket for the app.\n *\n * A user can be signed in either directly through the interactive\n * sign in process or by directly providing the app private key.\n *\n\n *\n */\nexport class UserSession {\n  appConfig: AppConfig;\n\n  store: SessionDataStore;\n\n  /**\n   * Creates a UserSession object\n   *\n   * @param options\n   */\n  constructor(options?: {\n    appConfig?: AppConfig;\n    sessionStore?: SessionDataStore;\n    sessionOptions?: SessionOptions;\n  }) {\n    let runningInBrowser = true;\n\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      // Logger.debug('UserSession: not running in browser')\n      runningInBrowser = false;\n    }\n\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n\n  /**\n   * Generates an authentication request that can be sent to the Blockstack\n   * browser for the user to approve sign in. This authentication request can\n   * then be used for sign in by passing it to the [[redirectToSignInWithAuthRequest]]\n   * method.\n   *\n   * *Note*: This method should only be used if you want to use a customized authentication\n   * flow. Typically, you'd use [[redirectToSignIn]] which is the default sign in method.\n   *\n   * @param transitKey A HEX encoded transit private key.\n   * @param redirectURI Location to redirect the user to after sign in approval.\n   * @param manifestURI Location of this app's manifest file.\n   * @param scopes The permissions this app is requesting. The default is `store_write`.\n   * @param appDomain The origin of the app.\n   * @param expiresAt The time at which this request is no longer valid.\n   * @param extraParams Any extra parameters to pass to the authenticator. Use this to\n   * pass options that aren't part of the Blockstack authentication specification,\n   * but might be supported by special authenticators.\n   *\n   * @returns {String} the authentication request\n   */\n  makeAuthRequest(\n    transitKey?: string,\n    redirectURI?: string,\n    manifestURI?: string,\n    scopes?: (AuthScope | string)[],\n    appDomain?: string,\n    expiresAt: number = nextHour().getTime(),\n    extraParams: any = {}\n  ): string {\n    const appConfig = this.appConfig;\n    if (!appConfig) {\n      throw new InvalidStateError('Missing AppConfig');\n    }\n    transitKey = transitKey || this.generateAndStoreTransitKey();\n    redirectURI = redirectURI || appConfig.redirectURI();\n    manifestURI = manifestURI || appConfig.manifestURI();\n    scopes = scopes || appConfig.scopes;\n    appDomain = appDomain || appConfig.appDomain;\n    return authMessages.makeAuthRequest(\n      transitKey,\n      redirectURI,\n      manifestURI,\n      scopes,\n      appDomain,\n      expiresAt,\n      extraParams\n    );\n  }\n\n  /**\n   * Generates a ECDSA keypair to\n   * use as the ephemeral app transit private key\n   * and store in the session.\n   *\n   * @returns {String} the hex encoded private key\n   *\n   */\n  generateAndStoreTransitKey(): string {\n    const sessionData = this.store.getSessionData();\n    const transitKey = authMessages.generateTransitKey();\n    sessionData.transitKey = transitKey;\n    this.store.setSessionData(sessionData);\n    return transitKey;\n  }\n\n  /**\n   * Retrieve the authentication token from the URL query\n   * @return {String} the authentication token if it exists otherwise `null`\n   */\n  getAuthResponseToken(): string {\n    const search = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'getAuthResponseToken',\n    })?.search;\n    if (search) {\n      const queryDict = queryString.parse(search);\n      return queryDict.authResponse ? (queryDict.authResponse as string) : '';\n    }\n    return '';\n  }\n\n  /**\n   * Check if there is a authentication request that hasn't been handled.\n   *\n   * Also checks for a protocol echo reply (which if detected then the page\n   * will be automatically redirected after this call).\n   *\n   * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n   */\n  isSignInPending() {\n    try {\n      const isProtocolEcho = protocolEchoReplyDetection();\n      if (isProtocolEcho) {\n        Logger.info(\n          'protocolEchoReply detected from isSignInPending call, the page is about to redirect.'\n        );\n        return true;\n      }\n    } catch (error) {\n      Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n\n    return !!this.getAuthResponseToken();\n  }\n\n  /**\n   * Check if a user is currently signed in.\n   *\n   * @returns {Boolean} `true` if the user is signed in, `false` if not.\n   */\n  isUserSignedIn() {\n    return !!this.store.getSessionData().userData;\n  }\n\n  /**\n   * Try to process any pending sign in request by returning a `Promise` that resolves\n   * to the user data object if the sign in succeeds.\n   *\n   * @param {String} authResponseToken - the signed authentication response token\n   * @returns {Promise} that resolves to the user data object if successful and rejects\n   * if handling the sign in request fails or there was no pending sign in request.\n   */\n  async handlePendingSignIn(\n    authResponseToken: string = this.getAuthResponseToken()\n  ): Promise<UserData> {\n    const sessionData = this.store.getSessionData();\n\n    if (sessionData.userData) {\n      throw new LoginFailedError('Existing user session found.');\n    }\n\n    const transitKey = this.store.getSessionData().transitKey;\n\n    // let nameLookupURL;\n    let coreNode = this.appConfig && this.appConfig.coreNode;\n    if (!coreNode) {\n      const network = new StacksMainnet();\n      coreNode = network.coreApiUrl;\n    }\n\n    const tokenPayload = decodeToken(authResponseToken).payload;\n\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    // Section below is removed since the config was never persisted and therefore useless\n\n    // if (isLaterVersion(tokenPayload.version as string, '1.3.0')\n    //    && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {\n    //   // override globally\n    //   Logger.info(`Overriding ${config.network.blockstackAPIUrl} `\n    //     + `with ${tokenPayload.blockstackAPIUrl}`)\n    //   // TODO: this config is never saved so the user node preference\n    //   // is not respected in later sessions..\n    //   config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl as string\n    //   coreNode = tokenPayload.blockstackAPIUrl as string\n    // }\n\n    const nameLookupURL = `${coreNode}${NAME_LOOKUP_PATH}`;\n\n    const isValid = await verifyAuthResponse(authResponseToken, nameLookupURL);\n    if (!isValid) {\n      throw new LoginFailedError('Invalid authentication response.');\n    }\n\n    // TODO: real version handling\n    let appPrivateKey: string = tokenPayload.private_key as string;\n    let coreSessionToken: string = tokenPayload.core_token as string;\n    if (isLaterVersion(tokenPayload.version as string, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            appPrivateKey = (await authMessages.decryptPrivateKey(\n              transitKey,\n              tokenPayload.private_key as string\n            )) as string;\n          } catch (e) {\n            Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n            try {\n              hexStringToECPair(tokenPayload.private_key as string);\n            } catch (ecPairError) {\n              throw new LoginFailedError(\n                'Failed decrypting appPrivateKey. Usually means' +\n                  ' that the transit key has changed during login.'\n              );\n            }\n          }\n        }\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            coreSessionToken = (await authMessages.decryptPrivateKey(\n              transitKey,\n              coreSessionToken\n            )) as string;\n          } catch (e) {\n            Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new LoginFailedError(\n          'Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.'\n        );\n      }\n    }\n    let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken: string;\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.2.0') &&\n      tokenPayload.hubUrl !== null &&\n      tokenPayload.hubUrl !== undefined\n    ) {\n      hubUrl = tokenPayload.hubUrl as string;\n    }\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.3.0') &&\n      tokenPayload.associationToken !== null &&\n      tokenPayload.associationToken !== undefined\n    ) {\n      gaiaAssociationToken = tokenPayload.associationToken as string;\n    }\n\n    const userData: UserData = {\n      username: tokenPayload.username as string,\n      profile: tokenPayload.profile,\n      email: tokenPayload.email as string,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      coreNode: tokenPayload.blockstackAPIUrl as string,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // @ts-ignore\n      gaiaAssociationToken,\n    };\n    const profileURL = tokenPayload.profile_url as string;\n    if (!userData.profile && profileURL) {\n      const response = await fetchPrivate(profileURL);\n      if (!response.ok) {\n        // return blank profile if we fail to fetch\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = await response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        userData.profile = extractProfile(wrappedProfile[0].token);\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n\n    sessionData.userData = userData;\n    this.store.setSessionData(sessionData);\n\n    return userData;\n  }\n\n  /**\n   * Retrieves the user data object. The user's profile is stored in the key [[Profile]].\n   *\n   * @returns {Object} User data object.\n   */\n  loadUserData() {\n    const userData = this.store.getSessionData().userData;\n    if (!userData) {\n      throw new InvalidStateError('No user data found. Did the user sign in?');\n    }\n    return userData;\n  }\n\n  /**\n   * Encrypts the data provided with the app public key.\n   * @param {String|Buffer} content  the data to encrypt\n   * @param options\n   * @param {String} options.publicKey the hex string of the ECDSA public\n   * key to use for encryption. If not provided, will use user's appPrivateKey.\n   *\n   * @returns {String} Stringified ciphertext object\n   */\n  encryptContent(content: string | Buffer, options?: EncryptContentOptions): Promise<string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return encryptContent(content, opts);\n  }\n\n  /**\n   * Decrypts data encrypted with `encryptContent` with the\n   * transit private key.\n   * @param {String|Buffer} content - encrypted content.\n   * @param options\n   * @param {String} options.privateKey - The hex string of the ECDSA private\n   * key to use for decryption. If not provided, will use user's appPrivateKey.\n   * @returns {String|Buffer} decrypted content.\n   */\n  decryptContent(content: string, options?: { privateKey?: string }): Promise<Buffer | string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return decryptContent(content, opts);\n  }\n\n  /**\n   * Sign the user out and optionally redirect to given location.\n   * @param  redirectURL\n   * Location to redirect user to after sign out.\n   * Only used in environments with `window` available\n   */\n\n  signUserOut(\n    redirectURL?: string\n    // TODO: this is not used?\n    // caller?: UserSession\n  ) {\n    this.store.deleteSessionData();\n    if (redirectURL) {\n      if (typeof location !== 'undefined' && location.href) {\n        location.href = redirectURL;\n      }\n      // TODO: Invalid left-hand side in assignment expression\n      // // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // // @ts-ignore\n      // getGlobalObject('location', {\n      //   throwIfUnavailable: true,\n      //   usageDesc: 'signUserOut',\n      // })?.href = redirectURL;\n    }\n  }\n}\n"],"names":["UserSession","options","runningInBrowser","window","self","appConfig","AppConfig","MissingParameterError","sessionStore","store","LocalStorageStore","sessionOptions","InstanceDataStore","makeAuthRequest","transitKey","redirectURI","manifestURI","scopes","appDomain","expiresAt","extraParams","nextHour","getTime","InvalidStateError","generateAndStoreTransitKey","authMessages","sessionData","getSessionData","setSessionData","getAuthResponseToken","search","getGlobalObject","throwIfUnavailable","usageDesc","queryDict","queryString","authResponse","isSignInPending","isProtocolEcho","protocolEchoReplyDetection","Logger","info","error","isUserSignedIn","userData","handlePendingSignIn","authResponseToken","LoginFailedError","coreNode","network","StacksMainnet","coreApiUrl","tokenPayload","decodeToken","payload","Error","nameLookupURL","NAME_LOOKUP_PATH","verifyAuthResponse","isValid","appPrivateKey","private_key","coreSessionToken","core_token","isLaterVersion","version","undefined","warn","hexStringToECPair","hubUrl","BLOCKSTACK_DEFAULT_GAIA_HUB_URL","associationToken","gaiaAssociationToken","username","profile","email","decentralizedID","iss","identityAddress","getAddressFromDID","blockstackAPIUrl","profileURL","profile_url","fetchPrivate","response","ok","Object","assign","DEFAULT_PROFILE","text","responseText","wrappedProfile","JSON","parse","extractProfile","token","loadUserData","encryptContent","content","opts","privateKey","decryptContent","signUserOut","redirectURL","deleteSessionData","location","href"],"mappings":"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"}
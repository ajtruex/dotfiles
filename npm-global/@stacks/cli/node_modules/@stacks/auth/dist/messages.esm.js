import { DEFAULT_SCOPE } from './constants.esm.js';
import { nextMonth, makeUUID4, getGlobalObject } from '@stacks/common';
import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';
import runtime_1 from './node_modules/regenerator-runtime/runtime.esm.js';
import 'cross-fetch/polyfill';
import { SECP256K1Client, TokenSigner } from 'jsontokens';
import { makeDIDFromAddress } from './dids.esm.js';
import { publicKeyToAddress, makeECPrivateKey, encryptECIES, decryptECIES } from '@stacks/encryption';

var VERSION = '1.3.1';
function generateTransitKey() {
  var transitKey = makeECPrivateKey();
  return transitKey;
}
function makeAuthRequest(transitPrivateKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams) {
  if (scopes === void 0) {
    scopes = DEFAULT_SCOPE.slice();
  }

  if (expiresAt === void 0) {
    expiresAt = nextMonth().getTime();
  }

  if (extraParams === void 0) {
    extraParams = {};
  }

  var getWindowOrigin = function getWindowOrigin(paramName) {
    var location = getGlobalObject('location', {
      throwIfUnavailable: true,
      usageDesc: "makeAuthRequest([" + paramName + "=undefined])"
    });
    return location == null ? void 0 : location.origin;
  };

  if (!redirectURI) {
    redirectURI = getWindowOrigin('redirectURI') + "/";
  }

  if (!manifestURI) {
    manifestURI = getWindowOrigin('manifestURI') + "/manifest.json";
  }

  if (!appDomain) {
    appDomain = getWindowOrigin('appDomain');
  }

  var payload = Object.assign({}, extraParams, {
    jti: makeUUID4(),
    iat: Math.floor(new Date().getTime() / 1000),
    exp: Math.floor(expiresAt / 1000),
    iss: null,
    public_keys: [],
    domain_name: appDomain,
    manifest_uri: manifestURI,
    redirect_uri: redirectURI,
    version: VERSION,
    do_not_include_profile: true,
    supports_hub_url: true,
    scopes: scopes
  });
  var publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);
  payload.public_keys = [publicKey];
  var address = publicKeyToAddress(publicKey);
  payload.iss = makeDIDFromAddress(address);
  var tokenSigner = new TokenSigner('ES256k', transitPrivateKey);
  var token = tokenSigner.sign(payload);
  return token;
}
function encryptPrivateKey(_x, _x2) {
  return _encryptPrivateKey.apply(this, arguments);
}

function _encryptPrivateKey() {
  _encryptPrivateKey = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(publicKey, privateKey) {
    var encryptedObj, encryptedJSON;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return encryptECIES(publicKey, Buffer.from(privateKey), true);

          case 2:
            encryptedObj = _context.sent;
            encryptedJSON = JSON.stringify(encryptedObj);
            return _context.abrupt("return", Buffer.from(encryptedJSON).toString('hex'));

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _encryptPrivateKey.apply(this, arguments);
}

function decryptPrivateKey(_x3, _x4) {
  return _decryptPrivateKey.apply(this, arguments);
}

function _decryptPrivateKey() {
  _decryptPrivateKey = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(privateKey, hexedEncrypted) {
    var unhexedString, encryptedObj, decrypted;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();
            encryptedObj = JSON.parse(unhexedString);
            _context2.next = 4;
            return decryptECIES(privateKey, encryptedObj);

          case 4:
            decrypted = _context2.sent;

            if (!(typeof decrypted !== 'string')) {
              _context2.next = 9;
              break;
            }

            throw new Error('Unable to correctly decrypt private key');

          case 9:
            return _context2.abrupt("return", decrypted);

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _decryptPrivateKey.apply(this, arguments);
}

function makeAuthResponse(_x5, _x6, _x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14, _x15) {
  return _makeAuthResponse.apply(this, arguments);
}

function _makeAuthResponse() {
  _makeAuthResponse = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(privateKey, profile, username, metadata, coreToken, appPrivateKey, expiresAt, transitPublicKey, hubUrl, blockstackAPIUrl, associationToken) {
    var publicKey, address, privateKeyPayload, coreTokenPayload, additionalProperties, payload, tokenSigner;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (profile === void 0) {
              profile = {};
            }

            if (username === void 0) {
              username = null;
            }

            if (coreToken === void 0) {
              coreToken = null;
            }

            if (appPrivateKey === void 0) {
              appPrivateKey = null;
            }

            if (expiresAt === void 0) {
              expiresAt = nextMonth().getTime();
            }

            if (transitPublicKey === void 0) {
              transitPublicKey = null;
            }

            if (hubUrl === void 0) {
              hubUrl = null;
            }

            if (blockstackAPIUrl === void 0) {
              blockstackAPIUrl = null;
            }

            if (associationToken === void 0) {
              associationToken = null;
            }

            publicKey = SECP256K1Client.derivePublicKey(privateKey);
            address = publicKeyToAddress(publicKey);
            privateKeyPayload = appPrivateKey;
            coreTokenPayload = coreToken;
            additionalProperties = {};

            if (!(appPrivateKey !== undefined && appPrivateKey !== null)) {
              _context3.next = 26;
              break;
            }

            if (!(transitPublicKey !== undefined && transitPublicKey !== null)) {
              _context3.next = 23;
              break;
            }

            _context3.next = 18;
            return encryptPrivateKey(transitPublicKey, appPrivateKey);

          case 18:
            privateKeyPayload = _context3.sent;

            if (!(coreToken !== undefined && coreToken !== null)) {
              _context3.next = 23;
              break;
            }

            _context3.next = 22;
            return encryptPrivateKey(transitPublicKey, coreToken);

          case 22:
            coreTokenPayload = _context3.sent;

          case 23:
            additionalProperties = {
              email: (metadata == null ? void 0 : metadata.email) ? metadata.email : null,
              profile_url: (metadata == null ? void 0 : metadata.profileUrl) ? metadata.profileUrl : null,
              hubUrl: hubUrl,
              blockstackAPIUrl: blockstackAPIUrl,
              associationToken: associationToken,
              version: VERSION
            };
            _context3.next = 26;
            break;

          case 26:
            payload = Object.assign({}, {
              jti: makeUUID4(),
              iat: Math.floor(new Date().getTime() / 1000),
              exp: Math.floor(expiresAt / 1000),
              iss: makeDIDFromAddress(address),
              private_key: privateKeyPayload,
              public_keys: [publicKey],
              profile: profile,
              username: username,
              core_token: coreTokenPayload
            }, additionalProperties);
            tokenSigner = new TokenSigner('ES256k', privateKey);
            return _context3.abrupt("return", tokenSigner.sign(payload));

          case 29:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _makeAuthResponse.apply(this, arguments);
}

export { decryptPrivateKey, encryptPrivateKey, generateTransitKey, makeAuthRequest, makeAuthResponse };
//# sourceMappingURL=messages.esm.js.map

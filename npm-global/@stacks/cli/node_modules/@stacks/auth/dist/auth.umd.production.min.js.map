{"version":3,"file":"auth.umd.production.min.js","sources":["../src/constants.ts","../src/appConfig.ts","../../../node_modules/regenerator-runtime/runtime.js","../src/dids.ts","../src/messages.ts","../src/provider.ts","../src/verification.ts","../src/sessionData.ts","../src/sessionStore.ts","../src/userSession.ts","../src/protocolEchoDetection.ts","../src/profile.ts"],"sourcesContent":["/**\n * @ignore\n */\nexport const BLOCKSTACK_HANDLER = 'blockstack';\n/**\n * @ignore\n */\nexport const BLOCKSTACK_STORAGE_LABEL = 'blockstack';\n/**\n * This constant is used in the [[redirectToSignInWithAuthRequest]]\n */\nexport const DEFAULT_BLOCKSTACK_HOST = 'https://browser.blockstack.org/auth';\n\n/**\n * Default user profile object\n */\nexport const DEFAULT_PROFILE = {\n  '@type': 'Person',\n  '@context': 'http://schema.org',\n};\n\n/**\n * Non-exhaustive list of common permission scopes.\n */\nexport const enum AuthScope {\n  /**\n   * Read and write data to the user's Gaia hub in an app-specific storage bucket.\n   * This is the default scope.\n   */\n  store_write = 'store_write',\n  /**\n   * Publish data so that other users of the app can discover and interact with the user.\n   * The user's files stored on Gaia hub are made visible to others via the `apps` property in the\n   * userâ€™s `profile.json` file.\n   */\n  publish_data = 'publish_data',\n  /**\n   * Request the user's email if available.\n   */\n  email = 'email',\n}\n\n/**\n * @ignore\n */\nexport const DEFAULT_SCOPE = [AuthScope.store_write];\n\n/**\n * @ignore\n */\nexport const BLOCKSTACK_APP_PRIVATE_KEY_LABEL = 'blockstack-transit-private-key';\n\n/**\n * @ignore\n */\nexport const DEFAULT_CORE_NODE = 'https://core.blockstack.org';\n/**\n * @ignore\n */\nexport const NAME_LOOKUP_PATH = '/v1/names';\n/**\n * @ignore\n */\nexport const LOCALSTORAGE_SESSION_KEY = 'blockstack-session';\n","import { DEFAULT_SCOPE, DEFAULT_BLOCKSTACK_HOST, AuthScope } from './constants';\nimport { getGlobalObject } from '@stacks/common';\n\n/**\n * Configuration data for the current app.\n *\n * On browser platforms, creating an instance of this\n * class without any arguments will use\n * `window.location.origin` as the app domain.\n * On non-browser platforms, you need to\n * specify an app domain as the second argument.\n *\n */\nexport class AppConfig {\n  /**\n   * Blockstack apps are uniquely identified by their app domain.\n   *\n   */\n  appDomain?: string;\n\n  /**\n   * An array of string representing permissions requested by the app.\n   *\n   */\n  scopes: (AuthScope | string)[];\n\n  /**\n   * Path on app domain to redirect users to after authentication. The\n   * authentication response token will be postpended in a query.\n   *\n   */\n  redirectPath: string;\n\n  /**\n   * Path relative to app domain of app's manifest file.\n   *\n   * This file needs to have CORS headers set so that it can be fetched\n   * from any origin. Typically this means return the header `Access-Control-Allow-Origin: *`.\n   *\n   */\n  manifestPath: string;\n\n  /**\n   * The URL of Blockstack core node to use for this app. If this is\n   * `null`, the core node specified by the user or default core node\n   * will be used.\n   *\n   */\n  coreNode?: string;\n\n  /**\n   * The URL of a web-based Blockstack Authenticator to use in the event\n   * the user doesn't have Blockstack installed on their machine. If this\n   * is not specified, the current default in this library will be used.\n   *\n   */\n  authenticatorURL?: string;\n\n  /**\n   * @param {Array<string>} scopes - permissions this app is requesting\n   * @param {string} appDomain - the app domain\n   * @param {string} redirectPath - path on app domain to redirect users to after authentication\n   * @param {string} manifestPath - path relative to app domain of app's manifest file\n   * @param {string | undefined} coreNode - override the default or user selected core node\n   * @param {string} authenticatorURL - the web-based fall back authenticator\n   * ([[DEFAULT_BLOCKSTACK_HOST]])\n   */\n  constructor(\n    scopes: string[] = DEFAULT_SCOPE.slice(),\n    appDomain: string | undefined = getGlobalObject('location', { returnEmptyObject: true })\n      ?.origin,\n    redirectPath = '',\n    manifestPath = '/manifest.json',\n    coreNode: string | undefined = undefined,\n    authenticatorURL: string = DEFAULT_BLOCKSTACK_HOST\n  ) {\n    this.appDomain = appDomain;\n    this.scopes = scopes;\n    this.redirectPath = redirectPath;\n    this.manifestPath = manifestPath;\n    this.coreNode = coreNode;\n    this.authenticatorURL = authenticatorURL;\n  }\n\n  /**\n   * The location to which the authenticator should\n   * redirect the user.\n   * @returns {string} - URI\n   */\n  redirectURI(): string {\n    return `${this.appDomain}${this.redirectPath}`;\n  }\n\n  /**\n   * The location of the app's manifest file.\n   * @returns {string} - URI\n   */\n  manifestURI(): string {\n    return `${this.appDomain}${this.manifestPath}`;\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import { InvalidDIDError } from '@stacks/common';\n\n/**\n * @ignore\n */\nexport function makeDIDFromAddress(address: string) {\n  return `did:btc-addr:${address}`;\n}\n\n/**\n * @ignore\n */\nexport function makeDIDFromPublicKey(publicKey: string) {\n  return `did:ecdsa-pub:${publicKey}`;\n}\n\n/**\n * @ignore\n */\nexport function getDIDType(decentralizedID: string) {\n  const didParts = decentralizedID.split(':');\n\n  if (didParts.length !== 3) {\n    throw new InvalidDIDError('Decentralized IDs must have 3 parts');\n  }\n\n  if (didParts[0].toLowerCase() !== 'did') {\n    throw new InvalidDIDError('Decentralized IDs must start with \"did\"');\n  }\n\n  return didParts[1].toLowerCase();\n}\n\n/**\n * @ignore\n */\nexport function getAddressFromDID(decentralizedID?: string): string | undefined {\n  if (decentralizedID) {\n    const didType = getDIDType(decentralizedID);\n    if (didType === 'btc-addr') {\n      return decentralizedID.split(':')[2];\n    } else {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\n/*\nexport function getPublicKeyOrAddressFromDID(decentralizedID) {\n  const didParts = decentralizedID.split(':')\n\n  if (didParts.length !== 3) {\n    throw new InvalidDIDError('Decentralized IDs must have 3 parts')\n  }\n\n  if (didParts[0].toLowerCase() !== 'did') {\n    throw new InvalidDIDError('Decentralized IDs must start with \"did\"')\n  }\n\n  if (didParts[1].toLowerCase() === 'ecdsa-pub') {\n    return didParts[2]\n  } else if (didParts[1].toLowerCase() === 'btc-addr') {\n    return didParts[2]\n  } else {\n    throw new InvalidDIDError('Decentralized ID format not supported')\n  }\n}\n*/\n","// eslint-disable-next-line import/no-unassigned-import\nimport 'cross-fetch/polyfill';\n\nimport { TokenSigner, SECP256K1Client } from 'jsontokens';\nimport { makeUUID4, nextMonth, getGlobalObject } from '@stacks/common';\nimport { makeDIDFromAddress } from './dids';\nimport {\n  encryptECIES,\n  decryptECIES,\n  makeECPrivateKey,\n  publicKeyToAddress,\n} from '@stacks/encryption';\nimport { DEFAULT_SCOPE, AuthScope } from './constants';\n\nconst VERSION = '1.3.1';\n\ntype AuthMetadata = {\n  email?: string;\n  profileUrl?: string;\n};\n\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\nexport function generateTransitKey() {\n  const transitKey = makeECPrivateKey();\n  return transitKey;\n}\n\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {(AuthScope | string)[]} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\nexport function makeAuthRequest(\n  transitPrivateKey: string,\n  redirectURI?: string,\n  manifestURI?: string,\n  scopes: (AuthScope | string)[] = DEFAULT_SCOPE.slice(),\n  appDomain?: string,\n  expiresAt: number = nextMonth().getTime(),\n  extraParams: any = {}\n): string {\n  const getWindowOrigin = (paramName: string) => {\n    const location = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: `makeAuthRequest([${paramName}=undefined])`,\n    });\n    return location?.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = `${getWindowOrigin('redirectURI')}/`;\n  }\n  if (!manifestURI) {\n    manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;\n  }\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n\n  /* Create the payload */\n  const payload = Object.assign({}, extraParams, {\n    jti: makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n    exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes,\n  });\n\n  // Logger.info(`blockstack.js: generating v${VERSION} auth request`)\n\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = publicKeyToAddress(publicKey);\n  payload.iss = makeDIDFromAddress(address);\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n\n  return token;\n}\n\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\nexport async function encryptPrivateKey(publicKey: string, privateKey: string): Promise<string> {\n  const encryptedObj = await encryptECIES(publicKey, Buffer.from(privateKey), true);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return Buffer.from(encryptedJSON).toString('hex');\n}\n\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\nexport async function decryptPrivateKey(\n  privateKey: string,\n  hexedEncrypted: string\n): Promise<string | null> {\n  const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = await decryptECIES(privateKey, encryptedObj);\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\n\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {String} username the username of the Blockstack ID if any, otherwise `null`\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\nexport async function makeAuthResponse(\n  privateKey: string,\n  profile: {} = {},\n  username: string | null = null,\n  metadata: AuthMetadata | null,\n  coreToken: string | null = null,\n  appPrivateKey: string | null = null,\n  expiresAt: number = nextMonth().getTime(),\n  transitPublicKey: string | null = null,\n  hubUrl: string | null = null,\n  blockstackAPIUrl: string | null = null,\n  associationToken: string | null = null\n): Promise<string> {\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = SECP256K1Client.derivePublicKey(privateKey);\n  const address = publicKeyToAddress(publicKey);\n\n  /* See if we should encrypt with the transit key */\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    // Logger.info(`blockstack.js: generating v${VERSION} auth response`)\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n    additionalProperties = {\n      email: metadata?.email ? metadata.email : null,\n      profile_url: metadata?.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION,\n    };\n  } else {\n    // Logger.info('blockstack.js: generating legacy auth response')\n  }\n\n  /* Create the payload */\n  const payload = Object.assign(\n    {},\n    {\n      jti: makeUUID4(),\n      iat: Math.floor(new Date().getTime() / 1000), // JWT times are in seconds\n      exp: Math.floor(expiresAt / 1000), // JWT times are in seconds\n      iss: makeDIDFromAddress(address),\n      private_key: privateKeyPayload,\n      public_keys: [publicKey],\n      profile,\n      username,\n      core_token: coreTokenPayload,\n    },\n    additionalProperties\n  );\n\n  /* Sign and return the token */\n  const tokenSigner = new TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}\n","import * as queryString from 'query-string';\nimport { decodeToken } from 'jsontokens';\nimport { BLOCKSTACK_HANDLER, getGlobalObject, fetchPrivate } from '@stacks/common';\n\n/**\n * Retrieves the authentication request from the query string\n * @return {String|null} the authentication request or `null` if\n * the query string parameter `authRequest` is not found\n * @private\n * @ignore\n */\nexport function getAuthRequestFromURL() {\n  const location = getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'getAuthRequestFromURL',\n  });\n  if (location?.search) {\n    const queryDict = queryString.parse(location?.search);\n    if (queryDict.authRequest) {\n      return (queryDict.authRequest as string).split(`${BLOCKSTACK_HANDLER}:`).join('');\n    } else {\n      return null;\n    }\n  } else {\n    return null;\n  }\n}\n\n/**\n * Fetches the contents of the manifest file specified in the authentication request\n *\n * @param  {String} authRequest encoded and signed authentication request\n * @return {Promise<Object|String>} Returns a `Promise` that resolves to the JSON\n * object manifest file unless there's an error in which case rejects with an error\n * message.\n * @private\n * @ignore\n */\nexport async function fetchAppManifest(authRequest: string): Promise<any> {\n  if (!authRequest) {\n    throw new Error('Invalid auth request');\n  }\n  const payload = decodeToken(authRequest).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const manifestURI = payload.manifest_uri as string;\n  try {\n    // Logger.debug(`Fetching manifest from ${manifestURI}`)\n    const response = await fetchPrivate(manifestURI);\n    const responseText = await response.text();\n    const responseJSON = JSON.parse(responseText);\n    return { ...responseJSON, manifestURI };\n  } catch (error) {\n    console.log(error);\n    throw new Error('Could not fetch manifest.json');\n  }\n}\n","import { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { publicKeyToAddress } from '@stacks/encryption';\nimport { fetchPrivate, isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { fetchAppManifest } from './provider';\n\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n * @ignore\n */\nexport function doSignaturesMatchPublicKeys(token: string): boolean {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys as string[];\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n    try {\n      const tokenVerifier = new TokenVerifier('ES256k', publicKey);\n      return tokenVerifier.verify(token);\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n * @ignore\n */\nexport function doPublicKeysMatchIssuer(token: string): boolean {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  const publicKeys = payload.public_keys as string[];\n  const addressFromIssuer = getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = publicKeyToAddress(publicKeys[0]);\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n\n/**\n * Looks up the identity address that owns the claimed username\n * in `token` using the lookup endpoint provided in `nameLookupURL`\n * to determine if the username is owned by the identity address\n * that matches the claimed public key\n *\n * @param  {String} token  encoded and signed authentication token\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\n * `true` if the username is owned by the public key, otherwise the\n * `Promise` resolves to `false`\n * @private\n * @ignore\n */\nexport async function doPublicKeysMatchUsername(\n  token: string,\n  nameLookupURL: string\n): Promise<boolean> {\n  try {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n    if (!payload.username) {\n      return true;\n    }\n\n    if (payload.username === null) {\n      return true;\n    }\n\n    if (nameLookupURL === null) {\n      return false;\n    }\n\n    const username = payload.username;\n    const url = `${nameLookupURL.replace(/\\/$/, '')}/${username}`;\n    const response = await fetchPrivate(url);\n    const responseText = await response.text();\n    const responseJSON = JSON.parse(responseText);\n    if (responseJSON.hasOwnProperty('address')) {\n      const nameOwningAddress = responseJSON.address;\n      const addressFromIssuer = getAddressFromDID(payload.iss);\n      if (nameOwningAddress === addressFromIssuer) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  } catch (error) {\n    console.log(error);\n    console.log('Error checking `doPublicKeysMatchUsername`');\n    return false;\n  }\n}\n\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n * @ignore\n */\nexport function isIssuanceDateValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n    const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n * @ignore\n */\nexport function isExpirationDateValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n    const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nexport function isManifestUriValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.manifest_uri as string);\n}\n\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\nexport function isRedirectUriValid(token: string) {\n  const payload = decodeToken(token).payload;\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n  return isSameOriginAbsoluteUrl(payload.domain_name as string, payload.redirect_uri as string);\n}\n\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n * @private\n * @ignore\n */\nexport async function verifyAuthRequest(token: string): Promise<boolean> {\n  if (decodeToken(token).header.alg === 'none') {\n    throw new Error('Token must be signed in order to be verified');\n  }\n  const values = await Promise.all([\n    isExpirationDateValid(token),\n    isIssuanceDateValid(token),\n    doSignaturesMatchPublicKeys(token),\n    doPublicKeysMatchIssuer(token),\n    isManifestUriValid(token),\n    isRedirectUriValid(token),\n  ]);\n  return values.every(val => val);\n}\n\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n * @ignore\n */\nexport async function verifyAuthRequestAndLoadManifest(token: string): Promise<any> {\n  const valid = await verifyAuthRequest(token);\n  if (!valid) {\n    throw new Error('Token is an invalid auth request');\n  }\n  return fetchAppManifest(token);\n}\n\n/**\n * Verify the authentication response is valid\n * @param {String} token the authentication response token\n * @param {String} nameLookupURL the url use to verify owner of a username\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n * @ignore\n */\nexport async function verifyAuthResponse(token: string, nameLookupURL: string): Promise<boolean> {\n  const values = await Promise.all([\n    isExpirationDateValid(token),\n    isIssuanceDateValid(token),\n    doSignaturesMatchPublicKeys(token),\n    doPublicKeysMatchIssuer(token),\n    doPublicKeysMatchUsername(token, nameLookupURL),\n  ]);\n  return values.every(val => val);\n}\n","import { InvalidStateError } from '@stacks/common';\nimport { UserData } from './userData';\n\nconst SESSION_VERSION = '1.0.0';\n\ntype EtagMap = { [key: string]: string };\n\nexport interface SessionOptions {\n  coreNode?: string;\n  userData?: UserData;\n  transitKey?: string;\n  etags?: EtagMap;\n  localStorageKey?: string;\n  storeOptions?: {\n    localStorageKey?: string;\n  };\n}\n\n/**\n * @ignore\n */\nexport class SessionData {\n  version: string;\n\n  transitKey?: string;\n\n  // using this in place of\n  // window.localStorage.setItem(BLOCKSTACK_STORAGE_LABEL, JSON.stringify(userData))\n  userData?: UserData;\n\n  etags?: EtagMap;\n\n  constructor(options: SessionOptions) {\n    this.version = SESSION_VERSION;\n    this.userData = options.userData;\n    this.transitKey = options.transitKey;\n    this.etags = options.etags ? options.etags : {};\n  }\n\n  // getGaiaHubConfig(): GaiaHubConfig {\n  //   return this.userData && this.userData.gaiaHubConfig\n  // }\n\n  // setGaiaHubConfig(config: GaiaHubConfig): void {\n  //   this.userData.gaiaHubConfig = config\n  // }\n\n  static fromJSON(json: any): SessionData {\n    if (json.version !== SESSION_VERSION) {\n      throw new InvalidStateError(`JSON data version ${json.version} not supported by SessionData`);\n    }\n    const options: SessionOptions = {\n      coreNode: json.coreNode,\n      userData: json.userData,\n      transitKey: json.transitKey,\n      etags: json.etags,\n    };\n    return new SessionData(options);\n  }\n\n  toString(): string {\n    return JSON.stringify(this);\n  }\n}\n","import { SessionData, SessionOptions } from './sessionData';\nimport { LOCALSTORAGE_SESSION_KEY } from './constants';\nimport { NoSessionDataError } from '@stacks/common';\n\n/**\n * An abstract class representing the SessionDataStore interface.\n\n */\nexport class SessionDataStore {\n  constructor(sessionOptions?: SessionOptions) {\n    if (sessionOptions) {\n      const newSessionData = new SessionData(sessionOptions);\n      this.setSessionData(newSessionData);\n    }\n  }\n\n  getSessionData(): SessionData {\n    throw new Error('Abstract class');\n  }\n\n  /* eslint-disable */\n  // @ts-ignore\n  // TODO: fix, not used?\n  setSessionData(session: SessionData): boolean {\n    throw new Error('Abstract class');\n  }\n\n  deleteSessionData(): boolean {\n    throw new Error('Abstract class');\n  }\n  /* eslint-enable */\n}\n\n/**\n * Stores session data in the instance of this class.\n * @ignore\n */\nexport class InstanceDataStore extends SessionDataStore {\n  sessionData?: SessionData;\n\n  constructor(sessionOptions?: SessionOptions) {\n    super(sessionOptions);\n    if (!this.sessionData) {\n      this.setSessionData(new SessionData({}));\n    }\n  }\n\n  getSessionData(): SessionData {\n    if (!this.sessionData) {\n      throw new NoSessionDataError('No session data was found.');\n    }\n    return this.sessionData;\n  }\n\n  setSessionData(session: SessionData): boolean {\n    this.sessionData = session;\n    return true;\n  }\n\n  deleteSessionData(): boolean {\n    this.setSessionData(new SessionData({}));\n    return true;\n  }\n}\n\n/**\n * Stores session data in browser a localStorage entry.\n * @ignore\n */\nexport class LocalStorageStore extends SessionDataStore {\n  key: string;\n\n  constructor(sessionOptions?: SessionOptions) {\n    super(sessionOptions);\n    if (\n      sessionOptions &&\n      sessionOptions.storeOptions &&\n      sessionOptions.storeOptions.localStorageKey &&\n      typeof sessionOptions.storeOptions.localStorageKey === 'string'\n    ) {\n      this.key = sessionOptions.storeOptions.localStorageKey;\n    } else {\n      this.key = LOCALSTORAGE_SESSION_KEY;\n    }\n\n    const data = localStorage.getItem(this.key);\n    if (!data) {\n      const sessionData = new SessionData({});\n      this.setSessionData(sessionData);\n    }\n  }\n\n  getSessionData(): SessionData {\n    const data = localStorage.getItem(this.key);\n    if (!data) {\n      throw new NoSessionDataError('No session data was found in localStorage');\n    }\n    const dataJSON = JSON.parse(data);\n    return SessionData.fromJSON(dataJSON);\n  }\n\n  setSessionData(session: SessionData): boolean {\n    localStorage.setItem(this.key, session.toString());\n    return true;\n  }\n\n  deleteSessionData(): boolean {\n    localStorage.removeItem(this.key);\n    this.setSessionData(new SessionData({}));\n    return true;\n  }\n}\n","import { AppConfig } from './appConfig';\nimport { SessionOptions } from './sessionData';\nimport { InstanceDataStore, LocalStorageStore, SessionDataStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport {\n  decryptContent,\n  encryptContent,\n  EncryptContentOptions,\n  hexStringToECPair,\n} from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport {\n  BLOCKSTACK_DEFAULT_GAIA_HUB_URL,\n  fetchPrivate,\n  getGlobalObject,\n  InvalidStateError,\n  isLaterVersion,\n  Logger,\n  LoginFailedError,\n  MissingParameterError,\n  nextHour,\n} from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { AuthScope, DEFAULT_PROFILE, NAME_LOOKUP_PATH } from './constants';\nimport * as queryString from 'query-string';\nimport { UserData } from './userData';\nimport { StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\n\n/**\n *\n * Represents an instance of a signed in user for a particular app.\n *\n * A signed in user has access to two major pieces of information\n * about the user, the user's private key for that app and the location\n * of the user's gaia storage bucket for the app.\n *\n * A user can be signed in either directly through the interactive\n * sign in process or by directly providing the app private key.\n *\n\n *\n */\nexport class UserSession {\n  appConfig: AppConfig;\n\n  store: SessionDataStore;\n\n  /**\n   * Creates a UserSession object\n   *\n   * @param options\n   */\n  constructor(options?: {\n    appConfig?: AppConfig;\n    sessionStore?: SessionDataStore;\n    sessionOptions?: SessionOptions;\n  }) {\n    let runningInBrowser = true;\n\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      // Logger.debug('UserSession: not running in browser')\n      runningInBrowser = false;\n    }\n\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n\n  /**\n   * Generates an authentication request that can be sent to the Blockstack\n   * browser for the user to approve sign in. This authentication request can\n   * then be used for sign in by passing it to the [[redirectToSignInWithAuthRequest]]\n   * method.\n   *\n   * *Note*: This method should only be used if you want to use a customized authentication\n   * flow. Typically, you'd use [[redirectToSignIn]] which is the default sign in method.\n   *\n   * @param transitKey A HEX encoded transit private key.\n   * @param redirectURI Location to redirect the user to after sign in approval.\n   * @param manifestURI Location of this app's manifest file.\n   * @param scopes The permissions this app is requesting. The default is `store_write`.\n   * @param appDomain The origin of the app.\n   * @param expiresAt The time at which this request is no longer valid.\n   * @param extraParams Any extra parameters to pass to the authenticator. Use this to\n   * pass options that aren't part of the Blockstack authentication specification,\n   * but might be supported by special authenticators.\n   *\n   * @returns {String} the authentication request\n   */\n  makeAuthRequest(\n    transitKey?: string,\n    redirectURI?: string,\n    manifestURI?: string,\n    scopes?: (AuthScope | string)[],\n    appDomain?: string,\n    expiresAt: number = nextHour().getTime(),\n    extraParams: any = {}\n  ): string {\n    const appConfig = this.appConfig;\n    if (!appConfig) {\n      throw new InvalidStateError('Missing AppConfig');\n    }\n    transitKey = transitKey || this.generateAndStoreTransitKey();\n    redirectURI = redirectURI || appConfig.redirectURI();\n    manifestURI = manifestURI || appConfig.manifestURI();\n    scopes = scopes || appConfig.scopes;\n    appDomain = appDomain || appConfig.appDomain;\n    return authMessages.makeAuthRequest(\n      transitKey,\n      redirectURI,\n      manifestURI,\n      scopes,\n      appDomain,\n      expiresAt,\n      extraParams\n    );\n  }\n\n  /**\n   * Generates a ECDSA keypair to\n   * use as the ephemeral app transit private key\n   * and store in the session.\n   *\n   * @returns {String} the hex encoded private key\n   *\n   */\n  generateAndStoreTransitKey(): string {\n    const sessionData = this.store.getSessionData();\n    const transitKey = authMessages.generateTransitKey();\n    sessionData.transitKey = transitKey;\n    this.store.setSessionData(sessionData);\n    return transitKey;\n  }\n\n  /**\n   * Retrieve the authentication token from the URL query\n   * @return {String} the authentication token if it exists otherwise `null`\n   */\n  getAuthResponseToken(): string {\n    const search = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'getAuthResponseToken',\n    })?.search;\n    if (search) {\n      const queryDict = queryString.parse(search);\n      return queryDict.authResponse ? (queryDict.authResponse as string) : '';\n    }\n    return '';\n  }\n\n  /**\n   * Check if there is a authentication request that hasn't been handled.\n   *\n   * Also checks for a protocol echo reply (which if detected then the page\n   * will be automatically redirected after this call).\n   *\n   * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n   */\n  isSignInPending() {\n    try {\n      const isProtocolEcho = protocolEchoReplyDetection();\n      if (isProtocolEcho) {\n        Logger.info(\n          'protocolEchoReply detected from isSignInPending call, the page is about to redirect.'\n        );\n        return true;\n      }\n    } catch (error) {\n      Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n\n    return !!this.getAuthResponseToken();\n  }\n\n  /**\n   * Check if a user is currently signed in.\n   *\n   * @returns {Boolean} `true` if the user is signed in, `false` if not.\n   */\n  isUserSignedIn() {\n    return !!this.store.getSessionData().userData;\n  }\n\n  /**\n   * Try to process any pending sign in request by returning a `Promise` that resolves\n   * to the user data object if the sign in succeeds.\n   *\n   * @param {String} authResponseToken - the signed authentication response token\n   * @returns {Promise} that resolves to the user data object if successful and rejects\n   * if handling the sign in request fails or there was no pending sign in request.\n   */\n  async handlePendingSignIn(\n    authResponseToken: string = this.getAuthResponseToken()\n  ): Promise<UserData> {\n    const sessionData = this.store.getSessionData();\n\n    if (sessionData.userData) {\n      throw new LoginFailedError('Existing user session found.');\n    }\n\n    const transitKey = this.store.getSessionData().transitKey;\n\n    // let nameLookupURL;\n    let coreNode = this.appConfig && this.appConfig.coreNode;\n    if (!coreNode) {\n      const network = new StacksMainnet();\n      coreNode = network.coreApiUrl;\n    }\n\n    const tokenPayload = decodeToken(authResponseToken).payload;\n\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    // Section below is removed since the config was never persisted and therefore useless\n\n    // if (isLaterVersion(tokenPayload.version as string, '1.3.0')\n    //    && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {\n    //   // override globally\n    //   Logger.info(`Overriding ${config.network.blockstackAPIUrl} `\n    //     + `with ${tokenPayload.blockstackAPIUrl}`)\n    //   // TODO: this config is never saved so the user node preference\n    //   // is not respected in later sessions..\n    //   config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl as string\n    //   coreNode = tokenPayload.blockstackAPIUrl as string\n    // }\n\n    const nameLookupURL = `${coreNode}${NAME_LOOKUP_PATH}`;\n\n    const isValid = await verifyAuthResponse(authResponseToken, nameLookupURL);\n    if (!isValid) {\n      throw new LoginFailedError('Invalid authentication response.');\n    }\n\n    // TODO: real version handling\n    let appPrivateKey: string = tokenPayload.private_key as string;\n    let coreSessionToken: string = tokenPayload.core_token as string;\n    if (isLaterVersion(tokenPayload.version as string, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            appPrivateKey = (await authMessages.decryptPrivateKey(\n              transitKey,\n              tokenPayload.private_key as string\n            )) as string;\n          } catch (e) {\n            Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n            try {\n              hexStringToECPair(tokenPayload.private_key as string);\n            } catch (ecPairError) {\n              throw new LoginFailedError(\n                'Failed decrypting appPrivateKey. Usually means' +\n                  ' that the transit key has changed during login.'\n              );\n            }\n          }\n        }\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            coreSessionToken = (await authMessages.decryptPrivateKey(\n              transitKey,\n              coreSessionToken\n            )) as string;\n          } catch (e) {\n            Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new LoginFailedError(\n          'Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.'\n        );\n      }\n    }\n    let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken: string;\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.2.0') &&\n      tokenPayload.hubUrl !== null &&\n      tokenPayload.hubUrl !== undefined\n    ) {\n      hubUrl = tokenPayload.hubUrl as string;\n    }\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.3.0') &&\n      tokenPayload.associationToken !== null &&\n      tokenPayload.associationToken !== undefined\n    ) {\n      gaiaAssociationToken = tokenPayload.associationToken as string;\n    }\n\n    const userData: UserData = {\n      username: tokenPayload.username as string,\n      profile: tokenPayload.profile,\n      email: tokenPayload.email as string,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      coreNode: tokenPayload.blockstackAPIUrl as string,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // @ts-ignore\n      gaiaAssociationToken,\n    };\n    const profileURL = tokenPayload.profile_url as string;\n    if (!userData.profile && profileURL) {\n      const response = await fetchPrivate(profileURL);\n      if (!response.ok) {\n        // return blank profile if we fail to fetch\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = await response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        userData.profile = extractProfile(wrappedProfile[0].token);\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n\n    sessionData.userData = userData;\n    this.store.setSessionData(sessionData);\n\n    return userData;\n  }\n\n  /**\n   * Retrieves the user data object. The user's profile is stored in the key [[Profile]].\n   *\n   * @returns {Object} User data object.\n   */\n  loadUserData() {\n    const userData = this.store.getSessionData().userData;\n    if (!userData) {\n      throw new InvalidStateError('No user data found. Did the user sign in?');\n    }\n    return userData;\n  }\n\n  /**\n   * Encrypts the data provided with the app public key.\n   * @param {String|Buffer} content  the data to encrypt\n   * @param options\n   * @param {String} options.publicKey the hex string of the ECDSA public\n   * key to use for encryption. If not provided, will use user's appPrivateKey.\n   *\n   * @returns {String} Stringified ciphertext object\n   */\n  encryptContent(content: string | Buffer, options?: EncryptContentOptions): Promise<string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return encryptContent(content, opts);\n  }\n\n  /**\n   * Decrypts data encrypted with `encryptContent` with the\n   * transit private key.\n   * @param {String|Buffer} content - encrypted content.\n   * @param options\n   * @param {String} options.privateKey - The hex string of the ECDSA private\n   * key to use for decryption. If not provided, will use user's appPrivateKey.\n   * @returns {String|Buffer} decrypted content.\n   */\n  decryptContent(content: string, options?: { privateKey?: string }): Promise<Buffer | string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return decryptContent(content, opts);\n  }\n\n  /**\n   * Sign the user out and optionally redirect to given location.\n   * @param  redirectURL\n   * Location to redirect user to after sign out.\n   * Only used in environments with `window` available\n   */\n\n  signUserOut(\n    redirectURL?: string\n    // TODO: this is not used?\n    // caller?: UserSession\n  ) {\n    this.store.deleteSessionData();\n    if (redirectURL) {\n      if (typeof location !== 'undefined' && location.href) {\n        location.href = redirectURL;\n      }\n      // TODO: Invalid left-hand side in assignment expression\n      // // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // // @ts-ignore\n      // getGlobalObject('location', {\n      //   throwIfUnavailable: true,\n      //   usageDesc: 'signUserOut',\n      // })?.href = redirectURL;\n    }\n  }\n}\n","/**\n * This logic is in a separate file with no dependencies so that it can be\n * loaded and executed as soon as possible to fulfill the purpose of the protocol\n * detection technique. The effectiveness of this is obviously subject to how web\n * apps bundle/consume the blockstack.js lib.\n */\n\nconst GLOBAL_DETECTION_CACHE_KEY = '_blockstackDidCheckEchoReply';\nconst ECHO_REPLY_PARAM = 'echoReply';\nconst AUTH_CONTINUATION_PARAM = 'authContinuation';\n\nfunction getQueryStringParams(query: string): Record<string, string> {\n  if (!query) {\n    return {};\n  }\n  // Trim a starting `?` character if exists\n  const trimmed = /^[?#]/.test(query) ? query.slice(1) : query;\n  return trimmed.split('&').reduce((params, param) => {\n    const [key, value] = param.split('=');\n    params[key] = value ? decodeURIComponent(value.replace(/\\+/g, ' ')) : '';\n    return params;\n  }, {} as Record<string, string>);\n}\n\n/**\n * Checks if the current window location URL contains an 'echoReply' parameter\n * which indicates that this page was only opened to signal back to the originating\n * tab that the protocol handler is installed.\n * If found, then localStorage events are used to notify the other tab,\n * and this page is redirected back to the Blockstack authenticator URL.\n * This function caches its result and will not trigger multiple redirects when\n * invoked multiple times.\n * @returns True if detected and the page will be automatically redirected.\n * @hidden\n */\nexport function protocolEchoReplyDetection(): boolean {\n  // Check that the `window` APIs exist\n  let globalScope: Window;\n  if (typeof self !== 'undefined') {\n    globalScope = self;\n  } else if (typeof window !== 'undefined') {\n    globalScope = window;\n  } else {\n    // Exit detection function - we are not running in a browser environment.\n    return false;\n  }\n\n  if (!globalScope.location || !globalScope.localStorage) {\n    // Exit detection function - we are not running in a browser environment.\n    return false;\n  }\n\n  // Avoid performing the check twice and triggered multiple redirect timers.\n  const existingDetection = (globalScope as any)[GLOBAL_DETECTION_CACHE_KEY];\n  if (typeof existingDetection === 'boolean') {\n    return existingDetection;\n  }\n\n  const searchParams = getQueryStringParams(globalScope.location.search);\n  const echoReplyParam = searchParams[ECHO_REPLY_PARAM];\n  if (echoReplyParam) {\n    (globalScope as any)[GLOBAL_DETECTION_CACHE_KEY] = true;\n\n    // Use localStorage to notify originated tab that protocol handler is available and working.\n    const echoReplyKey = `echo-reply-${echoReplyParam}`;\n\n    // Set the echo-reply result in localStorage for the other window to see.\n    globalScope.localStorage.setItem(echoReplyKey, 'success');\n\n    // Redirect back to the localhost auth url, as opposed to another protocol launch.\n    // This will re-use the same tab rather than creating another useless one.\n    globalScope.setTimeout(() => {\n      const authContinuationParam = searchParams[AUTH_CONTINUATION_PARAM];\n      globalScope.location.href = authContinuationParam;\n    }, 10);\n\n    return true;\n  }\n\n  return false;\n}\n","import { resolveZoneFileToProfile } from '@stacks/profile';\nimport { fetchPrivate } from '@stacks/common';\nimport { StacksNetwork, StacksMainnet } from '@stacks/network';\n\nexport interface ProfileLookupOptions {\n  username: string;\n  zoneFileLookupURL?: string;\n  network?: StacksNetwork;\n}\n\n/**\n * Look up a user profile by blockstack ID\n *\n * @param {string} username - The Blockstack ID of the profile to look up\n * @param {string} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, lookupProfile will use the\n * blockstack.js [[getNameInfo]] function.\n * @returns {Promise} that resolves to a profile object\n */\nexport function lookupProfile(options: ProfileLookupOptions): Promise<Record<string, any>> {\n  if (!options.username) {\n    return Promise.reject();\n  }\n  let network: StacksNetwork = options.network ? options.network : new StacksMainnet();\n  let lookupPromise;\n  if (options.zoneFileLookupURL) {\n    const url = `${options.zoneFileLookupURL.replace(/\\/$/, '')}/${options.username}`;\n    lookupPromise = fetchPrivate(url).then(response => response.json());\n  } else {\n    lookupPromise = network.getNameInfo(options.username);\n  }\n  return lookupPromise.then((responseJSON: any) => {\n    if (responseJSON.hasOwnProperty('zonefile') && responseJSON.hasOwnProperty('address')) {\n      return resolveZoneFileToProfile(responseJSON.zonefile, responseJSON.address);\n    } else {\n      throw new Error(\n        'Invalid zonefile lookup response: did not contain `address`' + ' or `zonefile` field'\n      );\n    }\n  });\n}\n"],"names":["DEFAULT_PROFILE","DEFAULT_SCOPE","AppConfig","scopes","appDomain","redirectPath","manifestPath","coreNode","authenticatorURL","slice","getGlobalObject","returnEmptyObject","_getGlobalObject","origin","undefined","redirectURI","this","manifestURI","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","makeDIDFromAddress","address","getDIDType","decentralizedID","didParts","split","InvalidDIDError","toLowerCase","getAddressFromDID","makeAuthRequest","transitPrivateKey","expiresAt","extraParams","nextMonth","getTime","getWindowOrigin","paramName","location","throwIfUnavailable","usageDesc","payload","assign","jti","makeUUID4","iat","Math","floor","Date","exp","iss","public_keys","domain_name","manifest_uri","redirect_uri","version","do_not_include_profile","supports_hub_url","publicKey","SECP256K1Client","derivePublicKey","publicKeyToAddress","TokenSigner","sign","encryptPrivateKey","privateKey","encryptECIES","Buffer","from","encryptedJSON","JSON","stringify","decryptPrivateKey","hexedEncrypted","unhexedString","encryptedObj","parse","decryptECIES","decrypted","profile","username","metadata","coreToken","appPrivateKey","transitPublicKey","hubUrl","blockstackAPIUrl","associationToken","privateKeyPayload","coreTokenPayload","additionalProperties","email","profile_url","profileUrl","private_key","core_token","tokenSigner","fetchAppManifest","authRequest","decodeToken","fetchPrivate","response","text","responseJSON","console","log","doSignaturesMatchPublicKeys","token","publicKeys","TokenVerifier","verify","e","doPublicKeysMatchIssuer","addressFromIssuer","doPublicKeysMatchUsername","nameLookupURL","url","replace","nameOwningAddress","isIssuanceDateValid","issuedAt","isExpirationDateValid","isManifestUriValid","isSameOriginAbsoluteUrl","isRedirectUriValid","verifyAuthRequest","header","alg","all","every","val","verifyAuthResponse","SessionData","options","userData","transitKey","etags","fromJSON","json","InvalidStateError","SessionDataStore","sessionOptions","newSessionData","setSessionData","getSessionData","session","deleteSessionData","InstanceDataStore","sessionData","NoSessionDataError","LocalStorageStore","storeOptions","localStorageKey","localStorage","getItem","_this2","data","dataJSON","setItem","removeItem","UserSession","runningInBrowser","window","appConfig","MissingParameterError","store","sessionStore","nextHour","authMessages","generateAndStoreTransitKey","makeECPrivateKey","getAuthResponseToken","search","queryDict","queryString","authResponse","isSignInPending","globalScope","existingDetection","query","searchParams","test","reduce","params","param","decodeURIComponent","echoReplyParam","setTimeout","href","protocolEchoReplyDetection","Logger","isUserSignedIn","handlePendingSignIn","authResponseToken","LoginFailedError","network","StacksMainnet","coreApiUrl","tokenPayload","coreSessionToken","isLaterVersion","warn","hexStringToECPair","BLOCKSTACK_DEFAULT_GAIA_HUB_URL","gaiaAssociationToken","identityAddress","profileURL","ok","wrappedProfile","extractProfile","loadUserData","encryptContent","content","opts","decryptContent","signUserOut","redirectURL","BLOCKSTACK_HANDLER","join","lookupPromise","zoneFileLookupURL","getNameInfo","resolveZoneFileToProfile","zonefile"],"mappings":"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"}
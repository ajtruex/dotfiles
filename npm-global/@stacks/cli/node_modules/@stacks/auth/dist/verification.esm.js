import { fetchPrivate, isSameOriginAbsoluteUrl } from '@stacks/common';
import { asyncToGenerator as _asyncToGenerator } from './_virtual/_rollupPluginBabelHelpers.js';
import runtime_1 from './node_modules/regenerator-runtime/runtime.esm.js';
import { decodeToken, TokenVerifier } from 'jsontokens';
import { getAddressFromDID } from './dids.esm.js';
import { publicKeyToAddress } from '@stacks/encryption';
import { fetchAppManifest } from './provider.esm.js';

function doSignaturesMatchPublicKeys(token) {
  var payload = decodeToken(token).payload;

  if (typeof payload === 'string') {
    throw new Error('Unexpected token payload type of string');
  }

  var publicKeys = payload.public_keys;

  if (publicKeys.length === 1) {
    var publicKey = publicKeys[0];

    try {
      var tokenVerifier = new TokenVerifier('ES256k', publicKey);
      return tokenVerifier.verify(token);
    } catch (e) {
      return false;
    }
  } else {
    throw new Error('Multiple public keys are not supported');
  }
}
function doPublicKeysMatchIssuer(token) {
  var payload = decodeToken(token).payload;

  if (typeof payload === 'string') {
    throw new Error('Unexpected token payload type of string');
  }

  var publicKeys = payload.public_keys;
  var addressFromIssuer = getAddressFromDID(payload.iss);

  if (publicKeys.length === 1) {
    var addressFromPublicKeys = publicKeyToAddress(publicKeys[0]);

    if (addressFromPublicKeys === addressFromIssuer) {
      return true;
    }
  } else {
    throw new Error('Multiple public keys are not supported');
  }

  return false;
}
function doPublicKeysMatchUsername(_x, _x2) {
  return _doPublicKeysMatchUsername.apply(this, arguments);
}

function _doPublicKeysMatchUsername() {
  _doPublicKeysMatchUsername = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(token, nameLookupURL) {
    var payload, username, url, response, responseText, responseJSON, nameOwningAddress, addressFromIssuer;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            payload = decodeToken(token).payload;

            if (!(typeof payload === 'string')) {
              _context.next = 4;
              break;
            }

            throw new Error('Unexpected token payload type of string');

          case 4:
            if (payload.username) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", true);

          case 6:
            if (!(payload.username === null)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", true);

          case 8:
            if (!(nameLookupURL === null)) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return", false);

          case 10:
            username = payload.username;
            url = nameLookupURL.replace(/\/$/, '') + "/" + username;
            _context.next = 14;
            return fetchPrivate(url);

          case 14:
            response = _context.sent;
            _context.next = 17;
            return response.text();

          case 17:
            responseText = _context.sent;
            responseJSON = JSON.parse(responseText);

            if (!responseJSON.hasOwnProperty('address')) {
              _context.next = 29;
              break;
            }

            nameOwningAddress = responseJSON.address;
            addressFromIssuer = getAddressFromDID(payload.iss);

            if (!(nameOwningAddress === addressFromIssuer)) {
              _context.next = 26;
              break;
            }

            return _context.abrupt("return", true);

          case 26:
            return _context.abrupt("return", false);

          case 27:
            _context.next = 30;
            break;

          case 29:
            return _context.abrupt("return", false);

          case 30:
            _context.next = 37;
            break;

          case 32:
            _context.prev = 32;
            _context.t0 = _context["catch"](0);
            console.log(_context.t0);
            console.log('Error checking `doPublicKeysMatchUsername`');
            return _context.abrupt("return", false);

          case 37:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 32]]);
  }));
  return _doPublicKeysMatchUsername.apply(this, arguments);
}

function isIssuanceDateValid(token) {
  var payload = decodeToken(token).payload;

  if (typeof payload === 'string') {
    throw new Error('Unexpected token payload type of string');
  }

  if (payload.iat) {
    if (typeof payload.iat !== 'number') {
      return false;
    }

    var issuedAt = new Date(payload.iat * 1000);

    if (new Date().getTime() < issuedAt.getTime()) {
      return false;
    } else {
      return true;
    }
  } else {
    return true;
  }
}
function isExpirationDateValid(token) {
  var payload = decodeToken(token).payload;

  if (typeof payload === 'string') {
    throw new Error('Unexpected token payload type of string');
  }

  if (payload.exp) {
    if (typeof payload.exp !== 'number') {
      return false;
    }

    var expiresAt = new Date(payload.exp * 1000);

    if (new Date().getTime() > expiresAt.getTime()) {
      return false;
    } else {
      return true;
    }
  } else {
    return true;
  }
}
function isManifestUriValid(token) {
  var payload = decodeToken(token).payload;

  if (typeof payload === 'string') {
    throw new Error('Unexpected token payload type of string');
  }

  return isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);
}
function isRedirectUriValid(token) {
  var payload = decodeToken(token).payload;

  if (typeof payload === 'string') {
    throw new Error('Unexpected token payload type of string');
  }

  return isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);
}
function verifyAuthRequest(_x3) {
  return _verifyAuthRequest.apply(this, arguments);
}

function _verifyAuthRequest() {
  _verifyAuthRequest = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(token) {
    var values;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(decodeToken(token).header.alg === 'none')) {
              _context2.next = 2;
              break;
            }

            throw new Error('Token must be signed in order to be verified');

          case 2:
            _context2.next = 4;
            return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]);

          case 4:
            values = _context2.sent;
            return _context2.abrupt("return", values.every(function (val) {
              return val;
            }));

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _verifyAuthRequest.apply(this, arguments);
}

function verifyAuthRequestAndLoadManifest(_x4) {
  return _verifyAuthRequestAndLoadManifest.apply(this, arguments);
}

function _verifyAuthRequestAndLoadManifest() {
  _verifyAuthRequestAndLoadManifest = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(token) {
    var valid;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return verifyAuthRequest(token);

          case 2:
            valid = _context3.sent;

            if (valid) {
              _context3.next = 5;
              break;
            }

            throw new Error('Token is an invalid auth request');

          case 5:
            return _context3.abrupt("return", fetchAppManifest(token));

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _verifyAuthRequestAndLoadManifest.apply(this, arguments);
}

function verifyAuthResponse(_x5, _x6) {
  return _verifyAuthResponse.apply(this, arguments);
}

function _verifyAuthResponse() {
  _verifyAuthResponse = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(token, nameLookupURL) {
    var values;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), doPublicKeysMatchUsername(token, nameLookupURL)]);

          case 2:
            values = _context4.sent;
            return _context4.abrupt("return", values.every(function (val) {
              return val;
            }));

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _verifyAuthResponse.apply(this, arguments);
}

export { doPublicKeysMatchIssuer, doPublicKeysMatchUsername, doSignaturesMatchPublicKeys, isExpirationDateValid, isIssuanceDateValid, isManifestUriValid, isRedirectUriValid, verifyAuthRequest, verifyAuthRequestAndLoadManifest, verifyAuthResponse };
//# sourceMappingURL=verification.esm.js.map

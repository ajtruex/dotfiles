{"version":3,"file":"utils.esm.js","sources":["../src/utils.ts"],"sourcesContent":["import * as logger from 'winston';\nimport * as bitcoinjs from 'bitcoinjs-lib';\nimport * as URL from 'url';\nimport * as readline from 'readline';\nimport * as stream from 'stream';\nimport * as fs from 'fs';\nimport * as blockstack from 'blockstack';\nimport { TokenSigner } from 'jsontokens';\nimport {\n  getTypeString,\n  ClarityAbiType,\n  isClarityAbiPrimitive,\n  isClarityAbiBuffer,\n  isClarityAbiResponse,\n  isClarityAbiOptional,\n  isClarityAbiTuple,\n  isClarityAbiList,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCVFromString,\n  trueCV,\n  falseCV,\n  standardPrincipalCV,\n  TransactionVersion,\n} from '@stacks/transactions';\n\nimport { StacksNetwork } from '@stacks/network';\n\nconst ZoneFile = require('zone-file');\n\nimport {\n  PRIVATE_KEY_NOSIGN_PATTERN,\n  PRIVATE_KEY_PATTERN,\n  PRIVATE_KEY_MULTISIG_PATTERN,\n  PRIVATE_KEY_SEGWIT_P2SH_PATTERN,\n  ID_ADDRESS_PATTERN,\n} from './argparse';\n\nimport { TransactionSigner } from 'blockstack';\n\nimport { decryptBackupPhrase } from './encrypt';\n\nimport { getOwnerKeyInfo, getApplicationKeyInfo, extractAppKey } from './keys';\n\nimport { NameInfoType, CLINetworkAdapter } from './network';\n\nexport interface UTXO {\n  value?: number;\n  confirmations?: number;\n  tx_hash: string;\n  tx_output_n: number;\n}\n\nclass CLITransactionSigner implements TransactionSigner {\n  address: string;\n  isComplete: boolean;\n\n  constructor(address = '') {\n    this.address = address;\n    this.isComplete = false;\n  }\n\n  getAddress(): Promise<string> {\n    return Promise.resolve().then(() => this.address);\n  }\n\n  signTransaction(_txIn: bitcoinjs.TransactionBuilder, _signingIndex: number): Promise<void> {\n    return Promise.resolve().then(() => {});\n  }\n\n  signerVersion(): number {\n    return 0;\n  }\n}\n\nexport class NullSigner extends CLITransactionSigner {}\n\nexport class MultiSigKeySigner extends CLITransactionSigner {\n  redeemScript: Buffer;\n  privateKeys: string[];\n  m: number;\n\n  constructor(redeemScript: string, privateKeys: string[]) {\n    super();\n    this.redeemScript = Buffer.from(redeemScript, 'hex');\n    this.privateKeys = privateKeys;\n    this.isComplete = true;\n    try {\n      // try to deduce m (as in m-of-n)\n      const chunks = bitcoinjs.script.decompile(this.redeemScript);\n      const firstOp = chunks![0];\n      this.m = parseInt(bitcoinjs.script.toASM([firstOp]).slice(3), 10);\n      this.address = bitcoinjs.address.toBase58Check(\n        bitcoinjs.crypto.hash160(this.redeemScript),\n        blockstack.config.network.layer1.scriptHash\n      );\n    } catch (e) {\n      logger.error(e);\n      throw new Error('Improper redeem script for multi-sig input.');\n    }\n  }\n\n  getAddress(): Promise<string> {\n    return Promise.resolve().then(() => this.address);\n  }\n\n  signTransaction(txIn: bitcoinjs.TransactionBuilder, signingIndex: number): Promise<void> {\n    return Promise.resolve().then(() => {\n      const keysToUse = this.privateKeys.slice(0, this.m);\n      keysToUse.forEach(keyHex => {\n        const ecPair = blockstack.hexStringToECPair(keyHex);\n        txIn.sign(signingIndex, ecPair, this.redeemScript);\n      });\n    });\n  }\n\n  signerVersion(): number {\n    return 0;\n  }\n}\n\nexport class SegwitP2SHKeySigner extends CLITransactionSigner {\n  redeemScript: Buffer;\n  witnessScript: Buffer;\n  privateKeys: string[];\n  m: number;\n\n  constructor(redeemScript: string, witnessScript: string, m: number, privateKeys: string[]) {\n    super();\n    this.redeemScript = Buffer.from(redeemScript, 'hex');\n    this.witnessScript = Buffer.from(witnessScript, 'hex');\n    this.address = bitcoinjs.address.toBase58Check(\n      bitcoinjs.crypto.hash160(this.redeemScript),\n      blockstack.config.network.layer1.scriptHash\n    );\n\n    this.privateKeys = privateKeys;\n    this.m = m;\n    this.isComplete = true;\n  }\n\n  getAddress(): Promise<string> {\n    return Promise.resolve().then(() => this.address);\n  }\n\n  findUTXO(txIn: bitcoinjs.TransactionBuilder, signingIndex: number, utxos: UTXO[]): UTXO {\n    // NOTE: this is O(n*2) complexity for n UTXOs when signing an n-input transaction\n    // NOTE: as of bitcoinjs-lib 4.x, the \"tx\" field is private\n    const private_tx = (txIn as any).__TX;\n    const txidBuf = new Buffer(private_tx.ins[signingIndex].hash.slice());\n    const outpoint = private_tx.ins[signingIndex].index;\n\n    txidBuf.reverse(); // NOTE: bitcoinjs encodes txid as big-endian\n    const txid = txidBuf.toString('hex');\n\n    for (let i = 0; i < utxos.length; i++) {\n      if (utxos[i].tx_hash === txid && utxos[i].tx_output_n === outpoint) {\n        if (!utxos[i].value) {\n          throw new Error(`UTXO for hash=${txid} vout=${outpoint} has no value`);\n        }\n        return utxos[i];\n      }\n    }\n    throw new Error(`No UTXO for input hash=${txid} vout=${outpoint}`);\n  }\n\n  signTransaction(txIn: bitcoinjs.TransactionBuilder, signingIndex: number): Promise<void> {\n    // This is an interface issue more than anything else.  Basically, in order to\n    // form the segwit sighash, we need the UTXOs.  If we knew better, we would have\n    // blockstack.js simply pass the consumed UTXO into this method.  But alas, we do\n    // not.  Therefore, we need to re-query them.  This is probably fine, since we're\n    // not pressured for time when it comes to generating transactions.\n    return Promise.resolve()\n      .then(() => {\n        return this.getAddress();\n      })\n      .then(address => {\n        return blockstack.config.network.getUTXOs(address);\n      })\n      .then(utxos => {\n        const utxo = this.findUTXO(txIn, signingIndex, utxos);\n        if (this.m === 1) {\n          // p2sh-p2wpkh\n          const ecPair = blockstack.hexStringToECPair(this.privateKeys[0]);\n          txIn.sign(signingIndex, ecPair, this.redeemScript, undefined, utxo.value);\n        } else {\n          // p2sh-p2wsh\n          const keysToUse = this.privateKeys.slice(0, this.m);\n          keysToUse.forEach(keyHex => {\n            const ecPair = blockstack.hexStringToECPair(keyHex);\n            txIn.sign(\n              signingIndex,\n              ecPair,\n              this.redeemScript,\n              undefined,\n              utxo.value,\n              this.witnessScript\n            );\n          });\n        }\n      });\n  }\n\n  signerVersion(): number {\n    return 0;\n  }\n}\n\nexport class SafetyError extends Error {\n  safetyErrors: AnyJson;\n  constructor(safetyErrors: AnyJson) {\n    super(JSONStringify(safetyErrors, true));\n    this.safetyErrors = safetyErrors;\n  }\n}\n\nfunction isCLITransactionSigner(\n  signer: string | CLITransactionSigner\n): signer is CLITransactionSigner {\n  return (signer as CLITransactionSigner).signerVersion !== undefined;\n}\n\nexport function hasKeys(signer: string | CLITransactionSigner): boolean {\n  if (isCLITransactionSigner(signer)) {\n    const s = signer as CLITransactionSigner;\n    return s.isComplete;\n  } else {\n    return true;\n  }\n}\n\n/*\n * Parse a string into a NullSigner\n * The string has the format \"nosign:address\"\n * @return a NullSigner instance\n */\nexport function parseNullSigner(addrString: string): NullSigner {\n  if (!addrString.startsWith('nosign:')) {\n    throw new Error('Invalid nosign string');\n  }\n\n  const addr = addrString.slice('nosign:'.length);\n  return new NullSigner(addr);\n}\n\n/*\n * Parse a string into a MultiSigKeySigner.\n * The string has the format \"m,pk1,pk2,...,pkn\"\n * @serializedPrivateKeys (string) the above string\n * @return a MultiSigKeySigner instance\n */\nexport function parseMultiSigKeys(serializedPrivateKeys: string): MultiSigKeySigner {\n  const matches = serializedPrivateKeys.match(PRIVATE_KEY_MULTISIG_PATTERN);\n  if (!matches) {\n    throw new Error('Invalid multisig private key string');\n  }\n\n  const m = parseInt(matches[1]);\n  const parts = serializedPrivateKeys.split(',');\n  const privkeys = [];\n  for (let i = 1; i < 256; i++) {\n    const pk = parts[i];\n    if (!pk) {\n      break;\n    }\n\n    if (!pk.match(PRIVATE_KEY_PATTERN)) {\n      throw new Error('Invalid private key string');\n    }\n\n    privkeys.push(pk);\n  }\n\n  // generate public keys\n  const pubkeys = privkeys.map(pk => {\n    return Buffer.from(getPublicKeyFromPrivateKey(pk), 'hex');\n  });\n\n  // generate redeem script\n  const multisigInfo = bitcoinjs.payments.p2ms({ m, pubkeys });\n  return new MultiSigKeySigner(multisigInfo.output!.toString('hex'), privkeys);\n}\n\n/*\n * Parse a string into a SegwitP2SHKeySigner\n * The string has the format \"segwit:p2sh:m,pk1,pk2,...,pkn\"\n * @serializedPrivateKeys (string) the above string\n * @return a MultiSigKeySigner instance\n */\nexport function parseSegwitP2SHKeys(serializedPrivateKeys: string): SegwitP2SHKeySigner {\n  const matches = serializedPrivateKeys.match(PRIVATE_KEY_SEGWIT_P2SH_PATTERN);\n  if (!matches) {\n    throw new Error('Invalid segwit p2sh private key string');\n  }\n\n  const m = parseInt(matches[1]);\n  const parts = serializedPrivateKeys.split(',');\n  const privkeys = [];\n  for (let i = 1; i < 256; i++) {\n    const pk = parts[i];\n    if (!pk) {\n      break;\n    }\n\n    if (!pk.match(PRIVATE_KEY_PATTERN)) {\n      throw new Error('Invalid private key string');\n    }\n\n    privkeys.push(pk);\n  }\n\n  // generate public keys\n  const pubkeys = privkeys.map(pk => {\n    return Buffer.from(getPublicKeyFromPrivateKey(pk), 'hex');\n  });\n\n  // generate redeem script for p2wpkh or p2sh, depending on how many keys\n  let redeemScript: string;\n  let witnessScript = '';\n  if (m === 1) {\n    // p2wpkh\n    const p2wpkh = bitcoinjs.payments.p2wpkh({ pubkey: pubkeys[0] });\n    const p2sh = bitcoinjs.payments.p2sh({ redeem: p2wpkh });\n\n    redeemScript = p2sh.redeem!.output!.toString('hex');\n  } else {\n    // p2wsh\n    const p2ms = bitcoinjs.payments.p2ms({ m, pubkeys });\n    const p2wsh = bitcoinjs.payments.p2wsh({ redeem: p2ms });\n    const p2sh = bitcoinjs.payments.p2sh({ redeem: p2wsh });\n\n    redeemScript = p2sh.redeem!.output!.toString('hex');\n    witnessScript = p2wsh.redeem!.output!.toString('hex');\n  }\n\n  return new SegwitP2SHKeySigner(redeemScript, witnessScript, m, privkeys);\n}\n\n/*\n * Decode one or more private keys from a string.\n * Can be used to parse single private keys (as strings),\n * or multisig bundles (as CLITransactionSigners)\n * @serializedPrivateKey (string) the private key, encoded\n * @return a CLITransactionSigner or a String\n */\nexport function decodePrivateKey(serializedPrivateKey: string): string | CLITransactionSigner {\n  const nosignMatches = serializedPrivateKey.match(PRIVATE_KEY_NOSIGN_PATTERN);\n  if (!!nosignMatches) {\n    // no private key\n    return parseNullSigner(serializedPrivateKey);\n  }\n\n  const singleKeyMatches = serializedPrivateKey.match(PRIVATE_KEY_PATTERN);\n  if (!!singleKeyMatches) {\n    // one private key\n    return serializedPrivateKey;\n  }\n\n  const multiKeyMatches = serializedPrivateKey.match(PRIVATE_KEY_MULTISIG_PATTERN);\n  if (!!multiKeyMatches) {\n    // multisig bundle\n    return parseMultiSigKeys(serializedPrivateKey);\n  }\n\n  const segwitP2SHMatches = serializedPrivateKey.match(PRIVATE_KEY_SEGWIT_P2SH_PATTERN);\n  if (!!segwitP2SHMatches) {\n    // segwit p2sh bundle\n    return parseSegwitP2SHKeys(serializedPrivateKey);\n  }\n\n  throw new Error('Unparseable private key');\n}\n\ntype AnyJson = string | number | boolean | null | { [property: string]: AnyJson } | AnyJson[];\n\n/*\n * JSON stringify helper\n * -- if stdout is a TTY, then pretty-format the JSON\n * -- otherwise, print it all on one line to make it easy for programs to consume\n */\nexport function JSONStringify(obj: AnyJson, stderr: boolean = false): string {\n  if ((!stderr && process.stdout.isTTY) || (stderr && process.stderr.isTTY)) {\n    return JSON.stringify(obj, null, 2);\n  } else {\n    return JSON.stringify(obj);\n  }\n}\n\n/*\n * Get a private key's public key, while honoring the 01 to compress it.\n * @privateKey (string) the hex-encoded private key\n */\nexport function getPublicKeyFromPrivateKey(privateKey: string): string {\n  const ecKeyPair = blockstack.hexStringToECPair(privateKey);\n  return ecKeyPair.publicKey.toString('hex');\n}\n\n/*\n * Get a private key's address.  Honor the 01 to compress the public key\n * @privateKey (string) the hex-encoded private key\n */\nexport function getPrivateKeyAddress(\n  network: CLINetworkAdapter,\n  privateKey: string | CLITransactionSigner\n): string {\n  if (isCLITransactionSigner(privateKey)) {\n    const pkts = privateKey as CLITransactionSigner;\n    return pkts.address;\n  } else {\n    const pk = privateKey as string;\n    const ecKeyPair = blockstack.hexStringToECPair(pk);\n    return network.coerceAddress(blockstack.ecPairToAddress(ecKeyPair));\n  }\n}\n\n/*\n * Is a name a sponsored name (a subdomain)?\n */\nexport function isSubdomain(name: string): boolean {\n  return !!name.match(/^[^\\.]+\\.[^.]+\\.[^.]+$/);\n}\n\n/*\n * Get the canonical form of a hex-encoded private key\n * (i.e. strip the trailing '01' if present)\n */\nexport function canonicalPrivateKey(privkey: string): string {\n  if (privkey.length == 66 && privkey.slice(-2) === '01') {\n    return privkey.substring(0, 64);\n  }\n  return privkey;\n}\n\n/*\n * Get the sum of a set of UTXOs' values\n * @txIn (object) the transaction\n */\nexport function sumUTXOs(utxos: UTXO[]): number {\n  return utxos.reduce((agg, x) => agg + x.value!, 0);\n}\n\n/*\n * Hash160 function for zone files\n */\nexport function hash160(buff: Buffer): Buffer {\n  return bitcoinjs.crypto.hash160(buff);\n}\n\n/*\n * Normalize a URL--remove duplicate /'s from the root of the path.\n * Throw an exception if it's not well-formed.\n */\nexport function checkUrl(url: string): string {\n  const urlinfo = URL.parse(url);\n  if (!urlinfo.protocol) {\n    throw new Error(`Malformed full URL: missing scheme in ${url}`);\n  }\n\n  if (!urlinfo.path || urlinfo.path.startsWith('//')) {\n    throw new Error(`Malformed full URL: path root has multiple /'s: ${url}`);\n  }\n\n  return url;\n}\n\n/*\n * Sign a profile into a JWT\n */\nexport function makeProfileJWT(profileData: Object, privateKey: string): string {\n  const signedToken = blockstack.signProfileToken(profileData, privateKey);\n  const wrappedToken = blockstack.wrapProfileToken(signedToken);\n  const tokenRecords = [wrappedToken];\n  return JSONStringify((tokenRecords as unknown) as AnyJson);\n}\n\nexport async function makeDIDConfiguration(\n  network: CLINetworkAdapter,\n  blockstackID: string,\n  domain: string,\n  privateKey: string\n): Promise<{ entries: { did: string; jwt: string }[] }> {\n  const tokenSigner = new TokenSigner('ES256K', privateKey);\n  const nameInfo = await network.getNameInfo(blockstackID);\n  const did = nameInfo.did!;\n  const payload = {\n    iss: did,\n    domain,\n    exp: new Date(new Date().setFullYear(new Date().getFullYear() + 1)),\n  };\n\n  const jwt = tokenSigner.sign(payload);\n  return {\n    entries: [\n      {\n        did,\n        jwt,\n      },\n    ],\n  };\n}\n/*\n * Broadcast a transaction and a zone file.\n * Returns an object that encodes the success/failure of doing so.\n * If zonefile is None, then only the transaction will be sent.\n */\nexport async function broadcastTransactionAndZoneFile(\n  network: CLINetworkAdapter,\n  tx: string,\n  zonefile?: string\n) {\n  let txid: string;\n  return Promise.resolve()\n    .then(() => {\n      return network.broadcastTransaction(tx);\n    })\n    .then((_txid: string) => {\n      txid = _txid;\n      if (zonefile) {\n        return network.broadcastZoneFile(zonefile, txid);\n      } else {\n        return { status: true };\n      }\n    })\n    .then(resp => {\n      if (!resp.status) {\n        return {\n          status: false,\n          error: 'Failed to broadcast zone file',\n          txid: txid,\n        };\n      } else {\n        return {\n          status: true,\n          txid: txid,\n        };\n      }\n    })\n    .catch(e => {\n      return {\n        status: false,\n        error: 'Caught exception sending transaction or zone file',\n        message: e.message,\n        stacktrace: e.stack,\n      };\n    });\n}\n\n/*\n * Easier-to-use getNameInfo.  Returns null if the name does not exist.\n */\nexport function getNameInfoEasy(\n  network: CLINetworkAdapter,\n  name: string\n): Promise<NameInfoType | null> {\n  const nameInfoPromise = network\n    .getNameInfo(name)\n    .then((nameInfo: NameInfoType) => nameInfo)\n    .catch((error: Error): null => {\n      if (error.message === 'Name not found') {\n        return null;\n      } else {\n        throw error;\n      }\n    });\n\n  return nameInfoPromise;\n}\n\n/*\n * Look up a name's zone file, profile URL, and profile\n * Returns a Promise to the above, or throws an error.\n */\nexport async function nameLookup(\n  network: CLINetworkAdapter,\n  name: string,\n  includeProfile: boolean = true\n): Promise<{ profile: any; profileUrl?: string; zonefile?: string }> {\n  const nameInfoPromise = getNameInfoEasy(network, name);\n  const profilePromise = includeProfile\n    ? blockstack.lookupProfile(name).catch(() => null)\n    : Promise.resolve().then(() => null);\n\n  const zonefilePromise = nameInfoPromise.then((nameInfo: NameInfoType | null) =>\n    nameInfo ? nameInfo.zonefile : null\n  );\n\n  const [profile, zonefile, nameInfo] = await Promise.all([\n    profilePromise,\n    zonefilePromise,\n    nameInfoPromise,\n  ]);\n  let profileObj = profile;\n\n  if (!nameInfo) {\n    throw new Error('Name not found');\n  }\n  if (nameInfo.hasOwnProperty('grace_period') && nameInfo.grace_period) {\n    throw new Error(\n      `Name is expired at block ${nameInfo.expire_block} ` +\n        `and must be renewed by block ${nameInfo.renewal_deadline}`\n    );\n  }\n\n  let profileUrl = null;\n  try {\n    const zonefileJSON = ZoneFile.parseZoneFile(zonefile);\n    if (zonefileJSON.uri && zonefileJSON.hasOwnProperty('$origin')) {\n      profileUrl = blockstack.getTokenFileUrl(zonefileJSON);\n    }\n  } catch (e) {\n    profileObj = null;\n  }\n\n  const ret = {\n    zonefile: zonefile,\n    profile: profileObj,\n    profileUrl: profileUrl,\n  };\n  // @ts-ignore\n  return ret;\n}\n\n/*\n * Get a password.  Don't echo characters to stdout.\n * Password will be passed to the given callback.\n */\nexport function getpass(promptStr: string, cb: (passwd: string) => void) {\n  const silentOutput = new stream.Writable({\n    write: (_chunk, _encoding, callback) => {\n      callback();\n    },\n  });\n\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: silentOutput,\n    terminal: true,\n  });\n\n  process.stderr.write(promptStr);\n  rl.question('', passwd => {\n    rl.close();\n    process.stderr.write('\\n');\n    cb(passwd);\n  });\n\n  return;\n}\n\n/*\n * Extract a 12-word backup phrase.  If the raw 12-word phrase is given, it will\n * be returned.  If the ciphertext is given, the user will be prompted for a password\n * (if a password is not given as an argument).\n */\nexport async function getBackupPhrase(\n  backupPhraseOrCiphertext: string,\n  password?: string\n): Promise<string> {\n  if (backupPhraseOrCiphertext.split(/ +/g).length > 1) {\n    // raw backup phrase\n    return backupPhraseOrCiphertext;\n  } else {\n    // ciphertext\n    const pass: string = await new Promise((resolve, reject) => {\n      if (!process.stdin.isTTY && !password) {\n        // password must be given\n        reject(new Error('Password argument required in non-interactive mode'));\n      } else {\n        // prompt password\n        getpass('Enter password: ', p => {\n          resolve(p);\n        });\n      }\n    });\n    return await decryptBackupPhrase(Buffer.from(backupPhraseOrCiphertext, 'base64'), pass);\n  }\n}\n\n/*\n * mkdir -p\n * path must be absolute\n */\nexport function mkdirs(path: string): void {\n  if (path.length === 0 || path[0] !== '/') {\n    throw new Error('Path must be absolute');\n  }\n\n  const pathParts = path.replace(/^\\//, '').split('/');\n  let tmpPath = '/';\n  for (let i = 0; i <= pathParts.length; i++) {\n    try {\n      const statInfo = fs.lstatSync(tmpPath);\n      if ((statInfo.mode & fs.constants.S_IFDIR) === 0) {\n        throw new Error(`Not a directory: ${tmpPath}`);\n      }\n    } catch (e) {\n      if (e.code === 'ENOENT') {\n        // need to create\n        fs.mkdirSync(tmpPath);\n      } else {\n        throw e;\n      }\n    }\n    if (i === pathParts.length) {\n      break;\n    }\n    tmpPath = `${tmpPath}/${pathParts[i]}`;\n  }\n}\n\n/*\n * Given a name or ID address, return a promise to the ID Address\n */\nexport async function getIDAddress(\n  network: CLINetworkAdapter,\n  nameOrIDAddress: string\n): Promise<string> {\n  if (nameOrIDAddress.match(ID_ADDRESS_PATTERN)) {\n    return nameOrIDAddress;\n  } else {\n    // need to look it up\n    const nameInfo = await network.getNameInfo(nameOrIDAddress);\n    return `ID-${nameInfo.address}`;\n  }\n}\n\n/*\n * Find all identity addresses until we have one that matches the given one.\n * Loops forever if not found\n */\nexport async function getOwnerKeyFromIDAddress(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  idAddress: string\n): Promise<string> {\n  let index = 0;\n  while (true) {\n    const keyInfo = await getOwnerKeyInfo(network, mnemonic, index);\n    if (keyInfo.idAddress === idAddress) {\n      return keyInfo.privateKey;\n    }\n    index++;\n  }\n}\n\n/*\n * Given a name or an ID address and a possibly-encrypted mnemonic, get the owner and app\n * private keys.\n * May prompt for a password if mnemonic is encrypted.\n */\nexport interface IDAppKeys {\n  ownerPrivateKey: string;\n  appPrivateKey: string;\n  mnemonic: string;\n}\n\nexport async function getIDAppKeys(\n  network: CLINetworkAdapter,\n  nameOrIDAddress: string,\n  appOrigin: string,\n  mnemonicOrCiphertext: string\n): Promise<IDAppKeys> {\n  const mnemonic = await getBackupPhrase(mnemonicOrCiphertext);\n  const idAddress = await getIDAddress(network, nameOrIDAddress);\n  const appKeyInfo = await getApplicationKeyInfo(network, mnemonic, idAddress, appOrigin);\n  const appPrivateKey = extractAppKey(network, appKeyInfo);\n  const ownerPrivateKey = await getOwnerKeyFromIDAddress(network, mnemonic, idAddress);\n  const ret = {\n    appPrivateKey,\n    ownerPrivateKey,\n    mnemonic,\n  };\n  return ret;\n}\n\ninterface InquirerPrompt {\n  type: string;\n  name: string;\n  message: string;\n  choices?: string[];\n}\n\nexport function makePromptsFromArgList(expectedArgs: ClarityFunctionArg[]): InquirerPrompt[] {\n  const prompts = [];\n  for (let i = 0; i < expectedArgs.length; i++) {\n    prompts.push(argToPrompt(expectedArgs[i]));\n  }\n  return prompts;\n}\n\nexport interface ClarityFunctionArg {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport function argToPrompt(arg: ClarityFunctionArg): InquirerPrompt {\n  const name = arg.name;\n  const type = arg.type;\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return {\n        type: 'input',\n        name,\n        message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n      };\n    } else if (type === 'int128') {\n      return {\n        type: 'input',\n        name,\n        message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n      };\n    } else if (type === 'bool') {\n      return {\n        type: 'list',\n        name,\n        message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n        choices: ['True', 'False'],\n      };\n    } else if (type === 'principal') {\n      return {\n        type: 'input',\n        name,\n        message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n      };\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    return {\n      type: 'input',\n      name,\n      message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n    };\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n\nexport function parseClarityFunctionArgAnswers(\n  answers: any,\n  expectedArgs: ClarityFunctionArg[]\n): ClarityValue[] {\n  const functionArgs: ClarityValue[] = [];\n  for (let i = 0; i < expectedArgs.length; i++) {\n    const expectedArg = expectedArgs[i];\n    const answer = answers[expectedArg.name];\n    functionArgs.push(answerToClarityValue(answer, expectedArg));\n  }\n  return functionArgs;\n}\n\nexport function answerToClarityValue(answer: any, arg: ClarityFunctionArg): ClarityValue {\n  const type = arg.type;\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(answer);\n    } else if (type === 'int128') {\n      return intCV(answer);\n    } else if (type === 'bool') {\n      return answer == 'True' ? trueCV() : falseCV();\n    } else if (type === 'principal') {\n      // TODO handle contract principals\n      return standardPrincipalCV(answer);\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    return bufferCVFromString(answer);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n\nexport function generateExplorerTxPageUrl(txid: string, network: StacksNetwork): string {\n  if (network.version === TransactionVersion.Testnet) {\n    return `https://testnet-explorer.now.sh/txid/0x${txid}`;\n  } else {\n    return `https://explorer.blockstack.org/txid/0x${txid}`;\n  }\n}\n"],"names":["ZoneFile","require","CLITransactionSigner","address","isComplete","getAddress","Promise","resolve","then","signTransaction","_txIn","_signingIndex","signerVersion","NullSigner","MultiSigKeySigner","redeemScript","privateKeys","Buffer","from","chunks","bitcoinjs","decompile","firstOp","m","parseInt","toASM","slice","toBase58Check","hash160","blockstack","network","layer1","scriptHash","e","logger","Error","txIn","signingIndex","keysToUse","forEach","keyHex","ecPair","sign","SegwitP2SHKeySigner","witnessScript","findUTXO","utxos","private_tx","__TX","txidBuf","ins","hash","outpoint","index","reverse","txid","toString","i","length","tx_hash","tx_output_n","value","getUTXOs","utxo","undefined","isCLITransactionSigner","signer","parseNullSigner","addrString","startsWith","addr","parseMultiSigKeys","serializedPrivateKeys","matches","match","PRIVATE_KEY_MULTISIG_PATTERN","parts","split","privkeys","pk","PRIVATE_KEY_PATTERN","push","pubkeys","map","getPublicKeyFromPrivateKey","multisigInfo","p2ms","output","parseSegwitP2SHKeys","PRIVATE_KEY_SEGWIT_P2SH_PATTERN","p2wpkh","pubkey","p2sh","redeem","p2wsh","decodePrivateKey","serializedPrivateKey","nosignMatches","PRIVATE_KEY_NOSIGN_PATTERN","singleKeyMatches","multiKeyMatches","segwitP2SHMatches","JSONStringify","obj","stderr","process","stdout","isTTY","JSON","stringify","privateKey","ecKeyPair","publicKey","getPrivateKeyAddress","pkts","coerceAddress","canonicalPrivateKey","privkey","substring","makeProfileJWT","profileData","signedToken","wrappedToken","tokenRecords","getNameInfoEasy","name","nameInfoPromise","getNameInfo","nameInfo","error","message","nameLookup","includeProfile","profilePromise","zonefilePromise","zonefile","all","profile","profileObj","hasOwnProperty","grace_period","expire_block","renewal_deadline","profileUrl","zonefileJSON","parseZoneFile","uri","ret","getpass","promptStr","cb","silentOutput","stream","write","_chunk","_encoding","callback","rl","readline","input","stdin","terminal","question","passwd","close","getBackupPhrase","backupPhraseOrCiphertext","password","reject","p","pass","decryptBackupPhrase","mkdirs","path","pathParts","replace","tmpPath","statInfo","fs","mode","S_IFDIR","code","getIDAddress","nameOrIDAddress","ID_ADDRESS_PATTERN","getOwnerKeyFromIDAddress","mnemonic","idAddress","getOwnerKeyInfo","keyInfo","getIDAppKeys","appOrigin","mnemonicOrCiphertext","getApplicationKeyInfo","appKeyInfo","appPrivateKey","extractAppKey","ownerPrivateKey","makePromptsFromArgList","expectedArgs","prompts","argToPrompt","arg","type","typeString","getTypeString","isClarityAbiPrimitive","choices","isClarityAbiBuffer","isClarityAbiResponse","isClarityAbiOptional","isClarityAbiTuple","isClarityAbiList","parseClarityFunctionArgAnswers","answers","functionArgs","expectedArg","answer","answerToClarityValue","uintCV","intCV","trueCV","falseCV","standardPrincipalCV","bufferCVFromString","generateExplorerTxPageUrl","version","TransactionVersion","Testnet"],"mappings":"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"}
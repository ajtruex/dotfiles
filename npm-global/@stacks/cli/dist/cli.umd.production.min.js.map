{"version":3,"file":"cli.umd.production.min.js","sources":["../../../node_modules/regenerator-runtime/runtime.js","../src/argparse.ts","../src/encrypt.ts","../src/utils.ts","../src/keys.ts","../src/network.ts","../src/data.ts","../src/auth.ts","../src/cli.ts","../src/index.ts"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import Ajv from 'ajv';\nimport * as process from 'process';\nimport * as fs from 'fs';\n\nexport const NAME_PATTERN = '^([0-9a-z_.+-]{3,37})$';\n\nexport const NAMESPACE_PATTERN = '^([0-9a-z_-]{1,19})$';\n\nexport const ADDRESS_CHARS = '[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{1,35}';\n\nexport const C32_ADDRESS_CHARS = '[0123456789ABCDEFGHJKMNPQRSTVWXYZ]+';\n\nexport const ADDRESS_PATTERN = `^(${ADDRESS_CHARS})$`;\n\nexport const ID_ADDRESS_PATTERN = `^ID-${ADDRESS_CHARS}$`;\n\nexport const STACKS_ADDRESS_PATTERN = `^(${C32_ADDRESS_CHARS})$`;\n\n// hex private key\nexport const PRIVATE_KEY_PATTERN = '^([0-9a-f]{64,66})$';\n\n// hex private key, no compression\nexport const PRIVATE_KEY_UNCOMPRESSED_PATTERN = '^([0-9a-f]{64})$';\n\n// nosign:addr\nexport const PRIVATE_KEY_NOSIGN_PATTERN = `^nosign:${ADDRESS_CHARS}$`;\n\n// m,pk1,pk2,...,pkn\nexport const PRIVATE_KEY_MULTISIG_PATTERN = '^([0-9]+),([0-9a-f]{64,66},)*([0-9a-f]{64,66})$';\n\n// segwit:p2sh:m,pk1,pk2,...,pkn\nexport const PRIVATE_KEY_SEGWIT_P2SH_PATTERN =\n  '^segwit:p2sh:([0-9]+),([0-9a-f]{64,66},)*([0-9a-f]{64,66})$';\n\n// any private key pattern we support\nexport const PRIVATE_KEY_PATTERN_ANY = `${PRIVATE_KEY_PATTERN}|${PRIVATE_KEY_MULTISIG_PATTERN}|${PRIVATE_KEY_SEGWIT_P2SH_PATTERN}|${PRIVATE_KEY_NOSIGN_PATTERN}`;\n\nexport const PUBLIC_KEY_PATTERN = '^([0-9a-f]{66,130})$';\n\nexport const INT_PATTERN = '^-?[0-9]+$';\n\nexport const ZONEFILE_HASH_PATTERN = '^([0-9a-f]{40})$';\n\nexport const URL_PATTERN = '^http[s]?://.+$';\n\nexport const SUBDOMAIN_PATTERN = '^([0-9a-z_+-]{1,37}).([0-9a-z_.+-]{3,37})$';\n\nexport const TXID_PATTERN = '^([0-9a-f]{64})$';\n\nexport const BOOLEAN_PATTERN = '^(0|1|true|false)$';\n\nexport interface CLI_LOG_CONFIG_TYPE {\n  level: string;\n  handleExceptions: boolean;\n  timestamp: boolean;\n  stringify: boolean;\n  colorize: boolean;\n  json: boolean;\n}\n\nexport interface CLI_CONFIG_TYPE {\n  blockstackAPIUrl: string;\n  blockstackNodeUrl: string;\n  broadcastServiceUrl: string;\n  utxoServiceUrl: string;\n  logConfig: CLI_LOG_CONFIG_TYPE;\n  bitcoindUsername?: string;\n  bitcoindPassword?: string;\n}\n\nconst LOG_CONFIG_DEFAULTS: CLI_LOG_CONFIG_TYPE = {\n  level: 'info',\n  handleExceptions: true,\n  timestamp: true,\n  stringify: true,\n  colorize: true,\n  json: true,\n};\n\nconst CONFIG_DEFAULTS: CLI_CONFIG_TYPE = {\n  blockstackAPIUrl: 'http://stacks-node-api.stacks.co',\n  blockstackNodeUrl: 'http://stacks-node-api.stacks.co',\n  broadcastServiceUrl: 'http://stacks-node-api.stacks.co/v2/transactions',\n  utxoServiceUrl: 'https://blockchain.info',\n  logConfig: LOG_CONFIG_DEFAULTS,\n};\n\nconst CONFIG_REGTEST_DEFAULTS: CLI_CONFIG_TYPE = {\n  blockstackAPIUrl: 'http://localhost:16268',\n  blockstackNodeUrl: 'http://localhost:16264',\n  broadcastServiceUrl: 'http://localhost:16269',\n  utxoServiceUrl: 'http://localhost:18332',\n  logConfig: LOG_CONFIG_DEFAULTS,\n  bitcoindPassword: 'blockstacksystem',\n  bitcoindUsername: 'blockstack',\n};\n\nconst PUBLIC_TESTNET_HOST = 'testnet-master.blockstack.org';\n\nconst CONFIG_TESTNET_DEFAULTS = {\n  blockstackAPIUrl: `http://${PUBLIC_TESTNET_HOST}:20443`,\n  blockstackNodeUrl: `http://${PUBLIC_TESTNET_HOST}:20443`,\n  broadcastServiceUrl: `http://${PUBLIC_TESTNET_HOST}:20443/v2/transactions`,\n  utxoServiceUrl: `http://${PUBLIC_TESTNET_HOST}:18332`,\n  logConfig: Object.assign({}, LOG_CONFIG_DEFAULTS, { level: 'debug' }),\n};\n\nexport const DEFAULT_CONFIG_PATH = '~/.blockstack-cli.conf';\nexport const DEFAULT_CONFIG_REGTEST_PATH = '~/.blockstack-cli-regtest.conf';\nexport const DEFAULT_CONFIG_TESTNET_PATH = '~/.blockstack-cli-testnet.conf';\n\nexport const DEFAULT_MAX_ID_SEARCH_INDEX = 256;\n\ninterface CLI_PROP_ITEM {\n  name: string;\n  type: 'string';\n  realtype: string;\n  pattern?: string;\n}\n\ninterface CLI_PROP {\n  [index: string]: {\n    type: 'array';\n    items: CLI_PROP_ITEM[];\n    minItems: number;\n    maxItems: number;\n    help: string;\n    group: string;\n  };\n}\n\n// CLI usage\nexport const CLI_ARGS = {\n  type: 'object',\n  properties: {\n    announce: {\n      type: 'array',\n      items: [\n        {\n          name: 'message_hash',\n          type: 'string',\n          realtype: 'zonefile_hash',\n          pattern: ZONEFILE_HASH_PATTERN,\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 2,\n      maxItems: 2,\n      help:\n        'Broadcast a message on the blockchain for subscribers to read.  ' +\n        'The `MESSAGE_HASH` argument must be the hash of a previously-announced zone file.  ' +\n        'The `OWNER_KEY` used to sign the transaction must correspond to the Blockstack ID ' +\n        'to which other users have already subscribed.  `OWNER_KEY` can be a single private key ' +\n        'or a serialized multisig private key bundle.\\n' +\n        '\\n' +\n        'If this command succeeds, it will print a transaction ID.  The rest of the Blockstack peer ' +\n        'network will process it once the transaction reaches 7 confirmations.\\n' +\n        '\\n' +\n        'Examples:\\n' +\n        '\\n' +\n        '    $ # Tip: You can obtain the owner key with the get_owner_keys command\\n' +\n        '    $ export OWNER_KEY=\"136ff26efa5db6f06b28f9c8c7a0216a1a52598045162abfe435d13036154a1b01\"\\n' +\n        '    $ stx announce 737c631c7c5d911c6617993c21fba731363f1cfe \"$OWNER_KEY\"\\n' +\n        '    d51749aeec2803e91a2f8bdec8d3e413491fd816b4962372b214ab74acb0bba8\\n' +\n        '\\n' +\n        '    $ export OWNER_KEY=\"2,136ff26efa5db6f06b28f9c8c7a0216a1a52598045162abfe435d13036154a1b01,1885cba486a42960499d1f137ef3a475725ceb11f45d74631f9928280196f67401,2418981c7f3a91d4467a65a518e14fafa30e07e6879c11fab7106ea72b49a7cb01\"\\n' +\n        '    $ stx announce 737c631c7c5d911c6617993c21fba731363f1cfe \"$OWNER_KEY\"\\n' +\n        '    8136a1114098893b28a693e8d84451abf99ee37ef8766f4bc59808eed76968c9\\n' +\n        '\\n',\n      group: 'Peer Services',\n    },\n    authenticator: {\n      type: 'array',\n      items: [\n        {\n          name: 'app_gaia_hub',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: '12_words_or_ciphertext',\n          pattern: '.+',\n        },\n        {\n          name: 'profile_gaia_hub',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'port',\n          type: 'string',\n          realtype: 'portnum',\n          pattern: '^[0-9]+',\n        },\n      ],\n      minItems: 2,\n      maxItems: 4,\n      help:\n        'Run an authentication endpoint for the set of names owned ' +\n        'by the given backup phrase.  Send applications the given Gaia hub URL on sign-in, ' +\n        'so the application will use it to read/write user data.\\n' +\n        '\\n' +\n        'You can supply your encrypted backup phrase instead of the raw backup phrase.  If so, ' +\n        'then you will be prompted for your password before any authentication takes place.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export BACKUP_PHRASE=\"oak indicate inside poet please share dinner monitor glow hire source perfect\"\\n' +\n        '    $ export APP_GAIA_HUB=\"https://1.2.3.4\"\\n' +\n        '    $ export PROFILE_GAIA_HUB=\"https://hub.blockstack.org\"\\n' +\n        '    $ stx authenticator \"$APP_GAIA_HUB\" \"$BACKUP_PHRASE\" \"$PROFILE_GAIA_HUB\" 8888\\n' +\n        '    Press Ctrl+C to exit\\n' +\n        '    Authentication server started on 8888\\n',\n      group: 'Authentication',\n    },\n    balance: {\n      type: 'array',\n      items: [\n        {\n          name: 'address',\n          type: 'string',\n          realtype: 'address',\n          pattern: `${ADDRESS_PATTERN}|${STACKS_ADDRESS_PATTERN}`,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Query the balance of an account.  Returns the balances of each kind of token ' +\n        'that the account owns.  The balances will be in the *smallest possible units* of the ' +\n        'token (i.e. satoshis for BTC, microStacks for Stacks, etc.).\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx balance 16pm276FpJYpm7Dv3GEaRqTVvGPTdceoY4\\n' +\n        '    {\\n' +\n        '      \"BTC\": \"123456\"\\n' +\n        '      \"STACKS\": \"123456\"\\n' +\n        '    }\\n' +\n        '    $ stx balance SPZY1V53Z4TVRHHW9Z7SFG8CZNRAG7BD8WJ6SXD0\\n' +\n        '    {\\n' +\n        '      \"BTC\": \"123456\"\\n' +\n        '      \"STACKS\": \"123456\"\\n' +\n        '    }\\n',\n      group: 'Account Management',\n    },\n    can_stack: {\n      type: 'array',\n      items: [\n        {\n          name: 'amount',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'cycles',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'pox_address',\n          type: 'string',\n          realtype: 'address',\n          pattern: `${ADDRESS_PATTERN}`,\n        },\n        {\n          name: 'stx_address',\n          type: 'string',\n          realtype: 'address',\n          pattern: `${STACKS_ADDRESS_PATTERN}`,\n        },\n      ],\n      minItems: 4,\n      maxItems: 4,\n      help:\n        'Check if specified account can stack a number of Stacks tokens for given number of cycles.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx can_stack 10000000 20 16pm276FpJYpm7Dv3GEaRqTVvGPTdceoY4 SPZY1V53Z4TVRHHW9Z7SFG8CZNRAG7BD8WJ6SXD0\\n' +\n        '    {\\n' +\n        '      \"eligible\": true\\n' +\n        '    }\\n',\n      group: 'Account Management',\n    },\n    call_contract_func: {\n      type: 'array',\n      items: [\n        {\n          name: 'contract_address',\n          type: 'string',\n          realtype: 'address',\n          pattern: `${STACKS_ADDRESS_PATTERN}`,\n        },\n        {\n          name: 'contract_name',\n          type: 'string',\n          realtype: 'string',\n          pattern: '^[a-zA-Z]([a-zA-Z0-9]|[-_])*$',\n        },\n        {\n          name: 'function_name',\n          type: 'string',\n          realtype: 'string',\n          pattern: '^[a-zA-Z]([a-zA-Z0-9]|[-_!?])*$',\n        },\n        {\n          name: 'fee',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'nonce',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 6,\n      maxItems: 6,\n      help:\n        'Call a function in a deployed Clarity smart contract.\\n' +\n        '\\n' +\n        'If the command succeeds, it prints out a transaction ID.' +\n        '\\n' +\n        'Example:\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ stx call_contract_func SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X contract_name' +\n        '      contract_function 1 0 \"$PAYMENT\"\\n' +\n        '    a9d387a925fb0ba7a725fb1e11f2c3f1647473699dd5a147c312e6453d233456\\n' +\n        '\\n',\n      group: 'Account Management',\n    },\n    call_read_only_contract_func: {\n      type: 'array',\n      items: [\n        {\n          name: 'contract_address',\n          type: 'string',\n          realtype: 'address',\n          pattern: `${STACKS_ADDRESS_PATTERN}`,\n        },\n        {\n          name: 'contract_name',\n          type: 'string',\n          realtype: 'string',\n          pattern: '^[a-zA-Z]([a-zA-Z0-9]|[-_])*$',\n        },\n        {\n          name: 'function_name',\n          type: 'string',\n          realtype: 'string',\n          pattern: '^[a-zA-Z]([a-zA-Z0-9]|[-_!?])*$',\n        },\n        {\n          name: 'sender_address',\n          type: 'string',\n          realtype: 'address',\n          pattern: `${STACKS_ADDRESS_PATTERN}`,\n        },\n      ],\n      minItems: 4,\n      maxItems: 4,\n      help:\n        'Call a read-only function in a deployed Clarity smart contract.\\n' +\n        '\\n' +\n        'If the command succeeds, it prints out a Clarity value.' +\n        '\\n' +\n        'Example:\\n' +\n        '    $ stx call_read_only_contract_func SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X contract_name' +\n        '     contract_function SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X\\n' +\n        '\\n',\n      group: 'Account Management',\n    },\n    convert_address: {\n      type: 'array',\n      items: [\n        {\n          name: 'address',\n          type: 'string',\n          realtype: 'address',\n          pattern: `${ADDRESS_PATTERN}|${STACKS_ADDRESS_PATTERN}`,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Convert a Bitcoin address to a Stacks address and vice versa.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx convert_address 12qdRgXxgNBNPnDeEChy3fYTbSHQ8nfZfD\\n' +\n        '    {\\n' +\n        '      \"STACKS\": \"SPA2MZWV9N67TBYVWTE0PSSKMJ2F6YXW7CBE6YPW\",\\n' +\n        '      \"BTC\": \"12qdRgXxgNBNPnDeEChy3fYTbSHQ8nfZfD\"\\n' +\n        '    }\\n' +\n        '    $ stx convert_address SPA2MZWV9N67TBYVWTE0PSSKMJ2F6YXW7CBE6YPW\\n' +\n        '    {\\n' +\n        '      \"STACKS\": \"SPA2MZWV9N67TBYVWTE0PSSKMJ2F6YXW7CBE6YPW\",\\n' +\n        '      \"BTC\": \"12qdRgXxgNBNPnDeEChy3fYTbSHQ8nfZfD\"\\n' +\n        '    }\\n',\n      group: 'Account Management',\n    },\n    decrypt_keychain: {\n      type: 'array',\n      items: [\n        {\n          name: 'encrypted_backup_phrase',\n          type: 'string',\n          realtype: 'encrypted_backup_phrase',\n          pattern: '^[^ ]+$',\n        },\n        {\n          name: 'password',\n          type: 'string',\n          realtype: 'password',\n          pattern: '.+',\n        },\n      ],\n      minItems: 1,\n      maxItems: 2,\n      help:\n        'Decrypt an encrypted backup phrase with a password.  Decrypts to a 12-word ' +\n        'backup phrase if done correctly.  The password will be prompted if not given.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # password is \"asdf\"\\n' +\n        '    $ stx decrypt_keychain \"bfMDtOucUGcJXjZo6vkrZWgEzue9fzPsZ7A6Pl4LQuxLI1xsVF0VPgBkMsnSLCmYS5YHh7R3mNtMmX45Bq9sNGPfPsseQMR0fD9XaHi+tBg=\\n' +\n        '    Enter password:\\n' +\n        '    section amount spend resemble spray verify night immune tattoo best emotion parrot',\n      group: 'Key Management',\n    },\n    deploy_contract: {\n      type: 'array',\n      items: [\n        {\n          name: 'source_file',\n          type: 'string',\n          realtype: 'path',\n          pattern: '.+',\n        },\n        {\n          name: 'contract_name',\n          type: 'string',\n          realtype: 'string',\n          pattern: '^[a-zA-Z]([a-zA-Z0-9]|[-_])*$',\n        },\n        {\n          name: 'fee',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'nonce',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 5,\n      maxItems: 5,\n      help:\n        'Deploys a Clarity smart contract on the network.\\n' +\n        '\\n' +\n        'If the command succeeds, it prints out a transaction ID.' +\n        '\\n' +\n        'Example:\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ stx deploy_contract ./my_contract.clar my_contract 1 0 \"$PAYMENT\"\\n' +\n        '    a9d387a925fb0ba7a725fb1e11f2c3f1647473699dd5a147c312e6453d233456\\n' +\n        '\\n',\n      group: 'Account Management',\n    },\n    docs: {\n      type: 'array',\n      items: [\n        {\n          name: 'format',\n          type: 'string',\n          realtype: 'output_format',\n          pattern: '^json$',\n        },\n      ],\n      minItems: 0,\n      maxItems: 1,\n      help: 'Dump the documentation for all commands as JSON to standard out.',\n      group: 'CLI',\n    },\n    encrypt_keychain: {\n      type: 'array',\n      items: [\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: 'backup_phrase',\n          pattern: '.+',\n        },\n        {\n          name: 'password',\n          type: 'string',\n          realtype: 'password',\n          pattern: '.+',\n        },\n      ],\n      minItems: 1,\n      maxItems: 2,\n      help:\n        'Encrypt a 12-word backup phrase, which can be decrypted later with the ' +\n        '`decrypt_backup_phrase` command.  The password will be prompted if not given.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '     $ # password is \"asdf\"\\n' +\n        '     $ stx encrypt_keychain \"section amount spend resemble spray verify night immune tattoo best emotion parrot\"\\n' +\n        '     Enter password:\\n' +\n        '     Enter password again:\\n' +\n        '     M+DnBHYb1fgw4N3oZ+5uTEAua5bAWkgTW/SjmmBhGGbJtjOtqVV+RrLJEJOgT35hBon4WKdGWye2vTdgqDo7+HIobwJwkQtN2YF9g3zPsKk=',\n      group: 'Key Management',\n    },\n    faucet: {\n      type: 'array',\n      items: [\n        {\n          name: 'address',\n          type: 'string',\n          realtype: 'address',\n          pattern: `${ADDRESS_PATTERN}|${STACKS_ADDRESS_PATTERN}`,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Encrypt a 12-word backup phrase, which can be decrypted later with the ' +\n        '`decrypt_backup_phrase` command.  The password will be prompted if not given.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '     $ # password is \"asdf\"\\n' +\n        '     $ blockstack-cli encrypt_keychain \"section amount spend resemble spray verify night immune tattoo best emotion parrot\"\\n' +\n        '     Enter password:\\n' +\n        '     Enter password again:\\n' +\n        '     M+DnBHYb1fgw4N3oZ+5uTEAua5bAWkgTW/SjmmBhGGbJtjOtqVV+RrLJEJOgT35hBon4WKdGWye2vTdgqDo7+HIobwJwkQtN2YF9g3zPsKk=',\n      group: 'Key Management',\n    },\n    gaia_dump_bucket: {\n      type: 'array',\n      items: [\n        {\n          name: 'name_or_id_address',\n          type: 'string',\n          realtype: 'name_or_id_address',\n          pattern: `${ID_ADDRESS_PATTERN}|${NAME_PATTERN}|${SUBDOMAIN_PATTERN}`,\n        },\n        {\n          name: 'app_origin',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'gaia_hub',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: '12_words_or_ciphertext',\n        },\n        {\n          name: 'dump_dir',\n          type: 'string',\n          realtype: 'path',\n          pattern: '.+',\n        },\n      ],\n      minItems: 5,\n      maxItems: 5,\n      help:\n        'Download the contents of a Gaia hub bucket to a given directory.  The `GAIA_HUB` argument ' +\n        'must correspond to the *write* endpoint of the Gaia hub -- that is, you should be able to fetch ' +\n        '`$GAIA_HUB/hub_info`.  If `DUMP_DIR` does not exist, it will be created.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export BACKUP_PHRASE=\"section amount spend resemble spray verify night immune tattoo best emotion parrot\\n' +\n        '    $ stx gaia_dump_bucket hello.id.blockstack https://sample.app https://hub.blockstack.org \"$BACKUP_PHRASE\" ./backups\\n' +\n        '    Download 3 files...\\n' +\n        '    Download hello_world to ./backups/hello_world\\n' +\n        '    Download dir/format to ./backups/dir\\\\x2fformat\\n' +\n        '    Download /.dotfile to ./backups/\\\\x2f.dotfile\\n' +\n        '    3\\n',\n      group: 'Gaia',\n    },\n    gaia_getfile: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: `${NAME_PATTERN}|${SUBDOMAIN_PATTERN}$`,\n        },\n        {\n          name: 'app_origin',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'filename',\n          type: 'string',\n          realtype: 'filename',\n          pattern: '.+',\n        },\n        {\n          name: 'app_private_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: PRIVATE_KEY_UNCOMPRESSED_PATTERN,\n        },\n        {\n          name: 'decrypt',\n          type: 'string',\n          realtype: 'boolean',\n          pattern: BOOLEAN_PATTERN,\n        },\n        {\n          name: 'verify',\n          type: 'string',\n          realtype: 'boolean',\n          pattern: BOOLEAN_PATTERN,\n        },\n      ],\n      minItems: 3,\n      maxItems: 6,\n      help:\n        \"Get a file from another user's Gaia hub.  Prints the file data to stdout.  If you \" +\n        'want to read an encrypted file, and/or verify a signed file, then you must pass an app ' +\n        'private key, and pass 1 for `DECRYPT` and/or `VERIFY`.  If the file is encrypted, and you do not ' +\n        'pass an app private key, then this command downloads the ciphertext.  If the file is signed, ' +\n        'and you want to download its data and its signature, then you must run this command twice -- ' +\n        'once to get the file contents at `FILENAME`, and once to get the signature (whose name will be `FILENAME`.sig).\\n' +\n        '\\n' +\n        'Gaia is a key-value store, so it does not have any built-in notion of directories.  However, ' +\n        'most underlying storage systems do -- directory separators in the name of a file in ' +\n        \"Gaia may be internally treated as first-class directories (it depends on the Gaia hub's driver).\" +\n        'As such, repeated directory separators will be treated as a single directory separator by this command.  ' +\n        'For example, the file name `a/b.txt`, `/a/b.txt`, and `///a////b.txt` will be treated as identical.\\n' +\n        '\\n' +\n        'Example without encryption:\\n' +\n        '\\n' +\n        '    $ # Get an unencrypted, unsigned file\\n' +\n        '    $ stx gaia_getfile ryan.id http://public.ykliao.com statuses.json\\n' +\n        '    [{\"id\":0,\"text\":\"Hello, Blockstack!\",\"created_at\":1515786983492}]\\n' +\n        '\\n' +\n        'Example with encryption:\\n' +\n        '\\n' +\n        '    $ # Get an encrypted file without decrypting\\n' +\n        '    $ stx gaia_getfile ryan.id https://app.graphitedocs.com documentscollection.json\\n' +\n        '    ' +\n        '    $ # Get an encrypted file, and decrypt it\\n' +\n        '    $ # Tip: You can obtain the app key with the get_app_keys command\\n' +\n        '    $ export APP_KEY=\"3ac770e8c3d88b1003bf4a0a148ceb920a6172bdade8e0325a1ed1480ab4fb19\"\\n' +\n        '    $ stx gaia_getfile ryan.id https://app.graphitedocs.com documentscollection.json \"$APP_KEY\" 1 0\\n',\n      group: 'Gaia',\n    },\n    gaia_putfile: {\n      type: 'array',\n      items: [\n        {\n          name: 'gaia_hub',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'app_private_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: PRIVATE_KEY_UNCOMPRESSED_PATTERN,\n        },\n        {\n          name: 'data_path',\n          type: 'string',\n          realtype: 'path',\n          pattern: '.+',\n        },\n        {\n          name: 'gaia_filename',\n          type: 'string',\n          realtype: 'filename',\n          pattern: '.+',\n        },\n        {\n          name: 'encrypt',\n          type: 'string',\n          realtype: 'boolean',\n          pattern: BOOLEAN_PATTERN,\n        },\n        {\n          name: 'sign',\n          type: 'string',\n          realtype: 'boolean',\n          pattern: BOOLEAN_PATTERN,\n        },\n      ],\n      minItems: 4,\n      maxItems: 6,\n      help:\n        'Put a file into a given Gaia hub, authenticating with the given app private key.  ' +\n        'Optionally encrypt and/or sign the data with the given app private key.  If the file is ' +\n        'successfully stored, this command prints out the URLs at which it can be fetched.\\n' +\n        '\\n' +\n        'Gaia is a key-value store, so it does not have any built-in notion of directories.  However, ' +\n        'most underlying storage systems do -- directory separators in the name of a file in ' +\n        \"Gaia may be internally treated as first-class directories (it depends on the Gaia hub's driver).\" +\n        'As such, repeated directory separators will be treated as a single directory separator by this command.  ' +\n        'For example, the file name `a/b.txt`, `/a/b.txt`, and `///a////b.txt` will be treated as identical.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # Store 4 versions of a file: plaintext, encrypted, signed, and encrypted+signed\\n' +\n        '    $ # Tip: You can obtain the app key with the get_app_keys command.\\n' +\n        '    $ export APP_KEY=\"3ac770e8c3d88b1003bf4a0a148ceb920a6172bdade8e0325a1ed1480ab4fb19\"\\n' +\n        '    $ stx gaia_putfile https://hub.blockstack.org \"$APP_KEY\" /path/to/file.txt file.txt\\n' +\n        '    {\\n' +\n        '       \"urls\": \"https://gaia.blockstack.org/hub/19KAzYp4kSKozeAGMUsnuqkEGdgQQLEvwo/file.txt\"\\n' +\n        '    }\\n' +\n        '    $ stx gaia_putfile https://hub.blockstack.org \"$APP_KEY\" /path/to/file.txt file-encrypted.txt 1\\n' +\n        '    {\\n' +\n        '       \"urls\": \"https://gaia.blockstack.org/hub/19KAzYp4kSKozeAGMUsnuqkEGdgQQLEvwo/file-encrypted.txt\"\\n' +\n        '    }\\n' +\n        '    $ stx gaia_putfile https://hub.blockstack.org \"$APP_KEY\" /path/to/file.txt file-signed.txt 0 1\\n' +\n        '    {\\n' +\n        '       \"urls\": \"https://gaia.blockstack.org/hub/19KAzYp4kSKozeAGMUsnuqkEGdgQQLEvwo/file-signed.txt\"\\n' +\n        '    }\\n' +\n        '    $ stx gaia_putfile https://hub.blockstack.org \"$APP_KEY\" /path/to/file.txt file-encrypted-signed.txt 1 1\\n' +\n        '    {\\n' +\n        '       \"urls\": \"https://gaia.blockstack.org/hub/19KAzYp4kSKozeAGMUsnuqkEGdgQQLEvwo/file-encrypted-signed.txt\"\\n' +\n        '    }\\n',\n      group: 'Gaia',\n    },\n    gaia_deletefile: {\n      type: 'array',\n      items: [\n        {\n          name: 'gaia_hub',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'app_private_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: PRIVATE_KEY_UNCOMPRESSED_PATTERN,\n        },\n        {\n          name: 'gaia_filename',\n          type: 'string',\n          realtype: 'filename',\n          pattern: '.+',\n        },\n        {\n          name: 'was_signed',\n          type: 'string',\n          realtype: 'boolean',\n          pattern: BOOLEAN_PATTERN,\n        },\n      ],\n      minItems: 3,\n      maxItems: 4,\n      help:\n        'Delete a file in a Gaia hub, as well as its signature metadata (which is stored in a separate file).' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # Tip: You can obtain the app key with the get_app_keys command.\\n' +\n        '    $ export APP_KEY=\"3ac770e8c3d88b1003bf4a0a148ceb920a6172bdade8e0325a1ed1480ab4fb19\"\\n' +\n        '    $ stx gaia_deletefile https://hub.blockstack.org \"$APP_KEY\" file.txt false\\n' +\n        '    ok',\n      group: 'Gaia',\n    },\n    gaia_listfiles: {\n      type: 'array',\n      items: [\n        {\n          name: 'gaia_hub',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'app_private_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: PRIVATE_KEY_UNCOMPRESSED_PATTERN,\n        },\n      ],\n      minItems: 2,\n      maxItems: 3,\n      help:\n        'List all the files in a Gaia hub bucket.  You must have the private key for the bucket ' +\n        'in order to list its contents.  The command prints each file name on its own line, and when ' +\n        'finished, it prints the number of files listed.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # Tip: You can obtain the app key with the get_app_keys command.\\n' +\n        '    $ export APP_KEY=\"3ac770e8c3d88b1003bf4a0a148ceb920a6172bdade8e0325a1ed1480ab4fb19\"\\n' +\n        '    $ stx gaia_listfiles \"https://hub.blockstack.org\" \"$APP_KEY\"\\n' +\n        '    hello_world\\n' +\n        '    dir/format\\n' +\n        '    /.dotfile\\n' +\n        '    3\\n',\n      group: 'Gaia',\n    },\n    gaia_restore_bucket: {\n      type: 'array',\n      items: [\n        {\n          name: 'name_or_id_address',\n          type: 'string',\n          realtype: 'name_or_id_address',\n          pattern: `${ID_ADDRESS_PATTERN}|${NAME_PATTERN}|${SUBDOMAIN_PATTERN}`,\n        },\n        {\n          name: 'app_origin',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'gaia_hub',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: '12_words_or_ciphertext',\n        },\n        {\n          name: 'dump_dir',\n          type: 'string',\n          realtype: 'path',\n          pattern: '.+',\n        },\n      ],\n      minItems: 5,\n      maxItems: 5,\n      help:\n        'Upload the contents of a previously-dumped Gaia bucket to a new Gaia hub.  The `GAIA_HUB` argument ' +\n        'must correspond to the *write* endpoint of the Gaia hub -- that is, you should be able to fetch ' +\n        '`$GAIA_HUB/hub_info`.  `DUMP_DIR` must contain the file contents created by a previous successful run of the gaia_dump_bucket command, ' +\n        'and both `NAME_OR_ID_ADDRESS` and `APP_ORIGIN` must be the same as they were when it was run.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export BACKUP_PHRASE=\"section amount spend resemble spray verify night immune tattoo best emotion parrot\"\\n' +\n        '    $ stx gaia_restore_bucket hello.id.blockstack https://sample.app https://new.gaia.hub \"$BACKUP_PHRASE\" ./backups\\n' +\n        '    Uploaded ./backups/hello_world to https://new.gaia.hub/hub/1Lr8ggSgdmfcb4764woYutUfFqQMjEoKHc/hello_world\\n' +\n        '    Uploaded ./backups/dir\\\\x2fformat to https://new.gaia.hub/hub/1Lr8ggSgdmfcb4764woYutUfFqQMjEoKHc/dir/format\\n' +\n        '    Uploaded ./backups/\\\\x2f.dotfile to https://new.gaia.hub/hub/1Lr8ggSgdmfcb4764woYutUfFqQMjEoKHc//.dotfile\\n' +\n        '    3\\n',\n      group: 'Gaia',\n    },\n    gaia_sethub: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: `^${NAME_PATTERN}|${SUBDOMAIN_PATTERN}$`,\n        },\n        {\n          name: 'owner_gaia_hub',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'app_origin',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'app_gaia_hub',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: '12_words_or_ciphertext',\n        },\n      ],\n      minItems: 5,\n      maxItems: 5,\n      help:\n        'Set the Gaia hub for a particular application for a Blockstack ID.  If the command succeeds, ' +\n        'the URLs to your updated profile will be printed and your profile will contain an entry in its \"apps\" ' +\n        'key that links the given `APP_ORIGIN` to the given `APP_GAIA_HUB`.\\n' +\n        '\\n' +\n        'NOTE: Both `OWNER_GAIA_HUB` and `APP_GAIA_HUB` must be the *write* endpoints of their respective Gaia hubs.\\n' +\n        '\\n' +\n        'Your 12-word phrase (in either raw or encrypted form) is required to re-sign and store your ' +\n        'profile and to generate an app-specific key and Gaia bucket.  If you give the encrypted backup phrase, you will be prompted for a password.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export BACKUP_PHRASE=\"soap fog wealth upon actual blossom neither timber phone exile monkey vocal\"\\n' +\n        '    $ stx gaia_sethub hello_world.id https://hub.blockstack.org https://my.cool.app https://my.app.gaia.hub \"$BACKUP_PHRASE\"\\n' +\n        '    {\\n' +\n        '      \"profileUrls\": {\\n' +\n        '        \"error\": null,\\n' +\n        '        \"dataUrls\": [\\n' +\n        '          \"https://gaia.blockstack.org/hub/1ArdkA2oLaKnbNbLccBaFhEV4pYju8hJ82/profile.json\"\\n' +\n        '        ]\\n' +\n        '      }\\n' +\n        '    }\\n' +\n        '    \\n' +\n        '    $ # You can check the new apps entry with curl and jq as follows:\\n' +\n        '    $ curl -sL https://gaia.blockstack.org/hub/1ArdkA2oLaKnbNbLccBaFhEV4pYju8hJ82/profile.json | jq \".[0].decodedToken.payload.claim.apps\"\\n' +\n        '    {\\n' +\n        '      \"https://my.cool.app\": \"https://my.app.gaia.hub/hub/1EqzyQLJ15KG1WQmi5cf1HtmSeqS1Wb8tY/\"\\n' +\n        '    }\\n' +\n        '\\n',\n      group: 'Gaia',\n    },\n    get_account_history: {\n      type: 'array',\n      items: [\n        {\n          name: 'address',\n          type: 'string',\n          realtype: 'address',\n          pattern: STACKS_ADDRESS_PATTERN,\n        },\n        {\n          name: 'page',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n      ],\n      minItems: 2,\n      maxItems: 2,\n      help:\n        'Query the history of account debits and credits over a given block range.  ' +\n        'Returns the history one page at a time.  An empty result indicates that the page ' +\n        'number has exceeded the number of historic operations in the given block range.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx get_account_history SP2H7VMY13ESQDAD5808QEY1EMGESMHZWBJRTN2YA 0\\n' +\n        '    [\\n' +\n        '      {\\n' +\n        '        \"address\": \"SP2H7VMY13ESQDAD5808QEY1EMGESMHZWBJRTN2YA\",\\n' +\n        '        \"block_id\": 56789\\n' +\n        '        \"credit_value\": \"100000000000\",\\n' +\n        '        \"debit_value\": \"0\",\\n' +\n        '        \"lock_transfer_block_id\": 0,\\n' +\n        '        \"txid\": \"0e5db84d94adff5b771262b9df015164703b39bb4a70bf499a1602b858a0a5a1\",\\n' +\n        '        \"type\": \"STACKS\",\\n' +\n        '        \"vtxindex\": 0\\n' +\n        '      },\\n' +\n        '      {\\n' +\n        '        \"address\": \"SP2H7VMY13ESQDAD5808QEY1EMGESMHZWBJRTN2YA\",\\n' +\n        '        \"block_id\": 56790,\\n' +\n        '        \"credit_value\": \"100000000000\",\\n' +\n        '        \"debit_value\": \"64000000000\",\\n' +\n        '        \"lock_transfer_block_id\": 0,\\n' +\n        '        \"txid\": \"5a0c67144626f7bd4514e4de3f3bbf251383ca13887444f326bac4bc8b8060ee\",\\n' +\n        '        \"type\": \"STACKS\",\\n' +\n        '        \"vtxindex\": 1\\n' +\n        '      },\\n' +\n        '      {\\n' +\n        '        \"address\": \"SP2H7VMY13ESQDAD5808QEY1EMGESMHZWBJRTN2YA\",\\n' +\n        '        \"block_id\": 56791,\\n' +\n        '        \"credit_value\": \"100000000000\",\\n' +\n        '        \"debit_value\": \"70400000000\",\\n' +\n        '        \"lock_transfer_block_id\": 0,\\n' +\n        '        \"txid\": \"e54c271d6a9feb4d1859d32bc99ffd713493282adef5b4fbf50bca9e33fc0ecc\",\\n' +\n        '        \"type\": \"STACKS\",\\n' +\n        '        \"vtxindex\": 2\\n' +\n        '      },\\n' +\n        '      {\\n' +\n        '        \"address\": \"SP2H7VMY13ESQDAD5808QEY1EMGESMHZWBJRTN2YA\",\\n' +\n        '        \"block_id\": 56792,\\n' +\n        '        \"credit_value\": \"100000000000\",\\n' +\n        '        \"debit_value\": \"76800000000\",\\n' +\n        '        \"lock_transfer_block_id\": 0,\\n' +\n        '        \"txid\": \"06e0d313261baefec1e59783e256ab487e17e0e776e2fdab0920cc624537e3c8\",\\n' +\n        '        \"type\": \"STACKS\",\\n' +\n        '        \"vtxindex\": 3\\n' +\n        '      }\\n' +\n        '    ]\\n' +\n        '\\n',\n      group: 'Account Management',\n    },\n    get_account_at: {\n      type: 'array',\n      items: [\n        {\n          name: 'address',\n          type: 'string',\n          realtype: 'address',\n          pattern: STACKS_ADDRESS_PATTERN,\n        },\n        {\n          name: 'blocknumber',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n      ],\n      minItems: 2,\n      maxItems: 2,\n      help:\n        'Query the list of token debits and credits on a given address that occurred ' +\n        'at a particular block height.  Does not include BTC debits and credits; only Stacks.\\n' +\n        '\\n' +\n        'Example\\n' +\n        '\\n' +\n        '    $ stx -t get_account_at SP2NTAQFECYGSTE1W47P71FG21H8F00KZZWFGEVKQ 56789\\n' +\n        '    [\\n' +\n        '      {\\n' +\n        '        \"debit_value\": \"0\",\\n' +\n        '        \"block_id\": 56789\\n' +\n        '        \"lock_transfer_block_id\": 0,\\n' +\n        '        \"txid\": \"291817c78a865c1f72938695218a48174265b2358e89b9448edc89ceefd66aa0\",\\n' +\n        '        \"address\": \"SP2NTAQFECYGSTE1W47P71FG21H8F00KZZWFGEVKQ\",\\n' +\n        '        \"credit_value\": \"1000000000000000000\",\\n' +\n        '        \"type\": \"STACKS\",\\n' +\n        '        \"vtxindex\": 0\\n' +\n        '      }\\n' +\n        '    ]\\n' +\n        '\\n',\n      group: 'Account Management',\n    },\n    get_address: {\n      type: 'array',\n      items: [\n        {\n          name: 'private_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get the address of a private key or multisig private key bundle.  Gives the BTC and STACKS addresses\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx get_address f5185b9ca93bdcb5753fded3b097dab8547a8b47d2be578412d0687a9a0184cb01\\n' +\n        '    {\\n' +\n        '      \"BTC\": \"1JFhWyVPpZQjbPcXFtpGtTmU22u4fhBVmq\",\\n' +\n        '      \"STACKS\": \"SP2YM3J4KQK09V670TD6ZZ1XYNYCNGCWCVVKSDFWQ\"\\n' +\n        '    }\\n' +\n        '    $ stx get_address 1,f5185b9ca93bdcb5753fded3b097dab8547a8b47d2be578412d0687a9a0184cb01,ff2ff4f4e7f8a1979ffad4fc869def1657fd5d48fc9cf40c1924725ead60942c01\\n' +\n        '    {\\n' +\n        '      \"BTC\": \"363pKBhc5ipDws1k5181KFf6RSxhBZ7e3p\",\\n' +\n        '      \"STACKS\": \"SMQWZ30EXVG6XEC1K4QTDP16C1CAWSK1JSWMS0QN\"\\n' +\n        '    }',\n      group: 'Key Management',\n    },\n    get_blockchain_record: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: `^${NAME_PATTERN}|${SUBDOMAIN_PATTERN}$`,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get the low-level blockchain-hosted state for a Blockstack ID.  This command ' +\n        'is used mainly for debugging and diagnostics.  You should not rely on it to be stable.',\n      group: 'Querying Blockstack IDs',\n    },\n    get_blockchain_history: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: `${NAME_PATTERN}|${SUBDOMAIN_PATTERN}$`,\n        },\n        {\n          name: 'page',\n          type: 'string',\n          realtype: 'page_number',\n          pattern: '^[0-9]+$',\n        },\n      ],\n      minItems: 1,\n      maxItems: 2,\n      help:\n        'Get the low-level blockchain-hosted history of operations on a Blockstack ID.  ' +\n        'This command is used mainly for debugging and diagnostics, and is not guaranteed to ' +\n        'be stable across releases.',\n      group: 'Querying Blockstack IDs',\n    },\n    get_confirmations: {\n      type: 'array',\n      items: [\n        {\n          name: 'txid',\n          type: 'string',\n          realtype: 'transaction_id',\n          pattern: TXID_PATTERN,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get the block height and number of confirmations for a transaction.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx get_confirmations e41ce043ab64fd5a5fd382fba21acba8c1f46cbb1d7c08771ada858ce7d29eea\\n' +\n        '    {\\n' +\n        '      \"blockHeight\": 567890,\\n' +\n        '      \"confirmations\": 7,\\n' +\n        '    }\\n' +\n        '\\n',\n      group: 'Peer Services',\n    },\n    get_namespace_blockchain_record: {\n      type: 'array',\n      items: [\n        {\n          name: 'namespace_id',\n          type: 'string',\n          realtype: 'namespace_id',\n          pattern: NAMESPACE_PATTERN,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get the low-level blockchain-hosted state for a Blockstack namespace.  This command ' +\n        'is used mainly for debugging and diagnostics, and is not guaranteed to be stable across ' +\n        'releases.',\n      group: 'Namespace Operations',\n    },\n    get_app_keys: {\n      type: 'array',\n      items: [\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: '12_words_or_ciphertext',\n        },\n        {\n          name: 'name_or_id_address',\n          type: 'string',\n          realtype: 'name-or-id-address',\n          pattern: `${NAME_PATTERN}|${SUBDOMAIN_PATTERN}|${ID_ADDRESS_PATTERN}`,\n        },\n        {\n          name: 'app_origin',\n          type: 'string',\n          realtype: 'url',\n          pattern: URL_PATTERN,\n        },\n      ],\n      minItems: 3,\n      maxItems: 3,\n      help:\n        'Get the application private key from a 12-word backup phrase and a name or ID-address.  ' +\n        'This is the private key used to sign data in Gaia, and its address is the Gaia bucket ' +\n        'address.  If you provide your encrypted backup phrase, you will be asked to decrypt it.  ' +\n        'If you provide a name instead of an ID-address, its ID-address will be queried automatically ' +\n        '(note that this means that the name must already be registered).\\n' +\n        '\\n' +\n        'NOTE: This command does NOT verify whether or not the name or ID-address was created by the ' +\n        'backup phrase. You should do this yourself via the `get_owner_keys` command if you are not sure.\\n' +\n        '\\n' +\n        'There are two derivation paths emitted by this command:  a `keyInfo` path and a `legacyKeyInfo`' +\n        \"path.  You should use the one that matches the Gaia hub read URL's address, if you have already \" +\n        'signed in before.  If not, then you should use the `keyInfo` path when possible.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export BACKUP_PHRASE=\"one race buffalo dynamic icon drip width lake extra forest fee kit\"\\n' +\n        '    $ stx get_app_keys \"$BACKUP_PHRASE\" example.id.blockstack https://my.cool.dapp\\n' +\n        '    {\\n' +\n        '      \"keyInfo\": {\\n' +\n        '        \"privateKey\": \"TODO\",\\n' +\n        '        \"address\": \"TODO\"\\n' +\n        '      },\\n' +\n        '      \"legacyKeyInfo\": {\\n' +\n        '        \"privateKey\": \"90f9ec4e13fb9a00243b4c1510075157229bda73076c7c721208c2edca28ea8b\",\\n' +\n        '        \"address\": \"1Lr8ggSgdmfcb4764woYutUfFqQMjEoKHc\"\\n' +\n        '      },\\n' +\n        '      \"ownerKeyIndex\": 0\\n' +\n        '    }',\n      group: 'Key Management',\n    },\n    get_owner_keys: {\n      type: 'array',\n      items: [\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: '12_words_or_ciphertext',\n        },\n        {\n          name: 'index',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n      ],\n      minItems: 1,\n      maxItems: 2,\n      help:\n        'Get the list of owner private keys and ID-addresses from a 12-word backup phrase.  ' +\n        'Pass non-zero values for INDEX to generate the sequence of ID-addresses that can be used ' +\n        'to own Blockstack IDs.  If you provide an encrypted 12-word backup phrase, you will be ' +\n        'asked for your password to decrypt it.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # get the first 3 owner keys and addresses for a backup phrase\\n' +\n        '    $ export BACKUP_PHRASE=\"soap fog wealth upon actual blossom neither timber phone exile monkey vocal\"\\n' +\n        '    $ stx get_owner_keys \"$BACKUP_PHRASE\" 3\\n' +\n        '    [\\n' +\n        '      {\\n' +\n        '        \"privateKey\": \"14b0811d5cd3486d47279d8f3a97008647c64586b121e99862c18863e2a4183501\",\\n' +\n        '        \"version\": \"v0.10-current\",\\n' +\n        '        \"index\": 0,\\n' +\n        '        \"idAddress\": \"ID-1ArdkA2oLaKnbNbLccBaFhEV4pYju8hJ82\"\\n' +\n        '      },\\n' +\n        '      {\\n' +\n        '        \"privateKey\": \"1b3572d8dd6866828281ac6cf135f04153210c1f9b123743eccb795fd3095e4901\",\\n' +\n        '        \"version\": \"v0.10-current\",\\n' +\n        '        \"index\": 1,\\n' +\n        '        \"idAddress\": \"ID-18pR3UpD1KFrnk88a3MGZmG2dLuZmbJZ25\"\\n' +\n        '      },\\n' +\n        '      {\\n' +\n        '        \"privateKey\": \"b19b6d62356db96d570fb5f08b78f0aa7f384525ba3bdcb96fbde29b8e11710d01\",\\n' +\n        '        \"version\": \"v0.10-current\",\\n' +\n        '        \"index\": 2,\\n' +\n        '        \"idAddress\": \"ID-1Gx4s7ggkjENw3wSY6bNd1CwoQKk857AqN\"\\n' +\n        '      }\\n' +\n        '    ]\\n' +\n        '\\n',\n      group: 'Key Management',\n    },\n    get_payment_key: {\n      type: 'array',\n      items: [\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: '12_words_or_ciphertext',\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get the payment private key from a 12-word backup phrase.  If you provide an ' +\n        'encrypted backup phrase, you will be asked for your password to decrypt it.  This command ' +\n        'will tell you your Bitcoin and Stacks token addresses as well.\\n' +\n        '\\n' +\n        'Example\\n' +\n        '\\n' +\n        '    $ stx get_payment_key \"soap fog wealth upon actual blossom neither timber phone exile monkey vocal\"\\n' +\n        '    [\\n' +\n        '      {\\n' +\n        '        \"privateKey\": \"4023435e33da4aff0775f33e7b258f257fb20ecff039c919b5782313ab73afb401\",\\n' +\n        '        \"address\": {\\n' +\n        '          \"BTC\": \"1ybaP1gaRwRSWRE4f8JXo2W8fiTZmA4rV\",\\n' +\n        '          \"STACKS\": \"SP5B89ZJAQHBRXVYP15YB5PAY5E24FEW9K4Q63PE\"\\n' +\n        '        },\\n' +\n        '        \"index\": 0\\n' +\n        '      }\\n' +\n        '    ]\\n' +\n        '\\n',\n      group: 'Key Management',\n    },\n    get_stacks_wallet_key: {\n      type: 'array',\n      items: [\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: '24_words_or_ciphertext',\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get the payment private key from a 24-word backup phrase used by the Stacks wallet.  If you provide an ' +\n        'encrypted backup phrase, you will be asked for your password to decrypt it.  This command ' +\n        'will tell you your Bitcoin and Stacks token addresses as well.\\n' +\n        '\\n' +\n        'Example\\n' +\n        '\\n' +\n        '    $ stx get_stacks_payment_key \"toast canal educate tissue express melody produce later gospel victory meadow outdoor hollow catch liberty annual gasp hat hello april equip thank neck cruise\"\\n' +\n        '    [\\n' +\n        '      {\\n' +\n        '        \"privateKey\": \"a25cea8d310ce656c6d427068c77bad58327334f73e39c296508b06589bc4fa201\",\\n' +\n        '        \"address\": {\\n' +\n        '          \"BTC\": \"1ATAW6TAbTCKgU3xPgAcWQwjW9Q26Eambx\",\\n' +\n        '          \"STACKS\": \"SP1KTQR7CTQNA20SV2VNTF9YABMR6RJERSES3KC6Z\"\\n' +\n        '        },\\n' +\n        '        \"index\": 0\\n' +\n        '      }\\n' +\n        '    ]\\n' +\n        '\\n',\n      group: 'Key Management',\n    },\n    get_zonefile: {\n      type: 'array',\n      items: [\n        {\n          name: 'zonefile_hash',\n          type: 'string',\n          realtype: 'zonefile_hash',\n          pattern: ZONEFILE_HASH_PATTERN,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get a zone file by hash.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx get_zonefile ee77ad484b7b229f09461e4c2b6d3bd3e152ba95\\n' +\n        '    $ORIGIN ryanshea.id\\n' +\n        '    $TTL 3600\\n' +\n        '    _http._tcp URI 10 1 \"https://gaia.blockstack.org/hub/15BcxePn59Y6mYD2fRLCLCaaHScefqW2No/1/profile.json\"\\n' +\n        '\\n',\n      group: 'Peer Services',\n    },\n    help: {\n      type: 'array',\n      items: [\n        {\n          name: 'command',\n          type: 'string',\n          realtype: 'command',\n        },\n      ],\n      minItems: 0,\n      maxItems: 1,\n      help: 'Get the usage string for a CLI command',\n      group: 'CLI',\n    },\n    lookup: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: `${NAME_PATTERN}|${SUBDOMAIN_PATTERN}$`,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get and authenticate the profile and zone file for a Blockstack ID.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx lookup example.id\\n' +\n        '\\n',\n      group: 'Querying Blockstack IDs',\n    },\n    names: {\n      type: 'array',\n      items: [\n        {\n          name: 'id_address',\n          type: 'string',\n          realtype: 'id-address',\n          pattern: ID_ADDRESS_PATTERN,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get the list of Blockstack IDs owned by an ID-address.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx names ID-1FpBChfzHG3TdQQRKWAipbLragCUArueG9\\n' +\n        '\\n',\n      group: 'Querying Blockstack IDs',\n    },\n    make_keychain: {\n      type: 'array',\n      items: [\n        {\n          name: 'backup_phrase',\n          type: 'string',\n          realtype: '12_words_or_ciphertext',\n        },\n      ],\n      minItems: 0,\n      maxItems: 1,\n      help:\n        'Generate the owner and payment private keys, optionally from a given 12-word ' +\n        'backup phrase.  If no backup phrase is given, a new one will be generated.  If you provide ' +\n        'your encrypted backup phrase, you will be asked to decrypt it.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx make_keychain\\n' +\n        '    {\\n' +\n        '      \"mnemonic\": \"apart spin rich leader siren foil dish sausage fee pipe ethics bundle\",\\n' +\n        '      \"keyInfo\": {\\n' +\n        '        \"address\": \"SP3G19B6J50FH6JGXAKS06N6WA1XPJCKKM4JCHC2D\"\\n' +\n        '        \"index\": 0,\\n' +\n        '        \"privateKey\": \"56d30f2b605ed114c7dc45599ae521c525d07e1286fbab67452a6586ea49332a01\"\\n' +\n        '      }\\n' +\n        '    }\\n' +\n        '\\n',\n      group: 'Key Management',\n    },\n    make_zonefile: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: `^${NAME_PATTERN}|${SUBDOMAIN_PATTERN}$`,\n        },\n        {\n          name: 'id_address',\n          type: 'string',\n          realtype: 'ID-address',\n          pattern: ID_ADDRESS_PATTERN,\n        },\n        {\n          name: 'gaia_url_prefix',\n          type: 'string',\n          realtype: 'url',\n          pattern: '.+',\n        },\n        {\n          name: 'resolver_url',\n          type: 'string',\n          realtype: 'url',\n          pattern: '.+',\n        },\n      ],\n      minItems: 3,\n      maxItems: 4,\n      help:\n        'Generate a zone file for a Blockstack ID with the given profile URL.  If you know ' +\n        'the ID-address for the Blockstack ID, the profile URL usually takes the form of:\\n' +\n        '\\n' +\n        '     {GAIA_URL_PREFIX}/{ADDRESS}/profile.json\\n' +\n        '\\n' +\n        'where `{GAIA_URL_PREFIX}` is the *read* endpoint of your Gaia hub (e.g. https://gaia.blockstack.org/hub) and ' +\n        \"`{ADDRESS}` is the base58check part of your ID-address (i.e. the string following 'ID-').\\n\" +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '     $ stx make_zonefile example.id ID-1ArdkA2oLaKnbNbLccBaFhEV4pYju8hJ82 https://my.gaia.hub/hub\\n' +\n        '     $ORIGIN example.id\\n' +\n        '     $TTL 3600\\n' +\n        '     _http._tcp      IN      URI     10      1       \"https://my.gaia.hub/hub/1ArdkA2oLaKnbNbLccBaFhEV4pYju8hJ82/profile.json\"\\n' +\n        '\\n',\n      group: 'Peer Services',\n    },\n    name_import: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n        {\n          name: 'id_address',\n          type: 'string',\n          realtype: 'id-address',\n          pattern: ID_ADDRESS_PATTERN,\n        },\n        {\n          name: 'gaia_url_prefix',\n          type: 'string',\n          realtype: 'url',\n          pattern: '.+',\n        },\n        {\n          name: 'reveal_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'zonefile',\n          type: 'string',\n          realtype: 'path',\n          pattern: '.+',\n        },\n        {\n          name: 'zonefile_hash',\n          type: 'string',\n          realtype: 'zonefile_hash',\n          pattern: ZONEFILE_HASH_PATTERN,\n        },\n      ],\n      minItems: 4,\n      maxItems: 6,\n      help:\n        'Import a name into a namespace you revealed.  The `REVEAL_KEY` must be the same as ' +\n        'the key that revealed the namespace.  You can only import a name into a namespace if ' +\n        'the namespace has not yet been launched (i.e. via `namespace_ready`), and if the ' +\n        'namespace was revealed less than a year ago (52595 blocks ago).\\n' +\n        '\\n' +\n        'A zone file will be generated for this name automatically, if \"ZONEFILE\" is not given.  By default, ' +\n        \"the zone file will have a URL to the name owner's profile prefixed by `GAIA_URL_PREFIX`.  If you \" +\n        \"know the *write* endpoint for the name owner's Gaia hub, you can find out the `GAIA_URL_PREFIX` \" +\n        'to use with `curl $GAIA_HUB/hub_info`\".\\n' +\n        '\\n' +\n        'If you specify an argument for `ZONEFILE`, then the `GAIA_URL_PREFIX` argument is ignored in favor of ' +\n        'your custom zone file on disk.\\n' +\n        '\\n' +\n        'If you specify a valid zone file hash for `ZONEFILE_HASH` then it will be used in favor of ' +\n        'both `ZONEFILE` and `GAIA_URL_PREFIX`.  The zone file hash will be incorporated directly into the ' +\n        'name-import transaction.\\n' +\n        '\\n' +\n        'This command prints out a transaction ID if it succeeds, and it replicates the zone file (if given) ' +\n        'to a transaction broadcaster (you can choose which one with -T).  The zone file will be automatically ' +\n        'broadcast to the Blockstack peer network when the transaction confirms.  Alternatively, you can do so ' +\n        'yourself with the `zonefile_push` command.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export REVEAL_KEY=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ export ID_ADDRESS=\"ID-18e1bqU7B5qUPY3zJgMLxDnexyStTeSnvV\"\\n' +\n        '    $ stx name_import example.id \"$ID_ADDRESS\" https://gaia.blockstack.org/hub \"$REVEAL_KEY\"\\n' +\n        '    f726309cea7a9db364307466dc0e0e759d5c0d6bad1405e2fd970740adc7dc45\\n' +\n        '\\n',\n      group: 'Namespace Operations',\n    },\n    namespace_preorder: {\n      type: 'array',\n      items: [\n        {\n          name: 'namespace_id',\n          type: 'string',\n          realtype: 'namespace_id',\n          pattern: NAMESPACE_PATTERN,\n        },\n        {\n          name: 'reveal_address',\n          type: 'string',\n          realtype: 'address',\n          pattern: ADDRESS_PATTERN,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 3,\n      maxItems: 3,\n      help:\n        'Preorder a namespace.  This is the first of three steps to creating a namespace.  ' +\n        'Once this transaction is confirmed, you will need to use the `namespace_reveal` command ' +\n        'to reveal the namespace (within 24 hours, or 144 blocks).',\n      group: 'Namespace Operations',\n    },\n    namespace_reveal: {\n      type: 'array',\n      items: [\n        {\n          name: 'namespace_id',\n          type: 'string',\n          realtype: 'namespace_id',\n          pattern: NAMESPACE_PATTERN,\n        },\n        {\n          name: 'reveal_address',\n          type: 'string',\n          realtype: 'address',\n          pattern: ADDRESS_PATTERN,\n        },\n        {\n          // version\n          name: 'version',\n          type: 'string',\n          realtype: '2-byte-integer',\n          pattern: INT_PATTERN,\n        },\n        {\n          // lifetime\n          name: 'lifetime',\n          type: 'string',\n          realtype: '4-byte-integer',\n          pattern: INT_PATTERN,\n        },\n        {\n          // coeff\n          name: 'coefficient',\n          type: 'string',\n          realtype: '1-byte-integer',\n          pattern: INT_PATTERN,\n        },\n        {\n          // base\n          name: 'base',\n          type: 'string',\n          realtype: '1-byte-integer',\n          pattern: INT_PATTERN,\n        },\n        {\n          // buckets\n          name: 'price_buckets',\n          type: 'string',\n          realtype: 'csv-of-16-nybbles',\n          pattern: '^([0-9]{1,2},){15}[0-9]{1,2}$',\n        },\n        {\n          // non-alpha discount\n          name: 'nonalpha_discount',\n          type: 'string',\n          realtype: 'nybble',\n          pattern: INT_PATTERN,\n        },\n        {\n          // no-vowel discount\n          name: 'no_vowel_discount',\n          type: 'string',\n          realtype: 'nybble',\n          pattern: INT_PATTERN,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 10,\n      maxItems: 10,\n      help:\n        'Reveal a preordered namespace, and set the price curve and payment options.  ' +\n        'This is the second of three steps required to create a namespace, and must be done ' +\n        'shortly after the associated `namespace_preorder` command.',\n      group: 'Namespace Operations',\n    },\n    namespace_ready: {\n      type: 'array',\n      items: [\n        {\n          name: 'namespace_id',\n          type: 'string',\n          realtype: 'namespace_id',\n          pattern: NAMESPACE_PATTERN,\n        },\n        {\n          name: 'reveal_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 2,\n      maxItems: 2,\n      help:\n        'Launch a revealed namespace.  This is the third and final step of creating a namespace.  ' +\n        'Once launched, you will not be able to import names anymore.',\n      group: 'Namespace Operations',\n    },\n    price: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get the price of an on-chain Blockstack ID.  Its namespace must already exist.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx price example.id\\n' +\n        '    {\\n' +\n        '      \"units\": \"BTC\",\\n' +\n        '      \"amount\": \"5500\"\\n' +\n        '    }\\n' +\n        '\\n',\n      group: 'Querying Blockstack IDs',\n    },\n    price_namespace: {\n      type: 'array',\n      items: [\n        {\n          name: 'namespace_id',\n          type: 'string',\n          realtype: 'namespace_id',\n          pattern: NAMESPACE_PATTERN,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get the price of a namespace.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # get the price of the .hello namespace\\n' +\n        '    $ stx price_namespace hello\\n' +\n        '    {\\n' +\n        '      \"units\": \"BTC\",\\n' +\n        '      \"amount\": \"40000000\"\\n' +\n        '    }\\n' +\n        '\\n',\n      group: 'Namespace Operations',\n    },\n    profile_sign: {\n      type: 'array',\n      items: [\n        {\n          name: 'profile',\n          type: 'string',\n          realtype: 'path',\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: PRIVATE_KEY_PATTERN,\n        },\n      ],\n      minItems: 2,\n      maxItems: 2,\n      help:\n        'Sign a profile on disk with a given owner private key.  Print out the signed profile JWT.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # Tip: you can get the owner key from your 12-word backup phrase using the get_owner_keys command\\n' +\n        '    $ stx profile_sign /path/to/profile.json 0ffd299af9c257173be8486ef54a4dd1373407d0629ca25ca68ff24a76be09fb01\\n' +\n        '\\n',\n      group: 'Profiles',\n    },\n    profile_store: {\n      type: 'array',\n      items: [\n        {\n          name: 'user_id',\n          type: 'string',\n          realtype: 'name-or-id-address',\n          pattern: `${NAME_PATTERN}|${SUBDOMAIN_PATTERN}|${ID_ADDRESS_PATTERN}`,\n        },\n        {\n          name: 'profile',\n          type: 'string',\n          realtype: 'path',\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: PRIVATE_KEY_PATTERN,\n        },\n        {\n          name: 'gaia_hub',\n          type: 'string',\n          realtype: 'url',\n        },\n      ],\n      minItems: 4,\n      maxItems: 4,\n      help:\n        'Store a profile on disk to a Gaia hub.  `USER_ID` can be either a Blockstack ID or ' +\n        \"an ID-address.  The `GAIA_HUB` argument must be the *write* endpoint for the user's Gaia hub \" +\n        '(e.g. https://hub.blockstack.org).  You can verify this by ensuring that you can run ' +\n        '`curl \"$GAIA_HUB/hub_info\"` successfully.',\n      group: 'Profiles',\n    },\n    profile_verify: {\n      type: 'array',\n      items: [\n        {\n          name: 'profile',\n          type: 'string',\n          realtype: 'path',\n        },\n        {\n          name: 'id_address',\n          type: 'string',\n          realtype: 'id-address',\n          pattern: `${ID_ADDRESS_PATTERN}|${PUBLIC_KEY_PATTERN}`,\n        },\n      ],\n      minItems: 2,\n      maxItems: 2,\n      help:\n        'Verify a JWT encoding a profile on disk using an ID-address.  Prints out the contained profile on success.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # get the raw profile JWT\\n' +\n        '    $ curl -sL https://raw.githubusercontent.com/jcnelson/profile/master/judecn.id > /tmp/judecn.id.jwt\\n' +\n        '    $ # Tip: you can get the ID-address for a name with the \"whois\" command\\n' +\n        '    $ stx profile_verify /tmp/judecn.id.jwt ID-16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\\n' +\n        '\\n',\n      group: 'Profiles',\n    },\n    renew: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'on-chain-blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'new_id_address',\n          type: 'string',\n          realtype: 'id-address',\n          pattern: ID_ADDRESS_PATTERN,\n        },\n        {\n          name: 'zonefile',\n          type: 'string',\n          realtype: 'path',\n        },\n        {\n          name: 'zonefile_hash',\n          type: 'string',\n          realtype: 'zonefile_hash',\n          pattern: ZONEFILE_HASH_PATTERN,\n        },\n      ],\n      minItems: 3,\n      maxItems: 6,\n      help:\n        'Renew a name.  Optionally transfer it to a new owner address (`NEW_ID_ADDRESS`), ' +\n        'and optionally load up and give it a new zone file on disk (`ZONEFILE`).  If the command ' +\n        'succeeds, it prints out a transaction ID.  You can use with the `get_confirmations` ' +\n        'command to track its confirmations on the underlying blockchain -- once it reaches 7 ' +\n        'confirmations, the rest of the Blockstack peer network will process it.\\n' +\n        '\\n' +\n        'If you create a new zonefile for your name, you will need ' +\n        'to later use `zonefile_push` to replicate the zone file to the Blockstack peer network ' +\n        'once the transaction reaches 7 confirmations.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # Tip: you can get your owner key from your backup phrase with \"get_owner_keys\".\\n' +\n        '    $ # Tip: you can get your payment key from your backup phrase with \"get_payment_key\".\\n' +\n        '    $ export OWNER=\"136ff26efa5db6f06b28f9c8c7a0216a1a52598045162abfe435d13036154a1b01\"\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ stx renew hello_world.id \"$OWNER\" \"$PAYMENT\"\\n' +\n        '    3d8945ce76d4261678d76592b472ed639a10d4298f9d730af4edbbc3ec02882e\\n' +\n        '\\n' +\n        '    $ # Renew with a new owner\\n' +\n        '    $ export NEW_OWNER=\"ID-141BcmFVbEuuMb7Bd6umXyV6ZD1WYomYDE\"\\n' +\n        '    $ stx renew hello_world.id \"$OWNER\" \"$PAYMENT\" \"$NEW_OWNER\"\\n' +\n        '    33865625ef3f1b607111c0dfba9e58604927173bd2e299a343e19aa6d2cfb263\\n' +\n        '\\n' +\n        '    $ # Renew with a new zone file.\\n' +\n        '    $ # Tip: you can create a new zonefile with the \"make_zonefile\" command.\\n' +\n        '    $ export ZONEFILE_PATH=\"/path/to/new/zonefile.txt\"\\n' +\n        '    $ stx renew hello_world.id \"$OWNER\" \"$PAYMENT\" --zonefile \"$ZONEFILE_PATH\"\\n' +\n        '    e41ce043ab64fd5a5fd382fba21acba8c1f46cbb1d7c08771ada858ce7d29eea\\n' +\n        '    $ # wait 7 confirmations\\n' +\n        '    $ stx get_confirmations e41ce043ab64fd5a5fd382fba21acba8c1f46cbb1d7c08771ada858ce7d29eea\\n' +\n        '    {\\n' +\n        '      \"blockHeight\": 567890,\\n' +\n        '      \"confirmations\": 7,\\n' +\n        '    }\\n' +\n        '    $ stx -H https://core.blockstack.org zonefile_push \"$ZONEFILE_PATH\"\\n' +\n        '    [\\n' +\n        '      \"https://core.blockstack.org\"\\n' +\n        '    ]\\n' +\n        '\\n',\n      group: 'Blockstack ID Management',\n    },\n    register: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'on-chain-blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: PRIVATE_KEY_PATTERN,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'gaia_hub',\n          type: 'string',\n          realtype: 'url',\n        },\n        {\n          name: 'zonefile',\n          type: 'string',\n          realtype: 'path',\n        },\n      ],\n      minItems: 4,\n      maxItems: 5,\n      help:\n        'If you are trying to register a name for a *private key*, use this command.\\n' +\n        '\\n' +\n        'Register a name to a single name-owning private key.  After successfully running this command, ' +\n        'and after waiting a couple hours, your name will be ready to use and will resolve to a ' +\n        'signed empty profile hosted on the given Gaia hub (`GAIA_HUB`).\\n' +\n        '\\n' +\n        'Behind the scenes, this will generate and send two transactions ' +\n        'and generate and replicate a zone file with the given Gaia hub URL (`GAIA_HUB`).  ' +\n        'Note that the `GAIA_HUB` argument must correspond to the *write* endpoint of the Gaia hub ' +\n        '(i.e. you should be able to run \\'curl \"$GAIA_HUB/hub_info\"\\' and get back data).  If you ' +\n        'are using Blockstack PBC\\'s default Gaia hub, pass \"https://hub.blockstack.org\" for this ' +\n        'argument.\\n' +\n        '\\n' +\n        \"By default, this command generates a zone file automatically that points to the Gaia hub's \" +\n        'read endpoint (which is queried on-the-fly from `GAIA_HUB`).  If you instead want to have a custom zone file for this name, ' +\n        'you can specify a path to it on disk with the `ZONEFILE` argument.\\n' +\n        '\\n' +\n        'If this command completes successfully, your name will be ready to use once both transactions have 7+ confirmations.  ' +\n        'You can use the `get_confirmations` command to track the confirmations ' +\n        'on the transaction IDs returned by this command.\\n' +\n        '\\n' +\n        'WARNING: You should *NOT* use the payment private key (`PAYMENT_KEY`) while the name is being confirmed.  ' +\n        'If you do so, you could double-spend one of the pending transactions and lose your name.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export OWNER=\"136ff26efa5db6f06b28f9c8c7a0216a1a52598045162abfe435d13036154a1b01\"\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ stx register example.id \"$OWNER\" \"$PAYMENT\" https://hub.blockstack.org\\n' +\n        '    9bb908bfd4ab221f0829167a461229172184fc825a012c4e551533aa283207b1\\n' +\n        '\\n',\n      group: 'Blockstack ID Management',\n    },\n    register_addr: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n        {\n          name: 'id-address',\n          type: 'string',\n          realtype: 'id-address',\n          pattern: ID_ADDRESS_PATTERN,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'gaia_url_prefix',\n          type: 'string',\n          realtype: 'url',\n        },\n        {\n          name: 'zonefile',\n          type: 'string',\n          realtype: 'path',\n        },\n      ],\n      minItems: 4,\n      maxItems: 5,\n      help:\n        'If you are trying to register a name for an *ID-address*, use this command.\\n' +\n        '\\n' +\n        \"Register a name to someone's ID-address.  After successfully running this \" +\n        'command and waiting a couple of hours, the name will be registered on-chain and have a ' +\n        \"zone file with a URL to where the owner's profile should be.  This command does NOT \" +\n        'generate, sign, or replicate a profile for the name---the name owner will need to do this ' +\n        'separately, once the name is registered.\\n' +\n        '\\n' +\n        'Behind the scenes, this command will generate two ' +\n        'transactions, and generate and replicate a zone file with the given Gaia hub read URL ' +\n        '(`GAIA_URL_PREFIX`).  Note that the `GAIA_URL_PREFIX` argument must correspond to the *read* endpoint of the Gaia hub ' +\n        '(e.g. if you are using Blockstack PBC\\'s default Gaia hub, this is \"https://gaia.blockstack.org/hub\"). ' +\n        \"If you know the *write* endpoint of the name owner's Gaia hub, you can find the right value for \" +\n        '`GAIA_URL_PREFIX` by running \"curl $GAIA_HUB/hub_info\".\\n' +\n        '\\n' +\n        'No profile will be generated or uploaded by this command.  Instead, this command generates ' +\n        'a zone file that will include the URL to a profile based on the `GAIA_URL_PREFIX` argument.\\n' +\n        '\\n' +\n        'The zone file will be generated automatically from the `GAIA_URL_PREFIX` argument.  If you need ' +\n        'to use a custom zone file, you can pass the path to it on disk via the `ZONEFILE` argument.\\n' +\n        '\\n' +\n        'If this command completes successfully, the name will be ready to use in a couple of ' +\n        'hours---that is, once both transactions have 7+ confirmations. ' +\n        'You can use the `get_confirmations` command to track the confirmations.\\n' +\n        '\\n' +\n        'WARNING: You should *NOT* use the payment private key (`PAYMENT_KEY`) while the name is being confirmed.  ' +\n        'If you do so, you could double-spend one of the pending transactions and lose the name.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export ID_ADDRESS=\"ID-18e1bqU7B5qUPY3zJgMLxDnexyStTeSnvV\"\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ stx register_addr example.id \"$ID_ADDRESS\" \"$PAYMENT\" https://gaia.blockstack.org/hub',\n      group: 'Blockstack ID Management',\n    },\n    register_subdomain: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: SUBDOMAIN_PATTERN,\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: PRIVATE_KEY_PATTERN,\n        },\n        {\n          name: 'gaia_hub',\n          type: 'string',\n          realtype: 'url',\n        },\n        {\n          name: 'registrar',\n          type: 'string',\n          realtype: 'url',\n        },\n        {\n          name: 'zonefile',\n          type: 'string',\n          realtype: 'path',\n        },\n      ],\n      minItems: 4,\n      maxItems: 5,\n      help:\n        'Register a subdomain.  This will generate and sign a subdomain zone file record ' +\n        'with the given `GAIA_HUB` URL and send it to the given subdomain registrar (`REGISTRAR`).\\n' +\n        '\\n' +\n        'This command generates, signs, and uploads a profile to the `GAIA_HUB` url.  Note that the `GAIA_HUB` ' +\n        'argument must correspond to the *write* endpoint of your Gaia hub (i.e. you should be able ' +\n        \"to run 'curl \\\"$GAIA_HUB/hub_info\\\"' successfully).  If you are using Blockstack PBC's default \" +\n        'Gaia hub, this argument should be \"https://hub.blockstack.org\".\\n' +\n        '\\n' +\n        'WARNING: At this time, no validation will occur on the registrar URL.  Be sure that the URL ' +\n        'corresponds to the registrar for the on-chain name before running this command!\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export OWNER=\"6e50431b955fe73f079469b24f06480aee44e4519282686433195b3c4b5336ef01\"\\n' +\n        '    $ # NOTE: https://registrar.blockstack.org is the registrar for personal.id!\\n' +\n        '    $ stx register_subdomain hello.personal.id \"$OWNER\" https://hub.blockstack.org https://registrar.blockstack.org\\n',\n      group: 'Blockstack ID Management',\n    },\n    revoke: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'on-chain-blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 3,\n      maxItems: 3,\n      help:\n        'Revoke a name.  This renders it unusable until it expires (if ever).  This command ' +\n        'prints out the transaction ID if it succeeds.  Once the transaction confirms, the name will ' +\n        'be revoked by each node in the peer network.  This command only works for on-chain names, not ' +\n        'subdomains.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # Tip: you can get your owner and payment keys from your 12-word backup phrase using the get_owner_keys and get_payment_key commands.\\n' +\n        '    $ export OWNER=\"6e50431b955fe73f079469b24f06480aee44e4519282686433195b3c4b5336ef01\"\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ stx revoke example.id \"$OWNER\" \"$PAYMENT\"\\n' +\n        '    233b559c97891affa010567bd582110508d0236b4e3f88d3b1d0731629e030b0\\n' +\n        '\\n',\n      group: 'Blockstack ID Management',\n    },\n    send_btc: {\n      type: 'array',\n      items: [\n        {\n          name: 'recipient_address',\n          type: 'string',\n          realtype: 'address',\n          pattern: ADDRESS_PATTERN,\n        },\n        {\n          name: 'amount',\n          type: 'string',\n          realtype: 'satoshis',\n          pattern: INT_PATTERN,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 3,\n      maxItems: 3,\n      help:\n        'Send some Bitcoin (in satoshis) from a payment key to an address.  Up to the given ' +\n        'amount will be spent, but likely less---the actual amount sent will be the amount given, ' +\n        'minus the transaction fee.  For example, if you want to send 10000 satoshis but the ' +\n        'transaction fee is 2000 satoshis, then the resulting transaction will send 8000 satoshis ' +\n        'to the given address.  This is to ensure that this command does not *over*-spend your ' +\n        'Bitcoin.  If you want to check the amount before spending, pass the `-x` flag to see the ' +\n        'raw transaction.\\n' +\n        '\\n' +\n        'If the command succeeds, it prints out the transaction ID.  You can track its confirmations ' +\n        'with the `get_confirmations` command.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ stx send_btc 18qTSE5PPQmypwKKej7QX5Db2XAttgYeA1 123456 \"$PAYMENT\"\\n' +\n        '    c7e239fd24da30e36e011e6bc7db153574a5b40a3a8dc3b727adb54ad038acc5\\n' +\n        '\\n',\n      group: 'Account Management',\n    },\n    send_tokens: {\n      type: 'array',\n      items: [\n        {\n          name: 'address',\n          type: 'string',\n          realtype: 'address',\n          pattern: STACKS_ADDRESS_PATTERN,\n        },\n        {\n          name: 'amount',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'fee',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'nonce',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'memo',\n          type: 'string',\n          realtype: 'string',\n          pattern: '^.{0,34}$',\n        },\n      ],\n      minItems: 5,\n      maxItems: 6,\n      help:\n        'Send a particular type of tokens to the given `ADDRESS`.  Right now, only supported `TOKEN-TYPE` is `STACKS`.  Optionally ' +\n        'include a memo string (`MEMO`) up to 34 characters long.\\n' +\n        '\\n' +\n        'If the command succeeds, it prints out a transaction ID.  You can track the confirmations on the transaction ' +\n        'via the `get_confirmations` command.  Once the transaction has 7 confirmations, the Blockstack peer network ' +\n        'will have processed it, and your payment key balance and recipient balance will be updated.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # check balances of sender and recipient before sending.\\n' +\n        '    $ # address of the key below is SP2SC16ASH76GX549PT7J5WQZA4GHMFBKYMBQFF9V\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ stx balance SP2SC16ASH76GX549PT7J5WQZA4GHMFBKYMBQFF9V\\n' +\n        '    {\\n' +\n        '      \"STACKS\": \"10000000\"\\n' +\n        '    }\\n' +\n        '    $ stx balance SP1P10PS2T517S4SQGZT5WNX8R00G1ECTRKYCPMHY\\n' +\n        '    {\\n' +\n        '      \"STACKS\": \"0\"\\n' +\n        '    }\\n' +\n        '\\n' +\n        '    $ # send tokens\\n' +\n        '    $ stx send_tokens SP1P10PS2T517S4SQGZT5WNX8R00G1ECTRKYCPMHY 12345 1 0 \"$PAYMENT\"\\n' +\n        '    a9d387a925fb0ba7a725fb1e11f2c3f1647473699dd5a147c312e6453d233456\\n' +\n        '\\n' +\n        '    $ # wait for transaction to be confirmed\\n' +\n        '\\n' +\n        '    $ stx balance SP2SC16ASH76GX549PT7J5WQZA4GHMFBKYMBQFF9V\\n' +\n        '    {\\n' +\n        '      \"STACKS\": \"9987655\"\\n' +\n        '    }\\n' +\n        '    $ stx balance SP1P10PS2T517S4SQGZT5WNX8R00G1ECTRKYCPMHY\\n' +\n        '    {\\n' +\n        '      \"STACKS\": \"12345\"\\n' +\n        '    }\\n' +\n        '\\n',\n      group: 'Account Management',\n    },\n    stack: {\n      type: 'array',\n      items: [\n        {\n          name: 'amount',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'cycles',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'pox_address',\n          type: 'string',\n          realtype: 'integer',\n          pattern: `${ADDRESS_PATTERN}`,\n        },\n        {\n          name: 'private_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'fee',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n        {\n          name: 'nonce',\n          type: 'string',\n          realtype: 'integer',\n          pattern: '^[0-9]+$',\n        },\n      ],\n      minItems: 4,\n      maxItems: 6,\n      help:\n        'Stack the specified number of Stacks tokens for given number of cycles.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx stack 10000000 20 16pm276FpJYpm7Dv3GEaRqTVvGPTdceoY4 136ff26efa5db6f06b28f9c8c7a0216a1a52598045162abfe435d13036154a1b01\\n' +\n        '    {\\n' +\n        '      \"txid\": true\\n' +\n        '    }\\n',\n      group: 'Account Management',\n    },\n    stacking_status: {\n      type: 'array',\n      items: [\n        {\n          name: 'pox_address',\n          type: 'string',\n          realtype: 'integer',\n          pattern: `${STACKS_ADDRESS_PATTERN}`,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Get stacking status for specified address.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx stacking_status SPZY1V53Z4TVRHHW9Z7SFG8CZNRAG7BD8WJ6SXD0\\n',\n      group: 'Account Management',\n    },\n    transfer: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'on-chain-blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n        {\n          name: 'new_id_address',\n          type: 'string',\n          realtype: 'id-address',\n          pattern: ID_ADDRESS_PATTERN,\n        },\n        {\n          name: 'keep_zonefile',\n          type: 'string',\n          realtype: 'true-or-false',\n          pattern: '^true$|^false$',\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 5,\n      maxItems: 5,\n      help:\n        'Transfer a Blockstack ID to a new address (`NEW_ID_ADDRESS`).  Optionally preserve ' +\n        'its zone file (`KEEP_ZONEFILE`).  If the command succeeds, it will print a transaction ID.  ' +\n        'Once the transaction reaches 7 confirmations, the Blockstack peer network will transfer the ' +\n        \"Blockstack ID to the new ID-address.  You can track the transaction's confirmations with \" +\n        'the `get_confirmations` command.\\n' +\n        '\\n' +\n        'NOTE: This command only works for on-chain Blockstack IDs.  It does not yet work for subdomains.\\n' +\n        '\\n' +\n        'An ID-address can only own up to 25 Blockstack IDs.  In practice, you should generate a new ' +\n        'owner key and ID-address for each name you receive (via the `get_owner_keys` command).\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # Tip: you can get your owner key from your backup phrase with \"get_owner_keys\".\\n' +\n        '    $ # Tip: you can get your payment key from your backup phrase with \"get_payment_key\".\\n' +\n        '    $ export OWNER=\"136ff26efa5db6f06b28f9c8c7a0216a1a52598045162abfe435d13036154a1b01\"\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ stx transfer example.id ID-1HJA1AJvWef21XbQVL2AcTv71b6JHGPfDX true \"$OWNER\" \"$PAYMENT\"\\n' +\n        '    e09dc158e586d0c09dbcdcba917ec394e6c6ac2b9c91c4b55f32f5973e4f08fc\\n' +\n        '\\n',\n      group: 'Blockstack ID Management',\n    },\n    tx_preorder: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'on-chain-blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n        {\n          name: 'id_address',\n          type: 'string',\n          realtype: 'id-address',\n          pattern: ID_ADDRESS_PATTERN,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n      ],\n      minItems: 3,\n      maxItems: 3,\n      help:\n        'Generate and send `NAME_PREORDER` transaction, for a Blockstack ID to be owned ' +\n        'by a given `ID_ADDRESS`.  The name cost will be paid for by the gven `PAYMENT_KEY`.  The ' +\n        'ID-address should be a never-before-seen address, since it will be used as a salt when ' +\n        'generating the name preorder hash.\\n' +\n        '\\n' +\n        'This is a low-level command that only experienced Blockstack developers should use.  ' +\n        'If you just want to register a name, use the \"register\" command.\\n',\n      group: 'Blockstack ID Management',\n    },\n    tx_register: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'on-chain-blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n        {\n          name: 'id_address',\n          type: 'string',\n          realtype: 'id-address',\n          pattern: ID_ADDRESS_PATTERN,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'zonefile',\n          type: 'string',\n          realtype: 'path',\n        },\n        {\n          name: 'zonefile_hash',\n          type: 'string',\n          realtype: 'zoenfile_hash',\n          pattern: ZONEFILE_HASH_PATTERN,\n        },\n      ],\n      minItems: 3,\n      maxItems: 5,\n      help:\n        'Generate and send a NAME_REGISTRATION transaction, assigning the given `BLOCKSTACK_ID` ' +\n        'to the given `ID_ADDRESS`.  Optionally pair the Blockstack ID with a zone file (`ZONEFILE`) or ' +\n        'the hash of the zone file (`ZONEFILE_HASH`).  You will need to push the zone file to the peer ' +\n        'network after the transaction confirms (i.e. with `zonefile_push`).\\n' +\n        '\\n' +\n        'This is a low-level command that only experienced Blockstack developers should use.  If you ' +\n        'just want to register a name, you should use the `register` command.',\n      group: 'Blockstack ID Management',\n    },\n    update: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'on-chain-blockstack_id',\n          pattern: NAME_PATTERN,\n        },\n        {\n          name: 'zonefile',\n          type: 'string',\n          realtype: 'path',\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'payment_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN_ANY}`,\n        },\n        {\n          name: 'zonefile_hash',\n          type: 'string',\n          realtype: 'zonefile_hash',\n          pattern: ZONEFILE_HASH_PATTERN,\n        },\n      ],\n      minItems: 4,\n      maxItems: 5,\n      help:\n        'Update the zonefile for an on-chain Blockstack ID.  You can generate a well-formed ' +\n        'zone file using the `make_zonefile` command, or you can supply your own.  Zone files can be ' +\n        'up to 40Kb.  Alternatively, if you only want to announce the hash of a zone file (or any ' +\n        'arbitrary 20-byte hex string), you can do so by passing a value for `ZONEFILE_HASH`.  If `ZONEFILE_HASH` ' +\n        'is given, then the value for `ZONEFILE` will be ignored.\\n' +\n        '\\n' +\n        'If this command succeeds, it prints out a transaction ID.  Once the transaction has 7 confirmations, ' +\n        \"the Blockstack peer network will set the name's zone file hash to the `RIPEMD160`(SHA256) hash of \" +\n        'the given zone file (or it will simply set it to the hash given in `ZONEFILE_HASH`).\\n' +\n        '\\n' +\n        'Once the transaction confirms, you will need to replicate the zone file to the Blockstack peer network.  ' +\n        'This can be done with the `zonefile_push` command.  Until you do so, no Blockstack clients will be able ' +\n        'to obtain the zone file announced by this command.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # Tip: you can get your owner and payment keys from your 12-word backup phrase using the get_owner_keys and get_payment_key commands.\\n' +\n        '    $ export OWNER=\"6e50431b955fe73f079469b24f06480aee44e4519282686433195b3c4b5336ef01\"\\n' +\n        '    $ export PAYMENT=\"bfeffdf57f29b0cc1fab9ea197bb1413da2561fe4b83e962c7f02fbbe2b1cd5401\"\\n' +\n        '    $ # make a new zone file\\n' +\n        '    $ stx make_zonefile example.id ID-1ArdkA2oLaKnbNbLccBaFhEV4pYju8hJ82 https://my.gaia.hub/hub > /tmp/zonefile.txt\\n' +\n        '    \\n' +\n        '    $ # update the name to reference this new zone file\\n' +\n        '    $ stx update example.id /tmp/zonefile.txt \"$OWNER\" \"$PAYMENT\"\\n' +\n        '    8e94a5b6647276727a343713d3213d587836e1322b1e38bc158406f5f8ebe3fd\\n' +\n        '    \\n' +\n        '    $ # check confirmations\\n' +\n        '    $ stx get_confirmations e41ce043ab64fd5a5fd382fba21acba8c1f46cbb1d7c08771ada858ce7d29eea\\n' +\n        '    {\\n' +\n        '      \"blockHeight\": 567890,\\n' +\n        '      \"confirmations\": 7,\\n' +\n        '    }\\n' +\n        '    \\n' +\n        '    $ # send out the new zone file to a Blockstack peer\\n' +\n        '    $ stx -H https://core.blockstack.org zonefile_push /tmp/zonefile.txt\\n' +\n        '    [\\n' +\n        '      \"https://core.blockstack.org\"\\n' +\n        '    ]\\n' +\n        '\\n',\n      group: 'Blockstack ID Management',\n    },\n    whois: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: NAME_PATTERN + '|' + SUBDOMAIN_PATTERN,\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Look up the zone file and owner of a Blockstack ID.  Works with both on-chain and off-chain names.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx whois example.id\\n' +\n        '    {\\n' +\n        '      \"address\": \"1ArdkA2oLaKnbNbLccBaFhEV4pYju8hJ82\",\\n' +\n        '      \"block_renewed_at\": 567890,\\n' +\n        '      \"blockchain\": \"bitcoin\",\\n' +\n        '      \"expire_block\": 687010,\\n' +\n        '      \"grace_period\": false,\\n' +\n        '      \"last_transaction_height\": \"567891\",\\n' +\n        '      \"last_txid\": \"a564aa482ee43eb2bdfb016e01ea3b950bab0cfa39eace627d632e73c7c93e48\",\\n' +\n        '      \"owner_script\": \"76a9146c1c2fc3cf74d900c51e9b5628205130d7b98ae488ac\",\\n' +\n        '      \"renewal_deadline\": 692010,\\n' +\n        '      \"resolver\": null,\\n' +\n        '      \"status\": \"registered\",\\n' +\n        '      \"zonefile\": \"$ORIGIN example.id\\\\n$TTL 3600\\\\n_http._tcp URI 10 1 \\\\\"https://gaia.blockstack.org/hub/1ArdkA2oLaKnbNbLccBaFhEV4pYju8hJ82/profile.json\\\\\"\\\\n\",\\n' +\n        '      \"zonefile_hash\": \"ae4ee8e7f30aa890468164e667e2c203266f726e\"\\n' +\n        '    }\\n' +\n        '\\n',\n      group: 'Querying Blockstack IDs',\n    },\n    zonefile_push: {\n      type: 'array',\n      items: [\n        {\n          name: 'zonefile',\n          type: 'string',\n          realtype: 'path',\n        },\n      ],\n      minItems: 1,\n      maxItems: 1,\n      help:\n        'Push a zone file on disk to the Blockstack peer network.  The zone file must ' +\n        'correspond to a zone file hash that has already been announced.  That is, you use this command ' +\n        'in conjunction with the `register`, `update`, `renew`, or `name_import` commands.\\n' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ stx -H https://core.blockstack.org zonefile_push /path/to/zonefile.txt\\n' +\n        '    [\\n' +\n        '      \"https://core.blockstack.org\"\\n' +\n        '    ]\\n' +\n        '\\n',\n      group: 'Peer Services',\n    },\n    get_did_configuration: {\n      type: 'array',\n      items: [\n        {\n          name: 'blockstack_id',\n          type: 'string',\n          realtype: 'blockstack_id',\n          pattern: NAME_PATTERN + '|' + SUBDOMAIN_PATTERN,\n        },\n        {\n          name: 'domain',\n          type: 'string',\n          realtype: 'domain',\n          pattern: NAME_PATTERN + '|' + SUBDOMAIN_PATTERN,\n        },\n        {\n          name: 'owner_key',\n          type: 'string',\n          realtype: 'private_key',\n          pattern: `${PRIVATE_KEY_PATTERN}`,\n        },\n      ],\n      minItems: 3,\n      maxItems: 3,\n      help:\n        'Creates a DID configuration for the given blockstack id and domain to create a link between both.' +\n        'The specification is define by the Decentralized Identity Foundation at https://identity.foundation/specs/did-configuration/\\n' +\n        'The DID configuration should be placed in the json file \".well_known/did_configuration\"' +\n        '\\n' +\n        'Example:\\n' +\n        '\\n' +\n        '    $ # Tip: you can get your owner keys from your 12-word backup phrase using the get_owner_keys command.\\n' +\n        '    $ export PRIVATE_OWNER_KEY=\"6e50431b955fe73f079469b24f06480aee44e4519282686433195b3c4b5336ef01\"\\n' +\n        '    $ stx get_did_configuration public_profile_for_testing.id.blockstack helloblockstack.com PRIVATE_OWNER_KEY\\n' +\n        '    {\\n' +\n        '       \"entries\": [\\n' +\n        '          {\\n' +\n        '            \"did\": \"did:stack:v0:SewTRvPZUEQGdr45QvEnVMGHZBhx3FT1Jj-0\",\\n' +\n        '            \"jwt\": \"eyJ0eXAiOiJKV1QiL....\"\\n' +\n        '          }\\n' +\n        '       ]\\n' +\n        '    }\\n' +\n        '\\n' +\n        'The decoded content of the jwt above is \\n' +\n        '    {\\n' +\n        '       \"header\": {\\n' +\n        '          \"typ\": \"JWT\", \"alg\": \"ES256K\"\\n' +\n        '       },\\n' +\n        '       \"payload\": {\\n' +\n        '           \"iss\": \"did:stack:v0:SewTRvPZUEQGdr45QvEnVMGHZBhx3FT1Jj-0\",\\n' +\n        '           \"domain\": \"helloblockstack.com\",\\n' +\n        '           \"exp\": \"2020-12-07T13:05:28.375Z\"\\n' +\n        '       },\\n' +\n        '       \"signature\": \"NDY7ISzgAHKcZDvbxzTxQdVnf6xWMZ46w5vHcDpNx_1Fsyip0M6E6GMq_2YZ-gUcwmwlo8Ag9jgnfOkaBIFpoQ\"\\n' +\n        '    }\\n' +\n        '\\n',\n      group: 'DID',\n    },\n  } as CLI_PROP,\n  additionalProperties: false,\n  strict: true,\n};\n\n// usage string for built-in options\nexport const USAGE = `Usage: ${process.argv[1]} [options] command [command arguments]\nOptions can be:\n    -c                  Path to a config file (defaults to\n                        ${DEFAULT_CONFIG_PATH})\n\n    -d                  Print verbose debugging output\n\n    -e                  Estimate the BTC cost of an transaction (in satoshis).\n                        Do not generate or send any transactions.\n\n    -m MAGIC_BYTES      Use an alternative magic byte string instead of \"id\".\n\n    -t                  Use the public testnet instead of mainnet.\n\n    -i                  Use integration test framework instead of mainnet.\n\n    -U                  Unsafe mode.  No safety checks will be performed.\n\n    -x                  Do not broadcast a transaction.  Only generate and\n                        print them to stdout.\n\n    -B BURN_ADDR        Use the given namespace burn address instead of the one\n                        obtained from the Blockstack network (DANGEROUS)\n\n    -D DENOMINATION     Denominate the price to pay in the given units\n                        (DANGEROUS)\n\n    -C CONSENSUS_HASH   Use the given consensus hash instead of one obtained\n                        from the network\n\n    -F FEE_RATE         Use the given transaction fee rate instead of the one\n                        obtained from the Bitcoin network\n\n    -G GRACE_PERIOD     Number of blocks in which a name can be renewed after it\n                        expires (DANGEROUS)\n\n    -H URL              Use an alternative Blockstack Core API endpoint.\n\n    -I URL              Use an alternative Blockstack Core Indexer endpoint.\n\n    -M MAX_INDEX        Maximum keychain index to use when searching for an identity address\n                        (default is ${DEFAULT_MAX_ID_SEARCH_INDEX}).\n\n    -N PAY2NS_PERIOD    Number of blocks in which a namespace receives the registration\n                        and renewal fees after it is created (DANGEROUS)\n\n    -P PRICE            Use the given price to pay for names or namespaces\n                        (DANGEROUS)\n\n    -T URL              Use an alternative Blockstack transaction broadcaster.\n    \n    -X URL              Use an alternative UTXO service endpoint.\n\n    -u USERNAME         A username to be passed to bitcoind RPC endpoints\n\n    -p PASSWORD         A password to be passed to bitcoind RPC endpoints\n`;\n\n/*\n * Format help\n */\nfunction formatHelpString(indent: number, limit: number, helpString: string): string {\n  const lines = helpString.split('\\n');\n  let buf = '';\n  let pad = '';\n  for (let i = 0; i < indent; i++) {\n    pad += ' ';\n  }\n\n  for (let i = 0; i < lines.length; i++) {\n    let linebuf = pad.slice();\n    const words = lines[i].split(/ /).filter(word => word.length > 0);\n    if (words.length == 0) {\n      buf += '\\n';\n      continue;\n    }\n\n    if (words[0] === '$' || lines[i].substring(0, 4) === '    ') {\n      // literal line\n      buf += lines[i] + '\\n';\n      continue;\n    }\n\n    for (let j = 0; j < words.length; j++) {\n      if (words[j].length === 0) {\n        // explicit line break\n        linebuf += '\\n';\n        break;\n      }\n\n      if (linebuf.split('\\n').slice(-1)[0].length + 1 + words[j].length > limit) {\n        linebuf += '\\n';\n        linebuf += pad;\n      }\n      linebuf += words[j] + ' ';\n    }\n\n    buf += linebuf + '\\n';\n  }\n  return buf;\n}\n\n/*\n * Format command usage lines.\n * Generate two strings:\n * raw string:\n *    COMMAND ARG_NAME ARG_NAME ARG_NAME [OPTINONAL ARG NAME]\n * keyword string:\n *    COMMAND --arg_name TYPE\n *            --arg_name TYPE\n *            [--arg_name TYPE]\n */\ninterface CLI_COMMAND_HELP {\n  raw: string;\n  kw: string;\n}\n\nfunction formatCommandHelpLines(\n  commandName: string,\n  commandArgs: Array<CLI_PROP_ITEM>\n): CLI_COMMAND_HELP {\n  let rawUsage = '';\n  let kwUsage = '';\n  let kwPad = '';\n  const commandInfo = CLI_ARGS.properties[commandName];\n\n  rawUsage = `  ${commandName} `;\n  for (let i = 0; i < commandArgs.length; i++) {\n    if (!commandArgs[i].name) {\n      console.log(commandName);\n      console.log(commandArgs[i]);\n      throw new Error('BUG: command info is missing a \"name\" field');\n    }\n    if (i + 1 <= commandInfo.minItems) {\n      rawUsage += `${commandArgs[i].name.toUpperCase()} `;\n    } else {\n      rawUsage += `[${commandArgs[i].name.toUpperCase()}] `;\n    }\n  }\n\n  kwUsage = `  ${commandName} `;\n  for (let i = 0; i < commandName.length + 3; i++) {\n    kwPad += ' ';\n  }\n\n  for (let i = 0; i < commandArgs.length; i++) {\n    if (!commandArgs[i].realtype) {\n      console.log(commandName);\n      console.log(commandArgs[i]);\n      throw new Error('BUG: command info is missing a \"realtype\" field');\n    }\n    if (i + 1 <= commandInfo.minItems) {\n      kwUsage += `--${commandArgs[i].name} ${commandArgs[i].realtype.toUpperCase()}`;\n    } else {\n      kwUsage += `[--${commandArgs[i].name} ${commandArgs[i].realtype.toUpperCase()}]`;\n    }\n    kwUsage += '\\n';\n    kwUsage += kwPad;\n  }\n\n  return { raw: rawUsage, kw: kwUsage } as CLI_COMMAND_HELP;\n}\n\n/*\n * Get the set of commands grouped by command group\n */\ninterface CLI_COMMAND_GROUP_ITEM {\n  command: string;\n  help: string;\n}\n\ninterface CLI_COMMAND_GROUP {\n  [index: string]: CLI_COMMAND_GROUP_ITEM[];\n}\n\nfunction getCommandGroups(): CLI_COMMAND_GROUP {\n  const groups: CLI_COMMAND_GROUP = {};\n  const commands = Object.keys(CLI_ARGS.properties);\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const group = CLI_ARGS.properties[command].group;\n\n    if (!groups.hasOwnProperty(group)) {\n      groups[group] = [\n        {\n          command: command,\n          help: CLI_ARGS.properties[command].help,\n        } as CLI_COMMAND_GROUP_ITEM,\n      ];\n    } else {\n      groups[group].push({\n        command: command,\n        help: CLI_ARGS.properties[command].help,\n      } as CLI_COMMAND_GROUP_ITEM);\n    }\n  }\n  return groups;\n}\n\n/*\n * Make all commands list\n */\nexport function makeAllCommandsList(): string {\n  const groups = getCommandGroups();\n  const groupNames = Object.keys(groups).sort();\n\n  let res = `All commands (run '${process.argv[1]} help COMMAND' for details):\\n`;\n  for (let i = 0; i < groupNames.length; i++) {\n    res += `  ${groupNames[i]}: `;\n    const cmds = [];\n    for (let j = 0; j < groups[groupNames[i]].length; j++) {\n      cmds.push(groups[groupNames[i]][j].command);\n    }\n\n    // wrap at 80 characters\n    const helpLineSpaces = formatHelpString(4, 70, cmds.join(' '));\n    const helpLineCSV =\n      '    ' +\n      helpLineSpaces\n        .split('\\n    ')\n        .map(line => line.trim().replace(/ /g, ', '))\n        .join('\\n    ') +\n      '\\n';\n\n    res += '\\n' + helpLineCSV;\n    res += '\\n';\n  }\n  return res.trim();\n}\n\n/*\n * Make help for all commands\n */\nexport function makeAllCommandsHelp(): string {\n  const groups = getCommandGroups();\n  const groupNames = Object.keys(groups).sort();\n\n  const helps = [];\n  let cmds = [];\n  for (let i = 0; i < groupNames.length; i++) {\n    for (let j = 0; j < groups[groupNames[i]].length; j++) {\n      cmds.push(groups[groupNames[i]][j].command);\n    }\n  }\n\n  cmds = cmds.sort();\n  for (let i = 0; i < cmds.length; i++) {\n    helps.push(makeCommandUsageString(cmds[i]).trim());\n  }\n\n  return helps.join('\\n\\n');\n}\n\n/*\n * Make a usage string for a single command\n */\nexport function makeCommandUsageString(command?: string): string {\n  let res = '';\n  if (command === 'all') {\n    return makeAllCommandsHelp();\n  }\n  if (!command) {\n    return makeAllCommandsList();\n  }\n\n  const commandInfo = CLI_ARGS.properties[command];\n  if (!commandInfo || command === 'help') {\n    return makeAllCommandsList();\n  }\n\n  const help = commandInfo.help;\n\n  const cmdFormat = formatCommandHelpLines(command, commandInfo.items);\n  const formattedHelp = formatHelpString(2, 78, help);\n\n  // make help string for one command\n  res += `Command: ${command}\\n`;\n  res += 'Usage:\\n';\n  res += `${cmdFormat.raw}\\n`;\n  res += `${cmdFormat.kw}\\n`;\n  res += formattedHelp;\n  return res.trim() + '\\n';\n}\n\n/*\n * Make the usage documentation\n */\nexport function makeUsageString(): string {\n  let res = `${USAGE}\\n\\nCommand reference\\n`;\n  const groups = getCommandGroups();\n  const groupNames = Object.keys(groups).sort();\n\n  for (let i = 0; i < groupNames.length; i++) {\n    const groupName = groupNames[i];\n    const groupCommands = groups[groupName];\n\n    res += `Command group: ${groupName}\\n\\n`;\n    for (let j = 0; j < groupCommands.length; j++) {\n      const command = groupCommands[j].command;\n      const help = groupCommands[j].help;\n\n      const commandInfo = CLI_ARGS.properties[command];\n\n      const cmdFormat = formatCommandHelpLines(command, commandInfo.items);\n      const formattedHelp = formatHelpString(4, 76, help);\n\n      res += cmdFormat.raw;\n      res += '\\n';\n      res += cmdFormat.kw;\n      res += '\\n';\n      res += formattedHelp;\n      res += '\\n';\n    }\n    res += '\\n';\n  }\n\n  return res;\n}\n\n/*\n * Print usage\n */\nexport function printUsage() {\n  console.error(makeUsageString());\n}\n\n/*\n * Implement just enough getopt(3) to be useful.\n * Only handles short options.\n * Returns an object whose keys are option flags that map to true/false,\n * or to a value.\n * The key _ is mapped to the non-opts list.\n */\ninterface CLI_OPTS {\n  [index: string]: null | boolean | string | string[];\n}\n\nexport function getCLIOpts(\n  argv: string[],\n  opts: string = 'deitUxC:F:B:P:D:G:N:H:T:I:m:M:X:u:p:'\n): CLI_OPTS {\n  const optsTable: CLI_OPTS = {};\n  const remainingArgv = [];\n  const argvBuff = argv.slice(0);\n\n  for (let i = 0; i < opts.length; i++) {\n    if (opts[i] == ':') {\n      continue;\n    }\n    if (i + 1 < opts.length && opts[i + 1] == ':') {\n      optsTable[opts[i]] = null;\n    } else {\n      optsTable[opts[i]] = false;\n    }\n  }\n\n  for (const opt of Object.keys(optsTable)) {\n    for (let i = 0; i < argvBuff.length; i++) {\n      if (argvBuff[i] === null) {\n        break;\n      }\n      if (argvBuff[i] === '--') {\n        break;\n      }\n\n      const argvOpt = `-${opt}`;\n      if (argvOpt === argvBuff[i]) {\n        if (optsTable[opt] === false) {\n          // boolean switch\n          optsTable[opt] = true;\n          argvBuff[i] = '';\n        } else {\n          // argument\n          optsTable[opt] = argvBuff[i + 1];\n          argvBuff[i] = '';\n          argvBuff[i + 1] = '';\n        }\n      }\n    }\n  }\n\n  for (let i = 0; i < argvBuff.length; i++) {\n    if (argvBuff[i].length > 0) {\n      if (argvBuff[i] === '--') {\n        continue;\n      }\n      remainingArgv.push(argvBuff[i]);\n    }\n  }\n\n  optsTable['_'] = remainingArgv;\n  return optsTable;\n}\n\nexport function CLIOptAsString(opts: CLI_OPTS, key: string): string | null {\n  if (opts[key] === null || opts[key] === undefined) {\n    return null;\n  } else if (typeof opts[key] === 'string') {\n    return `${opts[key]}`;\n  } else {\n    throw new Error(`Option '${key}' is not a string`);\n  }\n}\n\nexport function CLIOptAsBool(opts: CLI_OPTS, key: string): boolean {\n  if (typeof opts[key] === 'boolean' || opts[key] === null) {\n    return !!opts[key];\n  } else {\n    throw new Error(`Option '${key}' is not a boolean`);\n  }\n}\n\nfunction isStringArray(value: any): value is string[] {\n  if (value instanceof Array) {\n    return value\n      .map((s: any) => typeof s === 'string')\n      .reduce((x: boolean, y: boolean) => x && y, true);\n  } else {\n    return false;\n  }\n}\n\nexport function CLIOptAsStringArray(opts: CLI_OPTS, key: string): string[] | null {\n  const value: any = opts[key];\n  if (value === null || value === undefined) {\n    return null;\n  } else if (isStringArray(value)) {\n    return value;\n  } else {\n    throw new Error(`Option '${key}' is not a string array`);\n  }\n}\n\n/*\n * Use the CLI schema to get all positional and keyword args\n * for a given command.\n */\nexport function getCommandArgs(command: string, argsList: Array<string>) {\n  let commandProps = CLI_ARGS.properties[command].items;\n  if (!Array.isArray(commandProps)) {\n    commandProps = [commandProps];\n  }\n\n  const orderedArgs = [];\n  const foundArgs: Record<string, string> = {};\n\n  // scan for keywords\n  for (let i = 0; i < argsList.length; i++) {\n    if (argsList[i].startsWith('--')) {\n      // keyword argument\n      const argName = argsList[i].slice(2);\n      let argValue = null;\n\n      // dup?\n      if (foundArgs.hasOwnProperty(argName)) {\n        return {\n          status: false,\n          error: `duplicate argument ${argsList[i]}`,\n        };\n      }\n\n      for (let j = 0; j < commandProps.length; j++) {\n        if (!commandProps[j].hasOwnProperty('name')) {\n          continue;\n        }\n        if (commandProps[j].name === argName) {\n          // found!\n          // end of args?\n          if (i + 1 >= argsList.length) {\n            return {\n              status: false,\n              error: `no value for argument ${argsList[i]}`,\n            };\n          }\n\n          argValue = argsList[i + 1];\n        }\n      }\n\n      if (argValue) {\n        // found an argument given as a keyword\n        i += 1;\n        foundArgs[argName] = argValue;\n      } else {\n        return {\n          status: false,\n          error: `no such argument ${argsList[i]}`,\n        };\n      }\n    } else {\n      // positional argument\n      orderedArgs.push(argsList[i]);\n    }\n  }\n\n  // merge foundArgs and orderedArgs back into an ordered argument list\n  // that is conformant to the CLI specification.\n  const mergedArgs = [];\n  let orderedArgIndex = 0;\n\n  for (let i = 0; i < commandProps.length; i++) {\n    if (orderedArgIndex < orderedArgs.length) {\n      if (!commandProps[i].hasOwnProperty('name')) {\n        // unnamed positional argument\n        mergedArgs.push(orderedArgs[orderedArgIndex]);\n        orderedArgIndex += 1;\n      } else if (!foundArgs.hasOwnProperty(commandProps[i].name)) {\n        // named positional argument, NOT given as a keyword\n        mergedArgs.push(orderedArgs[orderedArgIndex]);\n        orderedArgIndex += 1;\n      } else {\n        // keyword argument\n        mergedArgs.push(foundArgs[commandProps[i].name]);\n      }\n    } else {\n      // keyword argument (possibly undefined)\n      mergedArgs.push(foundArgs[commandProps[i].name]);\n    }\n  }\n\n  return {\n    status: true,\n    arguments: mergedArgs,\n  };\n}\n\n/*\n * Check command args\n */\nexport interface CheckArgsSuccessType {\n  success: true;\n  command: string;\n  args: Array<string>;\n}\n\nexport interface CheckArgsFailType {\n  success: false;\n  error: string;\n  command: string;\n  usage: boolean;\n}\n\nexport function checkArgs(argList: Array<string>): CheckArgsSuccessType | CheckArgsFailType {\n  if (argList.length <= 2) {\n    return {\n      success: false,\n      error: 'No command given',\n      usage: true,\n      command: '',\n    };\n  }\n\n  const commandName = argList[2];\n  const allCommandArgs = argList.slice(3);\n\n  if (!CLI_ARGS.properties.hasOwnProperty(commandName)) {\n    return {\n      success: false,\n      error: `Unrecognized command '${commandName}'`,\n      usage: true,\n      command: commandName,\n    };\n  }\n\n  const parsedCommandArgs = getCommandArgs(commandName, allCommandArgs);\n  if (!parsedCommandArgs.status) {\n    return {\n      success: false,\n      error: parsedCommandArgs.error!,\n      usage: true,\n      command: commandName,\n    };\n  }\n\n  const commandArgs = parsedCommandArgs.arguments;\n\n  // validate all required commands as given.\n  // if there are optional commands, then only validate\n  // them if they're given.\n  const commandSchema = JSON.parse(JSON.stringify(CLI_ARGS.properties[commandName]));\n  for (let i = commandSchema.minItems; i < commandSchema.maxItems; i++) {\n    if (i < commandArgs!.length) {\n      if (commandArgs![i] === null || commandArgs![i] === undefined) {\n        // optional argument not given.  Update the schema we're checking against\n        // to expect this.\n        // @ts-ignore\n        commandArgs[i] = null;\n        commandSchema.items[i] = { type: 'null' };\n      }\n    }\n  }\n\n  const ajv = Ajv();\n  const valid = ajv.validate(commandSchema, commandArgs);\n  if (!valid) {\n    let errorMsg = '';\n    for (let i = 0; i < ajv.errors!.length; i++) {\n      const msg = `Invalid command arguments: Schema \"${\n        ajv.errors![0].schemaPath\n      }\" failed validation (problem: \"${ajv.errors![0].message}\", cause: \"${JSON.stringify(\n        ajv.errors![0].params\n      )}\")\\n`;\n      errorMsg += msg;\n    }\n    return {\n      success: false,\n      error: errorMsg,\n      usage: true,\n      command: commandName,\n    };\n  }\n\n  return {\n    success: true,\n    command: commandName,\n    args: commandArgs!,\n  };\n}\n\n/**\n * Load the config file and return a config dict.\n * If no config file exists, then return the default config.\n *\n * @configPath (string) the path to the config file.\n * @networkType (sring) 'mainnet', 'regtest', or 'testnet'\n */\nexport function loadConfig(configFile: string, networkType: string): CLI_CONFIG_TYPE {\n  if (networkType !== 'mainnet' && networkType !== 'testnet' && networkType != 'regtest') {\n    throw new Error('Unregognized network');\n  }\n\n  let configRet: CLI_CONFIG_TYPE;\n\n  if (networkType === 'mainnet') {\n    configRet = Object.assign({}, CONFIG_DEFAULTS);\n  } else if (networkType === 'regtest') {\n    configRet = Object.assign({}, CONFIG_REGTEST_DEFAULTS);\n  } else {\n    configRet = Object.assign({}, CONFIG_TESTNET_DEFAULTS);\n  }\n\n  try {\n    configRet = JSON.parse(fs.readFileSync(configFile).toString()) as CLI_CONFIG_TYPE;\n  } catch (e) {}\n\n  return configRet;\n}\n","import * as blockstack from 'blockstack';\n\nexport function encryptBackupPhrase(plaintextBuffer: string, password: string): Promise<Buffer> {\n  return blockstack.encryptMnemonic(plaintextBuffer, password);\n}\n\nexport function decryptBackupPhrase(\n  dataBuffer: string | Buffer,\n  password: string\n): Promise<string> {\n  return blockstack.decryptMnemonic(dataBuffer, password);\n}\n","import * as logger from 'winston';\nimport * as bitcoinjs from 'bitcoinjs-lib';\nimport * as URL from 'url';\nimport * as readline from 'readline';\nimport * as stream from 'stream';\nimport * as fs from 'fs';\nimport * as blockstack from 'blockstack';\nimport { TokenSigner } from 'jsontokens';\nimport {\n  getTypeString,\n  ClarityAbiType,\n  isClarityAbiPrimitive,\n  isClarityAbiBuffer,\n  isClarityAbiResponse,\n  isClarityAbiOptional,\n  isClarityAbiTuple,\n  isClarityAbiList,\n  ClarityValue,\n  intCV,\n  uintCV,\n  bufferCVFromString,\n  trueCV,\n  falseCV,\n  standardPrincipalCV,\n  TransactionVersion,\n} from '@stacks/transactions';\n\nimport { StacksNetwork } from '@stacks/network';\n\nconst ZoneFile = require('zone-file');\n\nimport {\n  PRIVATE_KEY_NOSIGN_PATTERN,\n  PRIVATE_KEY_PATTERN,\n  PRIVATE_KEY_MULTISIG_PATTERN,\n  PRIVATE_KEY_SEGWIT_P2SH_PATTERN,\n  ID_ADDRESS_PATTERN,\n} from './argparse';\n\nimport { TransactionSigner } from 'blockstack';\n\nimport { decryptBackupPhrase } from './encrypt';\n\nimport { getOwnerKeyInfo, getApplicationKeyInfo, extractAppKey } from './keys';\n\nimport { NameInfoType, CLINetworkAdapter } from './network';\n\nexport interface UTXO {\n  value?: number;\n  confirmations?: number;\n  tx_hash: string;\n  tx_output_n: number;\n}\n\nclass CLITransactionSigner implements TransactionSigner {\n  address: string;\n  isComplete: boolean;\n\n  constructor(address = '') {\n    this.address = address;\n    this.isComplete = false;\n  }\n\n  getAddress(): Promise<string> {\n    return Promise.resolve().then(() => this.address);\n  }\n\n  signTransaction(_txIn: bitcoinjs.TransactionBuilder, _signingIndex: number): Promise<void> {\n    return Promise.resolve().then(() => {});\n  }\n\n  signerVersion(): number {\n    return 0;\n  }\n}\n\nexport class NullSigner extends CLITransactionSigner {}\n\nexport class MultiSigKeySigner extends CLITransactionSigner {\n  redeemScript: Buffer;\n  privateKeys: string[];\n  m: number;\n\n  constructor(redeemScript: string, privateKeys: string[]) {\n    super();\n    this.redeemScript = Buffer.from(redeemScript, 'hex');\n    this.privateKeys = privateKeys;\n    this.isComplete = true;\n    try {\n      // try to deduce m (as in m-of-n)\n      const chunks = bitcoinjs.script.decompile(this.redeemScript);\n      const firstOp = chunks![0];\n      this.m = parseInt(bitcoinjs.script.toASM([firstOp]).slice(3), 10);\n      this.address = bitcoinjs.address.toBase58Check(\n        bitcoinjs.crypto.hash160(this.redeemScript),\n        blockstack.config.network.layer1.scriptHash\n      );\n    } catch (e) {\n      logger.error(e);\n      throw new Error('Improper redeem script for multi-sig input.');\n    }\n  }\n\n  getAddress(): Promise<string> {\n    return Promise.resolve().then(() => this.address);\n  }\n\n  signTransaction(txIn: bitcoinjs.TransactionBuilder, signingIndex: number): Promise<void> {\n    return Promise.resolve().then(() => {\n      const keysToUse = this.privateKeys.slice(0, this.m);\n      keysToUse.forEach(keyHex => {\n        const ecPair = blockstack.hexStringToECPair(keyHex);\n        txIn.sign(signingIndex, ecPair, this.redeemScript);\n      });\n    });\n  }\n\n  signerVersion(): number {\n    return 0;\n  }\n}\n\nexport class SegwitP2SHKeySigner extends CLITransactionSigner {\n  redeemScript: Buffer;\n  witnessScript: Buffer;\n  privateKeys: string[];\n  m: number;\n\n  constructor(redeemScript: string, witnessScript: string, m: number, privateKeys: string[]) {\n    super();\n    this.redeemScript = Buffer.from(redeemScript, 'hex');\n    this.witnessScript = Buffer.from(witnessScript, 'hex');\n    this.address = bitcoinjs.address.toBase58Check(\n      bitcoinjs.crypto.hash160(this.redeemScript),\n      blockstack.config.network.layer1.scriptHash\n    );\n\n    this.privateKeys = privateKeys;\n    this.m = m;\n    this.isComplete = true;\n  }\n\n  getAddress(): Promise<string> {\n    return Promise.resolve().then(() => this.address);\n  }\n\n  findUTXO(txIn: bitcoinjs.TransactionBuilder, signingIndex: number, utxos: UTXO[]): UTXO {\n    // NOTE: this is O(n*2) complexity for n UTXOs when signing an n-input transaction\n    // NOTE: as of bitcoinjs-lib 4.x, the \"tx\" field is private\n    const private_tx = (txIn as any).__TX;\n    const txidBuf = new Buffer(private_tx.ins[signingIndex].hash.slice());\n    const outpoint = private_tx.ins[signingIndex].index;\n\n    txidBuf.reverse(); // NOTE: bitcoinjs encodes txid as big-endian\n    const txid = txidBuf.toString('hex');\n\n    for (let i = 0; i < utxos.length; i++) {\n      if (utxos[i].tx_hash === txid && utxos[i].tx_output_n === outpoint) {\n        if (!utxos[i].value) {\n          throw new Error(`UTXO for hash=${txid} vout=${outpoint} has no value`);\n        }\n        return utxos[i];\n      }\n    }\n    throw new Error(`No UTXO for input hash=${txid} vout=${outpoint}`);\n  }\n\n  signTransaction(txIn: bitcoinjs.TransactionBuilder, signingIndex: number): Promise<void> {\n    // This is an interface issue more than anything else.  Basically, in order to\n    // form the segwit sighash, we need the UTXOs.  If we knew better, we would have\n    // blockstack.js simply pass the consumed UTXO into this method.  But alas, we do\n    // not.  Therefore, we need to re-query them.  This is probably fine, since we're\n    // not pressured for time when it comes to generating transactions.\n    return Promise.resolve()\n      .then(() => {\n        return this.getAddress();\n      })\n      .then(address => {\n        return blockstack.config.network.getUTXOs(address);\n      })\n      .then(utxos => {\n        const utxo = this.findUTXO(txIn, signingIndex, utxos);\n        if (this.m === 1) {\n          // p2sh-p2wpkh\n          const ecPair = blockstack.hexStringToECPair(this.privateKeys[0]);\n          txIn.sign(signingIndex, ecPair, this.redeemScript, undefined, utxo.value);\n        } else {\n          // p2sh-p2wsh\n          const keysToUse = this.privateKeys.slice(0, this.m);\n          keysToUse.forEach(keyHex => {\n            const ecPair = blockstack.hexStringToECPair(keyHex);\n            txIn.sign(\n              signingIndex,\n              ecPair,\n              this.redeemScript,\n              undefined,\n              utxo.value,\n              this.witnessScript\n            );\n          });\n        }\n      });\n  }\n\n  signerVersion(): number {\n    return 0;\n  }\n}\n\nexport class SafetyError extends Error {\n  safetyErrors: AnyJson;\n  constructor(safetyErrors: AnyJson) {\n    super(JSONStringify(safetyErrors, true));\n    this.safetyErrors = safetyErrors;\n  }\n}\n\nfunction isCLITransactionSigner(\n  signer: string | CLITransactionSigner\n): signer is CLITransactionSigner {\n  return (signer as CLITransactionSigner).signerVersion !== undefined;\n}\n\nexport function hasKeys(signer: string | CLITransactionSigner): boolean {\n  if (isCLITransactionSigner(signer)) {\n    const s = signer as CLITransactionSigner;\n    return s.isComplete;\n  } else {\n    return true;\n  }\n}\n\n/*\n * Parse a string into a NullSigner\n * The string has the format \"nosign:address\"\n * @return a NullSigner instance\n */\nexport function parseNullSigner(addrString: string): NullSigner {\n  if (!addrString.startsWith('nosign:')) {\n    throw new Error('Invalid nosign string');\n  }\n\n  const addr = addrString.slice('nosign:'.length);\n  return new NullSigner(addr);\n}\n\n/*\n * Parse a string into a MultiSigKeySigner.\n * The string has the format \"m,pk1,pk2,...,pkn\"\n * @serializedPrivateKeys (string) the above string\n * @return a MultiSigKeySigner instance\n */\nexport function parseMultiSigKeys(serializedPrivateKeys: string): MultiSigKeySigner {\n  const matches = serializedPrivateKeys.match(PRIVATE_KEY_MULTISIG_PATTERN);\n  if (!matches) {\n    throw new Error('Invalid multisig private key string');\n  }\n\n  const m = parseInt(matches[1]);\n  const parts = serializedPrivateKeys.split(',');\n  const privkeys = [];\n  for (let i = 1; i < 256; i++) {\n    const pk = parts[i];\n    if (!pk) {\n      break;\n    }\n\n    if (!pk.match(PRIVATE_KEY_PATTERN)) {\n      throw new Error('Invalid private key string');\n    }\n\n    privkeys.push(pk);\n  }\n\n  // generate public keys\n  const pubkeys = privkeys.map(pk => {\n    return Buffer.from(getPublicKeyFromPrivateKey(pk), 'hex');\n  });\n\n  // generate redeem script\n  const multisigInfo = bitcoinjs.payments.p2ms({ m, pubkeys });\n  return new MultiSigKeySigner(multisigInfo.output!.toString('hex'), privkeys);\n}\n\n/*\n * Parse a string into a SegwitP2SHKeySigner\n * The string has the format \"segwit:p2sh:m,pk1,pk2,...,pkn\"\n * @serializedPrivateKeys (string) the above string\n * @return a MultiSigKeySigner instance\n */\nexport function parseSegwitP2SHKeys(serializedPrivateKeys: string): SegwitP2SHKeySigner {\n  const matches = serializedPrivateKeys.match(PRIVATE_KEY_SEGWIT_P2SH_PATTERN);\n  if (!matches) {\n    throw new Error('Invalid segwit p2sh private key string');\n  }\n\n  const m = parseInt(matches[1]);\n  const parts = serializedPrivateKeys.split(',');\n  const privkeys = [];\n  for (let i = 1; i < 256; i++) {\n    const pk = parts[i];\n    if (!pk) {\n      break;\n    }\n\n    if (!pk.match(PRIVATE_KEY_PATTERN)) {\n      throw new Error('Invalid private key string');\n    }\n\n    privkeys.push(pk);\n  }\n\n  // generate public keys\n  const pubkeys = privkeys.map(pk => {\n    return Buffer.from(getPublicKeyFromPrivateKey(pk), 'hex');\n  });\n\n  // generate redeem script for p2wpkh or p2sh, depending on how many keys\n  let redeemScript: string;\n  let witnessScript = '';\n  if (m === 1) {\n    // p2wpkh\n    const p2wpkh = bitcoinjs.payments.p2wpkh({ pubkey: pubkeys[0] });\n    const p2sh = bitcoinjs.payments.p2sh({ redeem: p2wpkh });\n\n    redeemScript = p2sh.redeem!.output!.toString('hex');\n  } else {\n    // p2wsh\n    const p2ms = bitcoinjs.payments.p2ms({ m, pubkeys });\n    const p2wsh = bitcoinjs.payments.p2wsh({ redeem: p2ms });\n    const p2sh = bitcoinjs.payments.p2sh({ redeem: p2wsh });\n\n    redeemScript = p2sh.redeem!.output!.toString('hex');\n    witnessScript = p2wsh.redeem!.output!.toString('hex');\n  }\n\n  return new SegwitP2SHKeySigner(redeemScript, witnessScript, m, privkeys);\n}\n\n/*\n * Decode one or more private keys from a string.\n * Can be used to parse single private keys (as strings),\n * or multisig bundles (as CLITransactionSigners)\n * @serializedPrivateKey (string) the private key, encoded\n * @return a CLITransactionSigner or a String\n */\nexport function decodePrivateKey(serializedPrivateKey: string): string | CLITransactionSigner {\n  const nosignMatches = serializedPrivateKey.match(PRIVATE_KEY_NOSIGN_PATTERN);\n  if (!!nosignMatches) {\n    // no private key\n    return parseNullSigner(serializedPrivateKey);\n  }\n\n  const singleKeyMatches = serializedPrivateKey.match(PRIVATE_KEY_PATTERN);\n  if (!!singleKeyMatches) {\n    // one private key\n    return serializedPrivateKey;\n  }\n\n  const multiKeyMatches = serializedPrivateKey.match(PRIVATE_KEY_MULTISIG_PATTERN);\n  if (!!multiKeyMatches) {\n    // multisig bundle\n    return parseMultiSigKeys(serializedPrivateKey);\n  }\n\n  const segwitP2SHMatches = serializedPrivateKey.match(PRIVATE_KEY_SEGWIT_P2SH_PATTERN);\n  if (!!segwitP2SHMatches) {\n    // segwit p2sh bundle\n    return parseSegwitP2SHKeys(serializedPrivateKey);\n  }\n\n  throw new Error('Unparseable private key');\n}\n\ntype AnyJson = string | number | boolean | null | { [property: string]: AnyJson } | AnyJson[];\n\n/*\n * JSON stringify helper\n * -- if stdout is a TTY, then pretty-format the JSON\n * -- otherwise, print it all on one line to make it easy for programs to consume\n */\nexport function JSONStringify(obj: AnyJson, stderr: boolean = false): string {\n  if ((!stderr && process.stdout.isTTY) || (stderr && process.stderr.isTTY)) {\n    return JSON.stringify(obj, null, 2);\n  } else {\n    return JSON.stringify(obj);\n  }\n}\n\n/*\n * Get a private key's public key, while honoring the 01 to compress it.\n * @privateKey (string) the hex-encoded private key\n */\nexport function getPublicKeyFromPrivateKey(privateKey: string): string {\n  const ecKeyPair = blockstack.hexStringToECPair(privateKey);\n  return ecKeyPair.publicKey.toString('hex');\n}\n\n/*\n * Get a private key's address.  Honor the 01 to compress the public key\n * @privateKey (string) the hex-encoded private key\n */\nexport function getPrivateKeyAddress(\n  network: CLINetworkAdapter,\n  privateKey: string | CLITransactionSigner\n): string {\n  if (isCLITransactionSigner(privateKey)) {\n    const pkts = privateKey as CLITransactionSigner;\n    return pkts.address;\n  } else {\n    const pk = privateKey as string;\n    const ecKeyPair = blockstack.hexStringToECPair(pk);\n    return network.coerceAddress(blockstack.ecPairToAddress(ecKeyPair));\n  }\n}\n\n/*\n * Is a name a sponsored name (a subdomain)?\n */\nexport function isSubdomain(name: string): boolean {\n  return !!name.match(/^[^\\.]+\\.[^.]+\\.[^.]+$/);\n}\n\n/*\n * Get the canonical form of a hex-encoded private key\n * (i.e. strip the trailing '01' if present)\n */\nexport function canonicalPrivateKey(privkey: string): string {\n  if (privkey.length == 66 && privkey.slice(-2) === '01') {\n    return privkey.substring(0, 64);\n  }\n  return privkey;\n}\n\n/*\n * Get the sum of a set of UTXOs' values\n * @txIn (object) the transaction\n */\nexport function sumUTXOs(utxos: UTXO[]): number {\n  return utxos.reduce((agg, x) => agg + x.value!, 0);\n}\n\n/*\n * Hash160 function for zone files\n */\nexport function hash160(buff: Buffer): Buffer {\n  return bitcoinjs.crypto.hash160(buff);\n}\n\n/*\n * Normalize a URL--remove duplicate /'s from the root of the path.\n * Throw an exception if it's not well-formed.\n */\nexport function checkUrl(url: string): string {\n  const urlinfo = URL.parse(url);\n  if (!urlinfo.protocol) {\n    throw new Error(`Malformed full URL: missing scheme in ${url}`);\n  }\n\n  if (!urlinfo.path || urlinfo.path.startsWith('//')) {\n    throw new Error(`Malformed full URL: path root has multiple /'s: ${url}`);\n  }\n\n  return url;\n}\n\n/*\n * Sign a profile into a JWT\n */\nexport function makeProfileJWT(profileData: Object, privateKey: string): string {\n  const signedToken = blockstack.signProfileToken(profileData, privateKey);\n  const wrappedToken = blockstack.wrapProfileToken(signedToken);\n  const tokenRecords = [wrappedToken];\n  return JSONStringify((tokenRecords as unknown) as AnyJson);\n}\n\nexport async function makeDIDConfiguration(\n  network: CLINetworkAdapter,\n  blockstackID: string,\n  domain: string,\n  privateKey: string\n): Promise<{ entries: { did: string; jwt: string }[] }> {\n  const tokenSigner = new TokenSigner('ES256K', privateKey);\n  const nameInfo = await network.getNameInfo(blockstackID);\n  const did = nameInfo.did!;\n  const payload = {\n    iss: did,\n    domain,\n    exp: new Date(new Date().setFullYear(new Date().getFullYear() + 1)),\n  };\n\n  const jwt = tokenSigner.sign(payload);\n  return {\n    entries: [\n      {\n        did,\n        jwt,\n      },\n    ],\n  };\n}\n/*\n * Broadcast a transaction and a zone file.\n * Returns an object that encodes the success/failure of doing so.\n * If zonefile is None, then only the transaction will be sent.\n */\nexport async function broadcastTransactionAndZoneFile(\n  network: CLINetworkAdapter,\n  tx: string,\n  zonefile?: string\n) {\n  let txid: string;\n  return Promise.resolve()\n    .then(() => {\n      return network.broadcastTransaction(tx);\n    })\n    .then((_txid: string) => {\n      txid = _txid;\n      if (zonefile) {\n        return network.broadcastZoneFile(zonefile, txid);\n      } else {\n        return { status: true };\n      }\n    })\n    .then(resp => {\n      if (!resp.status) {\n        return {\n          status: false,\n          error: 'Failed to broadcast zone file',\n          txid: txid,\n        };\n      } else {\n        return {\n          status: true,\n          txid: txid,\n        };\n      }\n    })\n    .catch(e => {\n      return {\n        status: false,\n        error: 'Caught exception sending transaction or zone file',\n        message: e.message,\n        stacktrace: e.stack,\n      };\n    });\n}\n\n/*\n * Easier-to-use getNameInfo.  Returns null if the name does not exist.\n */\nexport function getNameInfoEasy(\n  network: CLINetworkAdapter,\n  name: string\n): Promise<NameInfoType | null> {\n  const nameInfoPromise = network\n    .getNameInfo(name)\n    .then((nameInfo: NameInfoType) => nameInfo)\n    .catch((error: Error): null => {\n      if (error.message === 'Name not found') {\n        return null;\n      } else {\n        throw error;\n      }\n    });\n\n  return nameInfoPromise;\n}\n\n/*\n * Look up a name's zone file, profile URL, and profile\n * Returns a Promise to the above, or throws an error.\n */\nexport async function nameLookup(\n  network: CLINetworkAdapter,\n  name: string,\n  includeProfile: boolean = true\n): Promise<{ profile: any; profileUrl?: string; zonefile?: string }> {\n  const nameInfoPromise = getNameInfoEasy(network, name);\n  const profilePromise = includeProfile\n    ? blockstack.lookupProfile(name).catch(() => null)\n    : Promise.resolve().then(() => null);\n\n  const zonefilePromise = nameInfoPromise.then((nameInfo: NameInfoType | null) =>\n    nameInfo ? nameInfo.zonefile : null\n  );\n\n  const [profile, zonefile, nameInfo] = await Promise.all([\n    profilePromise,\n    zonefilePromise,\n    nameInfoPromise,\n  ]);\n  let profileObj = profile;\n\n  if (!nameInfo) {\n    throw new Error('Name not found');\n  }\n  if (nameInfo.hasOwnProperty('grace_period') && nameInfo.grace_period) {\n    throw new Error(\n      `Name is expired at block ${nameInfo.expire_block} ` +\n        `and must be renewed by block ${nameInfo.renewal_deadline}`\n    );\n  }\n\n  let profileUrl = null;\n  try {\n    const zonefileJSON = ZoneFile.parseZoneFile(zonefile);\n    if (zonefileJSON.uri && zonefileJSON.hasOwnProperty('$origin')) {\n      profileUrl = blockstack.getTokenFileUrl(zonefileJSON);\n    }\n  } catch (e) {\n    profileObj = null;\n  }\n\n  const ret = {\n    zonefile: zonefile,\n    profile: profileObj,\n    profileUrl: profileUrl,\n  };\n  // @ts-ignore\n  return ret;\n}\n\n/*\n * Get a password.  Don't echo characters to stdout.\n * Password will be passed to the given callback.\n */\nexport function getpass(promptStr: string, cb: (passwd: string) => void) {\n  const silentOutput = new stream.Writable({\n    write: (_chunk, _encoding, callback) => {\n      callback();\n    },\n  });\n\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: silentOutput,\n    terminal: true,\n  });\n\n  process.stderr.write(promptStr);\n  rl.question('', passwd => {\n    rl.close();\n    process.stderr.write('\\n');\n    cb(passwd);\n  });\n\n  return;\n}\n\n/*\n * Extract a 12-word backup phrase.  If the raw 12-word phrase is given, it will\n * be returned.  If the ciphertext is given, the user will be prompted for a password\n * (if a password is not given as an argument).\n */\nexport async function getBackupPhrase(\n  backupPhraseOrCiphertext: string,\n  password?: string\n): Promise<string> {\n  if (backupPhraseOrCiphertext.split(/ +/g).length > 1) {\n    // raw backup phrase\n    return backupPhraseOrCiphertext;\n  } else {\n    // ciphertext\n    const pass: string = await new Promise((resolve, reject) => {\n      if (!process.stdin.isTTY && !password) {\n        // password must be given\n        reject(new Error('Password argument required in non-interactive mode'));\n      } else {\n        // prompt password\n        getpass('Enter password: ', p => {\n          resolve(p);\n        });\n      }\n    });\n    return await decryptBackupPhrase(Buffer.from(backupPhraseOrCiphertext, 'base64'), pass);\n  }\n}\n\n/*\n * mkdir -p\n * path must be absolute\n */\nexport function mkdirs(path: string): void {\n  if (path.length === 0 || path[0] !== '/') {\n    throw new Error('Path must be absolute');\n  }\n\n  const pathParts = path.replace(/^\\//, '').split('/');\n  let tmpPath = '/';\n  for (let i = 0; i <= pathParts.length; i++) {\n    try {\n      const statInfo = fs.lstatSync(tmpPath);\n      if ((statInfo.mode & fs.constants.S_IFDIR) === 0) {\n        throw new Error(`Not a directory: ${tmpPath}`);\n      }\n    } catch (e) {\n      if (e.code === 'ENOENT') {\n        // need to create\n        fs.mkdirSync(tmpPath);\n      } else {\n        throw e;\n      }\n    }\n    if (i === pathParts.length) {\n      break;\n    }\n    tmpPath = `${tmpPath}/${pathParts[i]}`;\n  }\n}\n\n/*\n * Given a name or ID address, return a promise to the ID Address\n */\nexport async function getIDAddress(\n  network: CLINetworkAdapter,\n  nameOrIDAddress: string\n): Promise<string> {\n  if (nameOrIDAddress.match(ID_ADDRESS_PATTERN)) {\n    return nameOrIDAddress;\n  } else {\n    // need to look it up\n    const nameInfo = await network.getNameInfo(nameOrIDAddress);\n    return `ID-${nameInfo.address}`;\n  }\n}\n\n/*\n * Find all identity addresses until we have one that matches the given one.\n * Loops forever if not found\n */\nexport async function getOwnerKeyFromIDAddress(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  idAddress: string\n): Promise<string> {\n  let index = 0;\n  while (true) {\n    const keyInfo = await getOwnerKeyInfo(network, mnemonic, index);\n    if (keyInfo.idAddress === idAddress) {\n      return keyInfo.privateKey;\n    }\n    index++;\n  }\n}\n\n/*\n * Given a name or an ID address and a possibly-encrypted mnemonic, get the owner and app\n * private keys.\n * May prompt for a password if mnemonic is encrypted.\n */\nexport interface IDAppKeys {\n  ownerPrivateKey: string;\n  appPrivateKey: string;\n  mnemonic: string;\n}\n\nexport async function getIDAppKeys(\n  network: CLINetworkAdapter,\n  nameOrIDAddress: string,\n  appOrigin: string,\n  mnemonicOrCiphertext: string\n): Promise<IDAppKeys> {\n  const mnemonic = await getBackupPhrase(mnemonicOrCiphertext);\n  const idAddress = await getIDAddress(network, nameOrIDAddress);\n  const appKeyInfo = await getApplicationKeyInfo(network, mnemonic, idAddress, appOrigin);\n  const appPrivateKey = extractAppKey(network, appKeyInfo);\n  const ownerPrivateKey = await getOwnerKeyFromIDAddress(network, mnemonic, idAddress);\n  const ret = {\n    appPrivateKey,\n    ownerPrivateKey,\n    mnemonic,\n  };\n  return ret;\n}\n\ninterface InquirerPrompt {\n  type: string;\n  name: string;\n  message: string;\n  choices?: string[];\n}\n\nexport function makePromptsFromArgList(expectedArgs: ClarityFunctionArg[]): InquirerPrompt[] {\n  const prompts = [];\n  for (let i = 0; i < expectedArgs.length; i++) {\n    prompts.push(argToPrompt(expectedArgs[i]));\n  }\n  return prompts;\n}\n\nexport interface ClarityFunctionArg {\n  name: string;\n  type: ClarityAbiType;\n}\n\nexport function argToPrompt(arg: ClarityFunctionArg): InquirerPrompt {\n  const name = arg.name;\n  const type = arg.type;\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return {\n        type: 'input',\n        name,\n        message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n      };\n    } else if (type === 'int128') {\n      return {\n        type: 'input',\n        name,\n        message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n      };\n    } else if (type === 'bool') {\n      return {\n        type: 'list',\n        name,\n        message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n        choices: ['True', 'False'],\n      };\n    } else if (type === 'principal') {\n      return {\n        type: 'input',\n        name,\n        message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n      };\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    return {\n      type: 'input',\n      name,\n      message: `Enter value for function argument \"${name}\" of type ${typeString}`,\n    };\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n\nexport function parseClarityFunctionArgAnswers(\n  answers: any,\n  expectedArgs: ClarityFunctionArg[]\n): ClarityValue[] {\n  const functionArgs: ClarityValue[] = [];\n  for (let i = 0; i < expectedArgs.length; i++) {\n    const expectedArg = expectedArgs[i];\n    const answer = answers[expectedArg.name];\n    functionArgs.push(answerToClarityValue(answer, expectedArg));\n  }\n  return functionArgs;\n}\n\nexport function answerToClarityValue(answer: any, arg: ClarityFunctionArg): ClarityValue {\n  const type = arg.type;\n  const typeString = getTypeString(type);\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(answer);\n    } else if (type === 'int128') {\n      return intCV(answer);\n    } else if (type === 'bool') {\n      return answer == 'True' ? trueCV() : falseCV();\n    } else if (type === 'principal') {\n      // TODO handle contract principals\n      return standardPrincipalCV(answer);\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    return bufferCVFromString(answer);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}\n\nexport function generateExplorerTxPageUrl(txid: string, network: StacksNetwork): string {\n  if (network.version === TransactionVersion.Testnet) {\n    return `https://testnet-explorer.now.sh/txid/0x${txid}`;\n  } else {\n    return `https://explorer.blockstack.org/txid/0x${txid}`;\n  }\n}\n","// TODO: most of this code should be in blockstack.js\n// Will remove most of this code once the wallet functionality is there instead.\n\nimport * as blockstack from 'blockstack';\nimport * as bitcoin from 'bitcoinjs-lib';\nimport * as bip39 from 'bip39';\n\nconst c32check = require('c32check');\n\nimport { getPrivateKeyAddress } from './utils';\n\nimport { getMaxIDSearchIndex } from './cli';\n\nimport { CLINetworkAdapter } from './network';\n\nimport * as bip32 from 'bip32';\nimport { BIP32Interface } from 'bip32';\n\nexport const STRENGTH = 128; // 12 words\nexport const STX_WALLET_COMPATIBLE_SEED_STRENGTH = 256;\nexport const DERIVATION_PATH = \"m/44'/5757'/0'/0/0\";\n\nexport type OwnerKeyInfoType = {\n  privateKey: string;\n  version: string;\n  index: number;\n  idAddress: string;\n};\n\nexport type PaymentKeyInfoType = {\n  privateKey: string;\n  address: {\n    BTC: string;\n    STACKS: string;\n  };\n  index: number;\n};\n\nexport type StacksKeyInfoType = {\n  privateKey: string;\n  address: string;\n  btcAddress: string;\n  index: number;\n};\n\nexport type AppKeyInfoType = {\n  keyInfo: {\n    privateKey: string;\n    address: string;\n  };\n  legacyKeyInfo: {\n    privateKey: string;\n    address: string;\n  };\n  ownerKeyIndex: number;\n};\n\nasync function walletFromMnemonic(mnemonic: string): Promise<blockstack.BlockstackWallet> {\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  return new blockstack.BlockstackWallet(bip32.fromSeed(seed));\n}\n\nfunction getNodePrivateKey(node: BIP32Interface): string {\n  return blockstack.ecPairToHexString(bitcoin.ECPair.fromPrivateKey(node.privateKey!));\n}\n\n/*\n * Get the owner key information for a 12-word phrase, at a specific index.\n * @network (object) the blockstack network\n * @mnemonic (string) the 12-word phrase\n * @index (number) the account index\n * @version (string) the derivation version string\n *\n * Returns an object with:\n *    .privateKey (string) the hex private key\n *    .version (string) the version string of the derivation\n *    .idAddress (string) the ID-address\n */\nexport async function getOwnerKeyInfo(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  index: number,\n  version: string = 'v0.10-current'\n): Promise<OwnerKeyInfoType> {\n  const wallet = await walletFromMnemonic(mnemonic);\n  const identity = wallet.getIdentityAddressNode(index);\n  const addr = network.coerceAddress(blockstack.BlockstackWallet.getAddressFromBIP32Node(identity));\n  const privkey = getNodePrivateKey(identity);\n  return {\n    privateKey: privkey,\n    version: version,\n    index: index,\n    idAddress: `ID-${addr}`,\n  } as OwnerKeyInfoType;\n}\n\n/*\n * Get the payment key information for a 12-word phrase.\n * @network (object) the blockstack network\n * @mnemonic (string) the 12-word phrase\n *\n * Returns an object with:\n *    .privateKey (string) the hex private key\n *    .address (string) the address of the private key\n */\nexport async function getPaymentKeyInfo(\n  network: CLINetworkAdapter,\n  mnemonic: string\n): Promise<PaymentKeyInfoType> {\n  const wallet = await walletFromMnemonic(mnemonic);\n  const privkey = wallet.getBitcoinPrivateKey(0);\n  const addr = getPrivateKeyAddress(network, privkey);\n  const result: PaymentKeyInfoType = {\n    privateKey: privkey,\n    address: {\n      BTC: addr,\n      STACKS: c32check.b58ToC32(addr),\n    },\n    index: 0,\n  };\n  return result;\n}\n\n/*\n * Get the payment key information for a 24-word phrase used by the Stacks wallet.\n * @network (object) the blockstack network\n * @mnemonic (string) the 24-word phrase\n *\n * Returns an object with:\n *    .privateKey (string) the hex private key\n *    .address (string) the address of the private key\n */\nexport async function getStacksWalletKeyInfo(\n  network: CLINetworkAdapter,\n  mnemonic: string\n): Promise<StacksKeyInfoType> {\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  const master = bip32.fromSeed(seed);\n  const child = master.derivePath(\"m/44'/5757'/0'/0/0\"); // taken from stacks-wallet. See https://github.com/blockstack/stacks-wallet\n  const ecPair = bitcoin.ECPair.fromPrivateKey(child.privateKey!);\n  const privkey = blockstack.ecPairToHexString(ecPair);\n\n  const addr = getPrivateKeyAddress(network, privkey);\n  let btcAddress: string;\n  if (network.isTestnet()) {\n    // btcAddress = const { address } = bitcoin.payments.p2pkh({ pubkey: keyPair.publicKey });\n    const { address } = bitcoin.payments.p2pkh({\n      pubkey: ecPair.publicKey,\n      network: bitcoin.networks.regtest,\n    });\n    btcAddress = address!;\n  } else {\n    const { address } = bitcoin.payments.p2pkh({\n      pubkey: ecPair.publicKey,\n      network: bitcoin.networks.bitcoin,\n    });\n    btcAddress = address!;\n  }\n  const result: StacksKeyInfoType = {\n    privateKey: privkey,\n    address: c32check.b58ToC32(addr),\n    btcAddress,\n    index: 0,\n  };\n  return result;\n}\n\n/*\n * Find the index of an ID address, given the mnemonic.\n * Returns the index if found\n * Returns -1 if not found\n */\nexport async function findIdentityIndex(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  idAddress: string,\n  maxIndex?: number\n): Promise<number> {\n  if (!maxIndex) {\n    maxIndex = getMaxIDSearchIndex();\n  }\n\n  if (idAddress.substring(0, 3) !== 'ID-') {\n    throw new Error('Not an identity address');\n  }\n\n  const wallet = await walletFromMnemonic(mnemonic);\n  for (let i = 0; i < maxIndex; i++) {\n    const identity = wallet.getIdentityAddressNode(i);\n    const addr = blockstack.BlockstackWallet.getAddressFromBIP32Node(identity);\n\n    if (network.coerceAddress(addr) === network.coerceAddress(idAddress.slice(3))) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/*\n * Get the Gaia application key from a 12-word phrase\n * @network (object) the blockstack network\n * @mmemonic (string) the 12-word phrase\n * @idAddress (string) the ID-address used to sign in\n * @appDomain (string) the application's Origin\n *\n * Returns an object with\n *    .keyInfo (object) the app key info with the current derivation path\n *      .privateKey (string) the app's hex private key\n *      .address (string) the address of the private key\n *    .legacyKeyInfo (object) the app key info with the legacy derivation path\n *      .privateKey (string) the app's hex private key\n *      .address (string) the address of the private key\n */\nexport async function getApplicationKeyInfo(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  idAddress: string,\n  appDomain: string,\n  idIndex?: number\n): Promise<AppKeyInfoType> {\n  if (!idIndex) {\n    idIndex = -1;\n  }\n\n  if (idIndex < 0) {\n    idIndex = await findIdentityIndex(network, mnemonic, idAddress);\n    if (idIndex < 0) {\n      throw new Error('Identity address does not belong to this keychain');\n    }\n  }\n\n  const wallet = await walletFromMnemonic(mnemonic);\n  const identityOwnerAddressNode = wallet.getIdentityAddressNode(idIndex);\n  const appsNode = blockstack.BlockstackWallet.getAppsNode(identityOwnerAddressNode);\n\n  //const appPrivateKey = blockstack.BlockstackWallet.getAppPrivateKey(\n  //  appsNode.toBase58(), wallet.getIdentitySalt(), appDomain);\n  const legacyAppPrivateKey = blockstack.BlockstackWallet.getLegacyAppPrivateKey(\n    appsNode.toBase58(),\n    wallet.getIdentitySalt(),\n    appDomain\n  );\n\n  // TODO: figure out when we can start using the new derivation path\n  const res: AppKeyInfoType = {\n    keyInfo: {\n      privateKey: 'TODO', // appPrivateKey,\n      address: 'TODO', // getPrivateKeyAddress(network, `${appPrivateKey}01`)\n    },\n    legacyKeyInfo: {\n      privateKey: legacyAppPrivateKey,\n      address: getPrivateKeyAddress(network, `${legacyAppPrivateKey}01`),\n    },\n    ownerKeyIndex: idIndex,\n  };\n  return res;\n}\n\n/*\n * Extract the \"right\" app key\n */\nexport function extractAppKey(\n  network: CLINetworkAdapter,\n  appKeyInfo: {\n    keyInfo: { privateKey: string; address: string };\n    legacyKeyInfo: { privateKey: string; address: string };\n  },\n  appAddress?: string\n): string {\n  if (appAddress) {\n    if (\n      network.coerceMainnetAddress(appKeyInfo.keyInfo.address) ===\n      network.coerceMainnetAddress(appAddress)\n    ) {\n      return appKeyInfo.keyInfo.privateKey;\n    }\n    if (\n      network.coerceMainnetAddress(appKeyInfo.legacyKeyInfo.address) ===\n      network.coerceMainnetAddress(appAddress)\n    ) {\n      return appKeyInfo.legacyKeyInfo.privateKey;\n    }\n  }\n\n  const appPrivateKey =\n    appKeyInfo.keyInfo.privateKey === 'TODO' || !appKeyInfo.keyInfo.privateKey\n      ? appKeyInfo.legacyKeyInfo.privateKey\n      : appKeyInfo.keyInfo.privateKey;\n  return appPrivateKey;\n}\n","import blockstack from 'blockstack';\nimport * as bitcoin from 'bitcoinjs-lib';\nconst BN = require('bn.js');\nimport fetch from 'node-fetch';\n\nimport { CLI_CONFIG_TYPE } from './argparse';\n\nimport { BlockstackNetwork } from 'blockstack/lib/network';\n\nconst SATOSHIS_PER_BTC = 1e8;\n\nexport interface CLI_NETWORK_OPTS {\n  consensusHash: string | null;\n  feeRate: number | null;\n  namespaceBurnAddress: string | null;\n  priceToPay: string | null;\n  priceUnits: string | null;\n  receiveFeesPeriod: number | null;\n  gracePeriod: number | null;\n  altAPIUrl: string | null;\n  altTransactionBroadcasterUrl: string | null;\n  nodeAPIUrl: string | null;\n}\n\nexport interface PriceType {\n  units: 'BTC' | 'STACKS';\n  amount: import('bn.js');\n}\n\nexport type NameInfoType = {\n  address: string;\n  blockchain?: string;\n  did?: string;\n  expire_block?: number;\n  grace_period?: number;\n  last_txid?: string;\n  renewal_deadline?: number;\n  resolver?: string | null;\n  status?: string;\n  zonefile?: string | null;\n  zonefile_hash?: string | null;\n};\n\n/*\n * Adapter class that allows us to use data obtained\n * from the CLI.\n */\nexport class CLINetworkAdapter {\n  consensusHash: string | null;\n  feeRate: number | null;\n  namespaceBurnAddress: string | null;\n  priceToPay: string | null;\n  priceUnits: string | null;\n  gracePeriod: number | null;\n  receiveFeesPeriod: number | null;\n  nodeAPIUrl: string;\n  optAlwaysCoerceAddress: boolean;\n  legacyNetwork: BlockstackNetwork;\n\n  constructor(network: BlockstackNetwork, opts: CLI_NETWORK_OPTS) {\n    const optsDefault: CLI_NETWORK_OPTS = {\n      consensusHash: null,\n      feeRate: null,\n      namespaceBurnAddress: null,\n      priceToPay: null,\n      priceUnits: null,\n      receiveFeesPeriod: null,\n      gracePeriod: null,\n      altAPIUrl: opts.nodeAPIUrl,\n      altTransactionBroadcasterUrl: network.broadcastServiceUrl,\n      nodeAPIUrl: opts.nodeAPIUrl,\n    };\n\n    opts = Object.assign({}, optsDefault, opts);\n\n    this.legacyNetwork = new BlockstackNetwork(\n      opts.nodeAPIUrl!,\n      opts.altTransactionBroadcasterUrl!,\n      network.btc,\n      network.layer1\n    );\n    this.consensusHash = opts.consensusHash;\n    this.feeRate = opts.feeRate;\n    this.namespaceBurnAddress = opts.namespaceBurnAddress;\n    this.priceToPay = opts.priceToPay;\n    this.priceUnits = opts.priceUnits;\n    this.receiveFeesPeriod = opts.receiveFeesPeriod;\n    this.gracePeriod = opts.gracePeriod;\n    this.nodeAPIUrl = opts.nodeAPIUrl!;\n\n    this.optAlwaysCoerceAddress = false;\n  }\n\n  isMainnet(): boolean {\n    return this.legacyNetwork.layer1.pubKeyHash === bitcoin.networks.bitcoin.pubKeyHash;\n  }\n\n  isTestnet(): boolean {\n    return this.legacyNetwork.layer1.pubKeyHash === bitcoin.networks.testnet.pubKeyHash;\n  }\n\n  setCoerceMainnetAddress(value: boolean) {\n    this.optAlwaysCoerceAddress = value;\n  }\n\n  coerceMainnetAddress(address: string): string {\n    const addressInfo = bitcoin.address.fromBase58Check(address);\n    const addressHash = addressInfo.hash;\n    const addressVersion = addressInfo.version;\n    let newVersion = 0;\n\n    if (addressVersion === this.legacyNetwork.layer1.pubKeyHash) {\n      newVersion = 0;\n    } else if (addressVersion === this.legacyNetwork.layer1.scriptHash) {\n      newVersion = 5;\n    }\n    return bitcoin.address.toBase58Check(addressHash, newVersion);\n  }\n\n  getFeeRate(): Promise<number> {\n    if (this.feeRate) {\n      // override with CLI option\n      return Promise.resolve(this.feeRate);\n    }\n    if (this.isTestnet()) {\n      // in regtest mode\n      return Promise.resolve(Math.floor(0.00001 * SATOSHIS_PER_BTC));\n    }\n    return this.legacyNetwork.getFeeRate();\n  }\n\n  getConsensusHash(): Promise<string> {\n    // override with CLI option\n    if (this.consensusHash) {\n      return new Promise((resolve: any) => resolve(this.consensusHash));\n    }\n    return this.legacyNetwork.getConsensusHash().then((c: string) => c);\n  }\n\n  getGracePeriod(): Promise<number> {\n    if (this.gracePeriod) {\n      return new Promise((resolve: any) => resolve(this.gracePeriod));\n    }\n    return this.legacyNetwork.getGracePeriod().then((g: number) => g);\n  }\n\n  getNamePrice(name: string): Promise<PriceType> {\n    // override with CLI option\n    if (this.priceUnits && this.priceToPay) {\n      return new Promise((resolve: any) =>\n        resolve({\n          units: String(this.priceUnits),\n          amount: new BN(this.priceToPay),\n        } as PriceType)\n      );\n    }\n    // @ts-ignore\n    return this.legacyNetwork.getNamePrice(name).then((priceInfo: PriceType) => {\n      // use v2 scheme\n      if (!priceInfo.units) {\n        priceInfo = {\n          units: 'BTC',\n          amount: new BN(String(priceInfo)),\n        };\n      }\n      return priceInfo;\n    });\n  }\n\n  getNamespacePrice(namespaceID: string): Promise<PriceType> {\n    // override with CLI option\n    if (this.priceUnits && this.priceToPay) {\n      return new Promise((resolve: any) =>\n        resolve({\n          units: String(this.priceUnits),\n          amount: new BN(String(this.priceToPay)),\n        } as PriceType)\n      );\n    }\n    // @ts-ignore\n    return super.getNamespacePrice(namespaceID).then((priceInfo: PriceType) => {\n      // use v2 scheme\n      if (!priceInfo.units) {\n        priceInfo = {\n          units: 'BTC',\n          amount: new BN(String(priceInfo)),\n        } as PriceType;\n      }\n      return priceInfo;\n    });\n  }\n\n  getNamespaceBurnAddress(\n    namespace: string,\n    useCLI: boolean = true,\n    receiveFeesPeriod: number = -1\n  ): Promise<string> {\n    // override with CLI option\n    if (this.namespaceBurnAddress && useCLI) {\n      return new Promise((resolve: any) => resolve(this.namespaceBurnAddress));\n    }\n\n    return Promise.all([\n      fetch(`${this.legacyNetwork.blockstackAPIUrl}/v1/namespaces/${namespace}`),\n      this.legacyNetwork.getBlockHeight(),\n    ])\n      .then(([resp, blockHeight]: [any, number]) => {\n        if (resp.status === 404) {\n          throw new Error(`No such namespace '${namespace}'`);\n        } else if (resp.status !== 200) {\n          throw new Error(`Bad response status: ${resp.status}`);\n        } else {\n          return Promise.all([resp.json(), blockHeight]);\n        }\n      })\n      .then(([namespaceInfo, blockHeight]: [any, number]) => {\n        let address = '1111111111111111111114oLvT2'; // default burn address\n        if (namespaceInfo.version === 2) {\n          // pay-to-namespace-creator if this namespace is less than $receiveFeesPeriod blocks old\n          if (receiveFeesPeriod < 0) {\n            receiveFeesPeriod = this.receiveFeesPeriod!;\n          }\n\n          if (namespaceInfo.reveal_block + receiveFeesPeriod > blockHeight) {\n            address = namespaceInfo.address;\n          }\n        }\n        return address;\n      })\n      .then((address: string) => this.legacyNetwork.coerceAddress(address));\n  }\n\n  getNameInfo(name: string): Promise<NameInfoType> {\n    // optionally coerce addresses\n    return this.legacyNetwork.getNameInfo(name).then((ni: any) => {\n      const nameInfo: NameInfoType = {\n        address: this.optAlwaysCoerceAddress ? this.coerceMainnetAddress(ni.address) : ni.address,\n        blockchain: ni.blockchain,\n        did: ni.did,\n        expire_block: ni.expire_block,\n        grace_period: ni.grace_period,\n        last_txid: ni.last_txid,\n        renewal_deadline: ni.renewal_deadline,\n        resolver: ni.resolver,\n        status: ni.status,\n        zonefile: ni.zonefile,\n        zonefile_hash: ni.zonefile_hash,\n      };\n      return nameInfo;\n    });\n  }\n\n  getBlockchainNameRecord(name: string): Promise<any> {\n    // TODO: send to blockstack.js\n    const url = `${this.legacyNetwork.blockstackAPIUrl}/v1/blockchains/bitcoin/names/${name}`;\n    return fetch(url)\n      .then(resp => {\n        if (resp.status !== 200) {\n          throw new Error(`Bad response status: ${resp.status}`);\n        } else {\n          return resp.json();\n        }\n      })\n      .then(nameInfo => {\n        // coerce all addresses\n        const fixedAddresses: Record<string, any> = {};\n        for (const addrAttr of ['address', 'importer_address', 'recipient_address']) {\n          if (nameInfo.hasOwnProperty(addrAttr) && nameInfo[addrAttr]) {\n            fixedAddresses[addrAttr] = this.legacyNetwork.coerceAddress(nameInfo[addrAttr]);\n          }\n        }\n        return Object.assign(nameInfo, fixedAddresses);\n      });\n  }\n\n  getNameHistory(name: string, page: number): Promise<Record<string, any[]>> {\n    // TODO: send to blockstack.js\n    const url = `${this.legacyNetwork.blockstackAPIUrl}/v1/names/${name}/history?page=${page}`;\n    return fetch(url)\n      .then(resp => {\n        if (resp.status !== 200) {\n          throw new Error(`Bad response status: ${resp.status}`);\n        }\n        return resp.json();\n      })\n      .then(historyInfo => {\n        // coerce all addresses\n        const fixedHistory: Record<string, any[]> = {};\n        for (const historyBlock of Object.keys(historyInfo)) {\n          const fixedHistoryList: any[] = [];\n          for (const historyEntry of historyInfo[historyBlock]) {\n            const fixedAddresses: Record<string, string> = {};\n            let fixedHistoryEntry: any = {};\n            for (const addrAttr of ['address', 'importer_address', 'recipient_address']) {\n              if (historyEntry.hasOwnProperty(addrAttr) && historyEntry[addrAttr]) {\n                fixedAddresses[addrAttr] = this.legacyNetwork.coerceAddress(historyEntry[addrAttr]);\n              }\n            }\n            fixedHistoryEntry = Object.assign(historyEntry, fixedAddresses);\n            fixedHistoryList.push(fixedHistoryEntry);\n          }\n          fixedHistory[historyBlock] = fixedHistoryList;\n        }\n        return fixedHistory;\n      });\n  }\n\n  coerceAddress(address: string) {\n    return this.legacyNetwork.coerceAddress(address);\n  }\n\n  getAccountHistoryPage(address: string, page: number) {\n    return this.legacyNetwork.getAccountHistoryPage(address, page);\n  }\n\n  broadcastTransaction(tx: string) {\n    return this.legacyNetwork.broadcastTransaction(tx);\n  }\n\n  broadcastZoneFile(zonefile: string, txid: string) {\n    return this.legacyNetwork.broadcastZoneFile(zonefile, txid);\n  }\n\n  getNamesOwned(address: string) {\n    return this.legacyNetwork.getNamesOwned(address);\n  }\n}\n\n/*\n * Instantiate a network using settings from the config file.\n */\nexport function getNetwork(configData: CLI_CONFIG_TYPE, regTest: boolean): BlockstackNetwork {\n  if (regTest) {\n    const network = new blockstack.network.LocalRegtest(\n      configData.blockstackAPIUrl,\n      configData.broadcastServiceUrl,\n      new blockstack.network.BitcoindAPI(configData.utxoServiceUrl, {\n        username: configData.bitcoindUsername || 'blockstack',\n        password: configData.bitcoindPassword || 'blockstacksystem',\n      })\n    );\n\n    return network;\n  } else {\n    const network = new BlockstackNetwork(\n      configData.blockstackAPIUrl,\n      configData.broadcastServiceUrl,\n      new blockstack.network.BlockchainInfoApi(configData.utxoServiceUrl)\n    );\n\n    return network;\n  }\n}\n","import * as blockstack from 'blockstack';\nimport * as URL from 'url';\nimport * as crypto from 'crypto';\nimport * as jsontokens from 'jsontokens';\n\nconst ZoneFile = require('zone-file');\n\nimport {\n  canonicalPrivateKey,\n  getPrivateKeyAddress,\n  checkUrl,\n  SafetyError,\n  getPublicKeyFromPrivateKey,\n} from './utils';\n\nimport { CLINetworkAdapter, NameInfoType } from './network';\n\nimport { UserData } from '@stacks/auth';\n\nimport { GaiaHubConfig, connectToGaiaHub } from '@stacks/storage';\n\n/*\n * Set up a session for Gaia.\n * Generate an authentication response like what the browser would do,\n * and store the relevant data to our emulated localStorage.\n */\nfunction makeFakeAuthResponseToken(\n  appPrivateKey: string | null,\n  hubURL: string | null,\n  associationToken?: string\n) {\n  const ownerPrivateKey = '24004db06ef6d26cdd2b0fa30b332a1b10fa0ba2b07e63505ffc2a9ed7df22b4';\n  const transitPrivateKey = 'f33fb466154023aba2003c17158985aa6603db68db0f1afc0fcf1d641ea6c2cb';\n  const transitPublicKey =\n    '0496345da77fb5e06757b9c4fd656bf830a3b293f245a6cc2f11f8334ebb690f1' +\n    '9582124f4b07172eb61187afba4514828f866a8a223e0d5c539b2e38a59ab8bb3';\n\n  // eslint-disable-next-line\n  window.localStorage.setItem('blockstack-transit-private-key', transitPrivateKey);\n\n  const authResponse = blockstack.makeAuthResponse(\n    ownerPrivateKey,\n    { type: '@Person', accounts: [] },\n    // @ts-ignore\n    null,\n    {},\n    null,\n    appPrivateKey,\n    undefined,\n    transitPublicKey,\n    hubURL,\n    blockstack.config.network.blockstackAPIUrl,\n    associationToken\n  );\n\n  return authResponse;\n}\n\n/*\n * Make an association token for the given address.\n * TODO belongs in a \"gaia.js\" library\n */\nexport function makeAssociationToken(appPrivateKey: string, identityKey: string): string {\n  const appPublicKey = getPublicKeyFromPrivateKey(`${canonicalPrivateKey(appPrivateKey)}01`);\n  const FOUR_MONTH_SECONDS = 60 * 60 * 24 * 31 * 4;\n  const salt = crypto.randomBytes(16).toString('hex');\n  const identityPublicKey = getPublicKeyFromPrivateKey(identityKey);\n  const associationTokenClaim = {\n    childToAssociate: appPublicKey,\n    iss: identityPublicKey,\n    exp: FOUR_MONTH_SECONDS + new Date().getTime() / 1000,\n    salt,\n  };\n  const associationToken = new jsontokens.TokenSigner('ES256K', identityKey).sign(\n    associationTokenClaim\n  );\n  return associationToken;\n}\n\n/*\n * Authenticate to Gaia.  Used for reading, writing, and listing files.\n * Process a (fake) session token and set up a Gaia hub connection.\n * Returns a Promise that resolves to the (fake) userData\n */\nexport function gaiaAuth(\n  network: CLINetworkAdapter,\n  appPrivateKey: string | null,\n  hubUrl: string | null,\n  ownerPrivateKey?: string\n): Promise<UserData> {\n  // Gaia speaks mainnet only!\n  if (!network.isMainnet()) {\n    throw new Error('Gaia only works with mainnet networks.');\n  }\n\n  let associationToken;\n  if (ownerPrivateKey && appPrivateKey) {\n    associationToken = makeAssociationToken(appPrivateKey, ownerPrivateKey);\n  }\n\n  const authSessionToken = makeFakeAuthResponseToken(appPrivateKey, hubUrl, associationToken);\n  const nameLookupUrl = `${network.legacyNetwork.blockstackAPIUrl}/v1/names/`;\n  const transitPrivateKey = 'f33fb466154023aba2003c17158985aa6603db68db0f1afc0fcf1d641ea6c2cb'; // same as above\n  //@ts-ignore\n  return blockstack.handlePendingSignIn(nameLookupUrl, authSessionToken, transitPrivateKey);\n}\n\n/*\n * Connect to Gaia hub and generate a hub config.\n * Used for reading and writing profiles.\n * Make sure we use a mainnet address always, even in test mode.\n * Returns a Promise that resolves to a GaiaHubConfig\n */\nexport function gaiaConnect(\n  network: CLINetworkAdapter,\n  gaiaHubUrl: string,\n  privateKey: string,\n  ownerPrivateKey?: string\n) {\n  const addressMainnet = network.coerceMainnetAddress(\n    getPrivateKeyAddress(network, `${canonicalPrivateKey(privateKey)}01`)\n  );\n  const addressMainnetCanonical = network.coerceMainnetAddress(\n    getPrivateKeyAddress(network, canonicalPrivateKey(privateKey))\n  );\n\n  let associationToken;\n  if (ownerPrivateKey) {\n    associationToken = makeAssociationToken(privateKey, ownerPrivateKey);\n  }\n\n  return connectToGaiaHub(gaiaHubUrl, canonicalPrivateKey(privateKey), associationToken).then(\n    hubConfig => {\n      // ensure that hubConfig always has a mainnet address, even if we're in testnet\n      if (network.coerceMainnetAddress(hubConfig.address) === addressMainnet) {\n        hubConfig.address = addressMainnet;\n      } else if (network.coerceMainnetAddress(hubConfig.address) === addressMainnetCanonical) {\n        hubConfig.address = addressMainnetCanonical;\n      } else {\n        throw new Error(\n          'Invalid private key: ' +\n            `${network.coerceMainnetAddress(hubConfig.address)} is neither ` +\n            `${addressMainnet} or ${addressMainnetCanonical}`\n        );\n      }\n      return hubConfig;\n    }\n  );\n}\n\n/*\n * Find the profile.json path for a name\n * @network (object) the network to use\n * @blockstackID (string) the blockstack ID to query\n *\n * Returns a Promise that resolves to the filename to use for the profile\n * Throws an exception if the profile URL could not be determined\n */\nfunction gaiaFindProfileName(\n  network: CLINetworkAdapter,\n  hubConfig: GaiaHubConfig,\n  blockstackID?: string\n): Promise<string> {\n  if (!blockstackID || blockstackID === null || blockstackID === undefined) {\n    return Promise.resolve().then(() => 'profile.json');\n  } else {\n    return network.getNameInfo(blockstackID).then((nameInfo: NameInfoType) => {\n      let profileUrl;\n      try {\n        const zonefileJSON = ZoneFile.parseZoneFile(nameInfo.zonefile);\n        if (zonefileJSON.uri && zonefileJSON.hasOwnProperty('$origin')) {\n          profileUrl = blockstack.getTokenFileUrl(zonefileJSON);\n        }\n      } catch (e) {\n        throw new Error(\n          `Could not determine profile URL for ${String(blockstackID)}: could not parse zone file`\n        );\n      }\n\n      if (profileUrl === null || profileUrl === undefined) {\n        throw new Error(\n          `Could not determine profile URL for ${String(blockstackID)}: no URL in zone file`\n        );\n      }\n\n      // profile URL path must match Gaia hub's URL prefix and address\n      // (the host can be different)\n      const gaiaReadPrefix = `${hubConfig.url_prefix}${hubConfig.address}`;\n      const gaiaReadUrlPath = String(URL.parse(gaiaReadPrefix).path);\n      const profileUrlPath = String(URL.parse(profileUrl).path);\n\n      if (!profileUrlPath.startsWith(gaiaReadUrlPath)) {\n        throw new Error(\n          `Could not determine profile URL for ${String(blockstackID)}: wrong Gaia hub` +\n            ` (${gaiaReadPrefix} does not correspond to ${profileUrl})`\n        );\n      }\n\n      const profilePath = profileUrlPath.substring(gaiaReadUrlPath.length + 1);\n      return profilePath;\n    });\n  }\n}\n\n/*\n * Upload profile data to a Gaia hub.\n *\n * Legacy compat:\n * If a blockstack ID is given, then the zone file will be queried and the profile URL\n * inspected to make sure that we handle the special (legacy) case where a profile.json\n * file got stored to $GAIA_URL/$ADDRESS/$INDEX/profile.json (where $INDEX is a number).\n * In such cases, the profile will be stored to $INDEX/profile.json, instead of just\n * profile.json.\n *\n * @network (object) the network to use\n * @gaiaHubUrl (string) the base scheme://host:port URL to the Gaia hub\n * @gaiaData (string) the data to upload\n * @privateKey (string) the private key to use to sign the challenge\n * @blockstackID (string) optional; the blockstack ID for which this profile will be stored.\n */\nexport function gaiaUploadProfile(\n  network: CLINetworkAdapter,\n  gaiaHubURL: string,\n  gaiaData: string,\n  privateKey: string,\n  blockstackID?: string\n) {\n  let hubConfig: GaiaHubConfig;\n  return gaiaConnect(network, gaiaHubURL, privateKey)\n    .then((hubconf: GaiaHubConfig) => {\n      // make sure we use the *right* gaia path.\n      // if the blockstackID is given, then we should inspect the zone file to\n      // determine if the Gaia profile URL contains an index.  If it does, then\n      // we need to preserve it!\n      hubConfig = hubconf;\n      return gaiaFindProfileName(network, hubConfig, blockstackID);\n    })\n    .then((profilePath: string) => {\n      return blockstack.uploadToGaiaHub(profilePath, gaiaData, hubConfig);\n    });\n}\n\n/*\n * Upload profile data to all Gaia hubs, given a zone file.\n * @network (object) the network to use\n * @gaiaUrls (array) list of Gaia URLs\n * @gaiaData (string) the data to store\n * @privateKey (string) the hex-encoded private key\n * @return a promise with {'dataUrls': [urls to the data]}, or {'error': ...}\n */\nexport function gaiaUploadProfileAll(\n  network: CLINetworkAdapter,\n  gaiaUrls: string[],\n  gaiaData: string,\n  privateKey: string,\n  blockstackID?: string\n): Promise<{ dataUrls?: string[] | null; error?: string | null }> {\n  const sanitizedGaiaUrls = gaiaUrls\n    .map(gaiaUrl => {\n      const urlInfo = URL.parse(gaiaUrl);\n      if (!urlInfo.protocol) {\n        return '';\n      }\n      if (!urlInfo.host) {\n        return '';\n      }\n      // keep flow happy\n      return `${String(urlInfo.protocol)}//${String(urlInfo.host)}`;\n    })\n    .filter(gaiaUrl => gaiaUrl.length > 0);\n\n  const uploadPromises = sanitizedGaiaUrls.map(gaiaUrl =>\n    gaiaUploadProfile(network, gaiaUrl, gaiaData, privateKey, blockstackID)\n  );\n\n  return Promise.all(uploadPromises)\n    .then(publicUrls => {\n      return { error: null, dataUrls: publicUrls! };\n    })\n    .catch(e => {\n      return { error: `Failed to upload: ${e.message}`, dataUrls: null };\n    });\n}\n\n/*\n * Make a zone file from a Gaia hub---reach out to the Gaia hub, get its read URL prefix,\n * and generate a zone file with the profile mapped to the Gaia hub.\n *\n * @network (object) the network connection\n * @name (string) the name that owns the zone file\n * @gaiaHubUrl (string) the URL to the gaia hub write endpoint\n * @ownerKey (string) the owner private key\n *\n * Returns a promise that resolves to the zone file with the profile URL\n */\nexport function makeZoneFileFromGaiaUrl(\n  network: CLINetworkAdapter,\n  name: string,\n  gaiaHubUrl: string,\n  ownerKey: string\n) {\n  const address = getPrivateKeyAddress(network, ownerKey);\n  const mainnetAddress = network.coerceMainnetAddress(address);\n\n  return gaiaConnect(network, gaiaHubUrl, ownerKey).then(hubConfig => {\n    if (!hubConfig.url_prefix) {\n      throw new Error('Invalid hub config: no read_url_prefix defined');\n    }\n    const gaiaReadUrl = hubConfig.url_prefix.replace(/\\/+$/, '');\n    const profileUrl = `${gaiaReadUrl}/${mainnetAddress}/profile.json`;\n    try {\n      checkUrl(profileUrl);\n    } catch (e) {\n      throw new SafetyError({\n        status: false,\n        error: e.message,\n        hints: [\n          'Make sure the Gaia hub read URL scheme is present and well-formed.',\n          `Check the \"read_url_prefix\" field of ${gaiaHubUrl}/hub_info`,\n        ],\n      });\n    }\n    return blockstack.makeProfileZoneFile(name, profileUrl);\n  });\n}\n\n/*\n * Given a Gaia bucket URL, extract its address\n */\nexport function getGaiaAddressFromURL(appUrl: string): string {\n  const matches = appUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n  if (!matches) {\n    throw new Error('Failed to parse gaia address');\n  }\n  return matches[matches.length - 1];\n}\n\n/*\n * Given a profile and an app origin, find its app address\n * Returns the address on success\n * Throws on error or not found\n */\nexport function getGaiaAddressFromProfile(\n  network: CLINetworkAdapter,\n  profile: any,\n  appOrigin: string\n): string {\n  if (!profile) {\n    throw new Error('No profile');\n  }\n  if (!profile.apps) {\n    throw new Error('No profile apps');\n  }\n  if (!profile.apps[appOrigin]) {\n    throw new Error(`No app entry for ${appOrigin}`);\n  }\n\n  // do we already have an address set for this app?\n  const appUrl = profile.apps[appOrigin];\n  let existingAppAddress;\n  // what's the address?\n  try {\n    existingAppAddress = network.coerceMainnetAddress(getGaiaAddressFromURL(appUrl));\n  } catch (e) {\n    throw new Error(`Failed to parse app URL ${appUrl}`);\n  }\n\n  return existingAppAddress;\n}\n","import * as blockstack from 'blockstack';\nimport * as express from 'express';\nimport * as crypto from 'crypto';\nimport * as jsontokens from 'jsontokens';\nimport * as logger from 'winston';\n\nimport {\n  gaiaConnect,\n  gaiaUploadProfileAll,\n  makeAssociationToken,\n  getGaiaAddressFromProfile,\n} from './data';\n\nimport { getApplicationKeyInfo, getOwnerKeyInfo, extractAppKey } from './keys';\n\nimport { nameLookup, makeProfileJWT } from './utils';\n\nimport { CLINetworkAdapter } from './network';\n\nimport { GaiaHubConfig } from '@stacks/storage';\n\nexport const SIGNIN_CSS = `\nh1 { \n  font-family: monospace; \n  font-size: 24px; \n  font-style: normal; \n  font-variant: normal; \n  font-weight: 700; \n  line-height: 26.4px; \n} \nh3 { \n  font-family: monospace; \n  font-size: 14px; \n  font-style: normal; \n  font-variant: normal; \n  font-weight: 700; \n  line-height: 15.4px; \n}\np { \n  font-family: monospace; \n  font-size: 14px; \n  font-style: normal; \n  font-variant: normal; \n  font-weight: 400; \n  line-height: 20px; \n}\nb {\n  background-color: #e8e8e8;\n}\npre { \n  font-family: monospace; \n  font-size: 13px; \n  font-style: normal; \n  font-variant: normal; \n  font-weight: 400; \n  line-height: 18.5714px;\n}`;\n\nexport const SIGNIN_HEADER = `<html><head><style>${SIGNIN_CSS}</style></head></body><h3>Blockstack CLI Sign-in</h3><br>`;\nexport const SIGNIN_DESC = '<p>Sign-in request for <b>\"{appName}\"</b></p>';\nexport const SIGNIN_SCOPES = '<p>Requested scopes: <b>\"{appScopes}\"</b></p>';\nexport const SIGNIN_FMT_NAME = '<p><a href=\"{authRedirect}\">{blockstackID}</a> ({idAddress})</p>';\nexport const SIGNIN_FMT_ID = '<p><a href=\"{authRedirect}\">{idAddress}</a> (anonymous)</p>';\nexport const SIGNIN_FOOTER = '</body></html>';\n\nexport interface NamedIdentityType {\n  name: string;\n  idAddress: string;\n  privateKey: string;\n  index: number;\n  profile: Object;\n  profileUrl: string;\n}\n\ninterface AuthRequestType {\n  jti: string;\n  iat: number;\n  exp: number;\n  iss: null | string;\n  public_keys: string[];\n  domain_name: string;\n  manifest_uri: string;\n  redirect_uri: string;\n  version: string;\n  do_not_include_profile: boolean;\n  supports_hub_url: boolean;\n  scopes: string[];\n}\n\n// new ecdsa private key each time\nconst authTransitNonce = crypto.randomBytes(32).toString('hex');\n\n/*\n * Get the app private key\n */\nasync function getAppPrivateKey(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  id: NamedIdentityType,\n  appOrigin: string\n): Promise<string> {\n  const appKeyInfo = await getApplicationKeyInfo(\n    network,\n    mnemonic,\n    id.idAddress,\n    appOrigin,\n    id.index\n  );\n  let appPrivateKey;\n  try {\n    const existingAppAddress = getGaiaAddressFromProfile(network, id.profile, appOrigin);\n    appPrivateKey = extractAppKey(network, appKeyInfo, existingAppAddress);\n  } catch (e) {\n    appPrivateKey = extractAppKey(network, appKeyInfo);\n  }\n\n  return appPrivateKey;\n}\n\n/*\n * Make a sign-in link\n */\nasync function makeSignInLink(\n  network: CLINetworkAdapter,\n  authPort: number,\n  mnemonic: string,\n  authRequest: AuthRequestType,\n  hubUrl: string,\n  id: NamedIdentityType\n): Promise<string> {\n  const appOrigin = authRequest.domain_name;\n  const appPrivateKey = await getAppPrivateKey(network, mnemonic, id, appOrigin);\n\n  const associationToken = makeAssociationToken(appPrivateKey, id.privateKey);\n  const authResponseTmp = blockstack.makeAuthResponse(\n    id.privateKey,\n    {},\n    id.name,\n    { email: undefined, profileUrl: id.profileUrl },\n    undefined,\n    appPrivateKey,\n    undefined,\n    authRequest.public_keys[0],\n    hubUrl,\n    blockstack.config.network.blockstackAPIUrl,\n    associationToken\n  );\n\n  // pass along some helpful data from the authRequest\n  const authResponsePayload = jsontokens.decodeToken(authResponseTmp).payload;\n  const id_public = Object.assign({}, id);\n  id_public.profile = {};\n  // @ts-ignore\n  id_public.privateKey = undefined;\n\n  (authResponsePayload as any).metadata = {\n    id: id_public,\n    profileUrl: id.profileUrl,\n    appOrigin: appOrigin,\n    redirect_uri: authRequest.redirect_uri,\n    scopes: authRequest.scopes,\n    salt: crypto.randomBytes(16).toString('hex'),\n    nonce: authTransitNonce,\n    // fill in more CLI-specific fields here\n  };\n\n  const tokenSigner = new jsontokens.TokenSigner('ES256k', id.privateKey);\n  const authResponse = tokenSigner.sign(authResponsePayload);\n\n  return blockstack.updateQueryStringParameter(\n    `http://localhost:${authPort}/signin`,\n    'authResponse',\n    authResponse\n  );\n}\n\n/*\n * Make the sign-in page\n */\nasync function makeAuthPage(\n  network: CLINetworkAdapter,\n  authPort: number,\n  mnemonic: string,\n  hubUrl: string,\n  manifest: any,\n  authRequest: AuthRequestType,\n  ids: Array<NamedIdentityType>\n): Promise<string> {\n  let signinBody = SIGNIN_HEADER;\n  const signinDescription = SIGNIN_DESC.replace(/{appName}/, manifest.name || '(Unknown app)');\n\n  const signinScopes = SIGNIN_SCOPES.replace(\n    /{appScopes}/,\n    authRequest.scopes.length > 0 ? authRequest.scopes.join(', ') : '(none)'\n  );\n\n  signinBody = `${signinBody}${signinDescription}${signinScopes}`;\n\n  for (let i = 0; i < ids.length; i++) {\n    let signinEntry;\n    if (ids[i].name) {\n      signinEntry = SIGNIN_FMT_NAME.replace(\n        /{authRedirect}/,\n        await makeSignInLink(network, authPort, mnemonic, authRequest, hubUrl, ids[i])\n      )\n        .replace(/{blockstackID}/, ids[i].name)\n        .replace(/{idAddress}/, ids[i].idAddress);\n    } else {\n      signinEntry = SIGNIN_FMT_ID.replace(\n        /{authRedirect}/,\n        await makeSignInLink(network, authPort, mnemonic, authRequest, hubUrl, ids[i])\n      ).replace(/{idAddress}/, ids[i].idAddress);\n    }\n\n    signinBody = `${signinBody}${signinEntry}`;\n  }\n\n  signinBody = `${signinBody}${SIGNIN_FOOTER}`;\n  return signinBody;\n}\n\n/*\n * Find all identity addresses that have names attached to them.\n * Fills in identities.\n */\nasync function loadNamedIdentitiesLoop(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  index: number,\n  identities: NamedIdentityType[]\n): Promise<NamedIdentityType[]> {\n  // 65536 is a ridiculously huge number\n  if (index > 65536) {\n    throw new Error('Too many names');\n  }\n\n  const keyInfo = await getOwnerKeyInfo(network, mnemonic, index);\n  const nameList = await network.getNamesOwned(keyInfo.idAddress.slice(3));\n  if (nameList.length === 0) {\n    // out of names\n    return identities;\n  }\n  for (let i = 0; i < nameList.length; i++) {\n    const identity: NamedIdentityType = {\n      name: nameList[i],\n      idAddress: keyInfo.idAddress,\n      privateKey: keyInfo.privateKey,\n      index: index,\n      profile: {},\n      profileUrl: '',\n    };\n    identities.push(identity);\n  }\n  return await loadNamedIdentitiesLoop(network, mnemonic, index + 1, identities);\n}\n\n/*\n * Load all named identities for a mnemonic.\n * Keep loading until we find an ID-address that does not have a name.\n */\nexport function loadNamedIdentities(\n  network: CLINetworkAdapter,\n  mnemonic: string\n): Promise<Array<NamedIdentityType>> {\n  return loadNamedIdentitiesLoop(network, mnemonic, 0, []);\n}\n\n/*\n * Generate identity info for an unnamed ID\n */\nasync function loadUnnamedIdentity(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  index: number\n): Promise<NamedIdentityType> {\n  const keyInfo = await getOwnerKeyInfo(network, mnemonic, index);\n  const idInfo = {\n    name: '',\n    idAddress: keyInfo.idAddress,\n    privateKey: keyInfo.privateKey,\n    index: index,\n    profile: {},\n    profileUrl: '',\n  };\n  return idInfo;\n}\n\n/*\n * Send a JSON HTTP response\n */\nfunction sendJSON(res: express.Response, data: Object, statusCode: number) {\n  logger.info(`Respond ${statusCode}: ${JSON.stringify(data)}`);\n  res.writeHead(statusCode, { 'Content-Type': 'application/json' });\n  res.write(JSON.stringify(data));\n  res.end();\n}\n\n/*\n * Get all of a 12-word phrase's identities, profiles, and Gaia connections.\n * Returns a Promise to an Array of NamedIdentityType instances.\n *\n * NOTE: should be the *only* promise chain running!\n */\nasync function getIdentityInfo(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  _appGaiaHub: string,\n  _profileGaiaHub: string\n): Promise<NamedIdentityType[]> {\n  network.setCoerceMainnetAddress(true); // for lookups in regtest\n  let identities: NamedIdentityType[];\n\n  try {\n    // load up all of our identity addresses and profile URLs\n    identities = await loadNamedIdentities(network, mnemonic);\n    const nameInfoPromises = identities.map(id => {\n      const lookup: Promise<{\n        profile: any;\n        profileUrl?: string;\n        zonefile?: string;\n      } | null> = nameLookup(network, id.name, true).catch(() => null);\n      return lookup;\n    });\n\n    let nameDatas = await Promise.all(nameInfoPromises);\n\n    network.setCoerceMainnetAddress(false);\n    nameDatas = nameDatas.filter(p => p !== null && p !== undefined);\n\n    for (let i = 0; i < nameDatas.length; i++) {\n      if (nameDatas[i]!.hasOwnProperty('error') && (nameDatas[i] as any).error) {\n        // no data for this name\n        identities[i].profileUrl = '';\n      } else {\n        identities[i].profileUrl = nameDatas[i]!.profileUrl!;\n        identities[i].profile = nameDatas[i]!.profile;\n      }\n    }\n\n    const nextIndex = identities.length + 1;\n\n    // ignore identities with no data\n    identities = identities.filter(id => !!id.profileUrl);\n\n    // add in the next non-named identity\n    identities.push(await loadUnnamedIdentity(network, mnemonic, nextIndex));\n  } catch (e) {\n    network.setCoerceMainnetAddress(false);\n    throw e;\n  }\n\n  return identities;\n}\n\n/*\n * Handle GET /auth?authRequest=...\n * If the authRequest is verifiable and well-formed, and if we can fetch the application\n * manifest, then we can render an auth page to the user.\n * Serves back the sign-in page on success.\n * Serves back an error page on error.\n * Returns a Promise that resolves to nothing.\n *\n * NOTE: should be the *only* promise chain running!\n */\nexport async function handleAuth(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  gaiaHubUrl: string,\n  profileGaiaHub: string,\n  port: number,\n  req: express.Request,\n  res: express.Response\n): Promise<any> {\n  const authToken = req.query.authRequest as string;\n  if (!authToken) {\n    return Promise.resolve().then(() => {\n      sendJSON(res, { error: 'No authRequest given' }, 400);\n    });\n  }\n\n  let errorMsg = '';\n  let identities: NamedIdentityType[] = [];\n\n  try {\n    identities = await getIdentityInfo(network, mnemonic, gaiaHubUrl, profileGaiaHub);\n\n    errorMsg = 'Unable to verify authentication token';\n    const valid = await blockstack.verifyAuthRequest(authToken);\n\n    if (!valid) {\n      errorMsg = 'Invalid authentication token: could not verify';\n      throw new Error(errorMsg);\n    }\n    errorMsg = 'Unable to fetch app manifest';\n    const appManifest = await blockstack.fetchAppManifest(authToken);\n\n    errorMsg = 'Unable to decode token';\n    const decodedAuthToken = jsontokens.decodeToken(authToken);\n    const decodedAuthPayload = decodedAuthToken.payload;\n    if (!decodedAuthPayload) {\n      errorMsg = 'Invalid authentication token: no payload';\n      throw new Error(errorMsg);\n    }\n\n    errorMsg = 'Unable to make auth page';\n\n    // make sign-in page\n    const authPage = await makeAuthPage(\n      network,\n      port,\n      mnemonic,\n      gaiaHubUrl,\n      appManifest,\n      decodedAuthPayload as AuthRequestType,\n      identities\n    );\n\n    res.writeHead(200, { 'Content-Type': 'text/html', 'Content-Length': authPage.length });\n    res.write(authPage);\n    res.end();\n  } catch (e) {\n    if (!errorMsg) {\n      errorMsg = e.message;\n    }\n\n    console.log(e.stack);\n    logger.error(errorMsg);\n    sendJSON(res, { error: `Unable to authenticate app request: ${errorMsg}` }, 400);\n  }\n}\n\n/*\n * Update a named identity's profile with new app data, if necessary.\n * Indicates whether or not the profile was changed.\n */\nfunction updateProfileApps(\n  network: CLINetworkAdapter,\n  id: NamedIdentityType,\n  appOrigin: string,\n  appGaiaConfig: GaiaHubConfig,\n  profile?: any\n): Promise<{ profile: any; changed: boolean }> {\n  let needProfileUpdate = false;\n\n  // go get the profile from the profile URL in the id\n  const profilePromise = Promise.resolve().then(() => {\n    if (profile === null || profile === undefined) {\n      return nameLookup(network, id.name).catch(_e => null);\n    } else {\n      return { profile: profile };\n    }\n  });\n\n  return profilePromise.then(profileData => {\n    if (profileData) {\n      profile = profileData.profile;\n    }\n\n    if (!profile) {\n      // instantiate\n      logger.debug(`Profile for ${id.name} is ${JSON.stringify(profile)}`);\n      logger.debug(`Instantiating profile for ${id.name}`);\n      needProfileUpdate = true;\n      profile = {\n        type: '@Person',\n        account: [],\n        apps: {},\n      };\n    }\n\n    // do we need to update the Gaia hub read URL in the profile?\n    if (profile.apps === null || profile.apps === undefined) {\n      needProfileUpdate = true;\n\n      logger.debug(`Adding multi-reader Gaia links to profile for ${id.name}`);\n      profile.apps = {};\n    }\n\n    const gaiaPrefix = `${appGaiaConfig.url_prefix}${appGaiaConfig.address}/`;\n\n    if (!profile.apps.hasOwnProperty(appOrigin) || !profile.apps[appOrigin]) {\n      needProfileUpdate = true;\n      logger.debug(\n        `Setting Gaia read URL ${gaiaPrefix} for ${appOrigin} ` + `in profile for ${id.name}`\n      );\n\n      profile.apps[appOrigin] = gaiaPrefix;\n    } else if (!profile.apps[appOrigin].startsWith(gaiaPrefix)) {\n      needProfileUpdate = true;\n      logger.debug(\n        `Overriding Gaia read URL for ${appOrigin} from ${profile.apps[appOrigin]} ` +\n          `to ${gaiaPrefix} in profile for ${id.name}`\n      );\n\n      profile.apps[appOrigin] = gaiaPrefix;\n    }\n\n    return { profile, changed: needProfileUpdate };\n  });\n}\n\n/*\n * Updates a named identitie's profile's API settings, if necessary.\n * Indicates whether or not the profile data changed.\n */\nfunction updateProfileAPISettings(\n  network: CLINetworkAdapter,\n  id: NamedIdentityType,\n  appGaiaConfig: GaiaHubConfig,\n  profile?: any\n): Promise<{ profile: any; changed: boolean }> {\n  let needProfileUpdate = false;\n\n  // go get the profile from the profile URL in the id\n  const profilePromise = Promise.resolve().then(() => {\n    if (profile === null || profile === undefined) {\n      return nameLookup(network, id.name).catch(_e => null);\n    } else {\n      return { profile: profile };\n    }\n  });\n\n  return profilePromise.then(profileData => {\n    if (profileData) {\n      profile = profileData.profile;\n    }\n\n    if (!profile) {\n      // instantiate\n      logger.debug(`Profile for ${id.name} is ${JSON.stringify(profile)}`);\n      logger.debug(`Instantiating profile for ${id.name}`);\n      needProfileUpdate = true;\n      profile = {\n        type: '@Person',\n        account: [],\n        api: {},\n      };\n    }\n\n    // do we need to update the API settings in the profile?\n    if (profile.api === null || profile.api === undefined) {\n      needProfileUpdate = true;\n\n      logger.debug(`Adding API settings to profile for ${id.name}`);\n      profile.api = {\n        gaiaHubConfig: {\n          url_prefix: appGaiaConfig.url_prefix,\n        },\n        gaiaHubUrl: appGaiaConfig.server,\n      };\n    }\n\n    if (\n      !profile.hasOwnProperty('api') ||\n      !profile.api.hasOwnProperty('gaiaHubConfig') ||\n      !profile.api.gaiaHubConfig.hasOwnProperty('url_prefix') ||\n      !profile.api.gaiaHubConfig.url_prefix ||\n      !profile.api.hasOwnProperty('gaiaHubUrl') ||\n      !profile.api.gaiaHubUrl\n    ) {\n      logger.debug(`Existing profile for ${id.name} is ${JSON.stringify(profile)}`);\n      logger.debug(`Updating API settings to profile for ${id.name}`);\n      profile.api = {\n        gaiaHubConfig: {\n          url_prefix: appGaiaConfig.url_prefix,\n        },\n        gaiaHubUrl: appGaiaConfig.server,\n      };\n    }\n\n    return { profile, changed: needProfileUpdate };\n  });\n}\n\n/*\n * Handle GET /signin?encAuthResponse=...\n * Takes an encrypted authResponse from the page generated on GET /auth?authRequest=....,\n * verifies it, updates the name's profile's app's entry with the latest Gaia\n * hub information (if necessary), and redirects the user back to the application.\n *\n * If adminKey is given, then the new app private key will be automatically added\n * as an authorized writer to the Gaia hub.\n *\n * Redirects the user on success.\n * Sends the user an error page on failure.\n * Returns a Promise that resolves to nothing.\n */\nexport async function handleSignIn(\n  network: CLINetworkAdapter,\n  mnemonic: string,\n  appGaiaHub: string,\n  profileGaiaHub: string,\n  req: express.Request,\n  res: express.Response\n): Promise<any> {\n  const authResponseQP = req.query.authResponse as string;\n  if (!authResponseQP) {\n    return Promise.resolve().then(() => {\n      sendJSON(res, { error: 'No authResponse given' }, 400);\n    });\n  }\n  const nameLookupUrl = `${network.legacyNetwork.blockstackAPIUrl}/v1/names/`;\n\n  let errorMsg = '';\n  let errorStatusCode = 400;\n  let authResponsePayload: any;\n\n  let id: NamedIdentityType;\n  let profileUrl: string;\n  let appOrigin: string;\n  let redirectUri: string;\n  let scopes: string[];\n  let authResponse: string;\n  let hubConfig: GaiaHubConfig;\n  let needProfileAPIUpdate = false;\n  let profileAPIUpdate: boolean;\n\n  try {\n    const valid = await blockstack.verifyAuthResponse(authResponseQP, nameLookupUrl);\n    if (!valid) {\n      errorMsg = `Unable to verify authResponse token ${authResponseQP}`;\n      throw new Error(errorMsg);\n    }\n\n    const authResponseToken = jsontokens.decodeToken(authResponseQP);\n    authResponsePayload = authResponseToken.payload;\n\n    id = authResponsePayload.metadata.id;\n    profileUrl = authResponsePayload.metadata.profileUrl;\n    appOrigin = authResponsePayload.metadata.appOrigin;\n    redirectUri = authResponsePayload.metadata.redirect_uri;\n    scopes = authResponsePayload.metadata.scopes;\n    const nonce = authResponsePayload.metadata.nonce;\n\n    if (nonce != authTransitNonce) {\n      throw new Error('Invalid auth response: not generated by this authenticator');\n    }\n\n    // restore\n    id.privateKey = (await getOwnerKeyInfo(network, mnemonic, id.index)).privateKey;\n\n    const appPrivateKey = await getAppPrivateKey(network, mnemonic, id, appOrigin);\n\n    // remove sensitive (CLI-specific) information\n    authResponsePayload.metadata = {\n      profileUrl: profileUrl,\n    };\n\n    authResponse = new jsontokens.TokenSigner('ES256K', id.privateKey).sign(authResponsePayload);\n\n    logger.debug(`App ${appOrigin} requests scopes ${JSON.stringify(scopes)}`);\n\n    // connect to the app gaia hub\n    const appHubConfig = await gaiaConnect(network, appGaiaHub, appPrivateKey);\n\n    hubConfig = appHubConfig;\n    let newProfileData = await updateProfileAPISettings(network, id, hubConfig);\n\n    needProfileAPIUpdate = newProfileData.changed;\n    profileAPIUpdate = newProfileData.profile;\n    newProfileData = await updateProfileApps(network, id, appOrigin, hubConfig, profileAPIUpdate);\n\n    const profile = newProfileData.profile;\n    const needProfileSigninUpdate = newProfileData.changed && scopes.includes('store_write');\n\n    logger.debug(`Resulting profile for ${id.name} is ${JSON.stringify(profile)}`);\n\n    let gaiaUrls: any;\n\n    // sign and replicate new profile if we need to.\n    // otherwise do nothing\n    if (needProfileSigninUpdate) {\n      logger.debug(`Upload new profile with new sign-in data to ${profileGaiaHub}`);\n      const profileJWT = makeProfileJWT(profile, id.privateKey);\n      gaiaUrls = await gaiaUploadProfileAll(\n        network,\n        [profileGaiaHub],\n        profileJWT,\n        id.privateKey,\n        id.name\n      );\n    } else if (needProfileAPIUpdate) {\n      // API settings changed, but we won't be adding an app entry\n      logger.debug(`Upload new profile with new API settings to ${profileGaiaHub}`);\n      const profileJWT = makeProfileJWT(profileAPIUpdate, id.privateKey);\n      gaiaUrls = await gaiaUploadProfileAll(\n        network,\n        [profileGaiaHub],\n        profileJWT,\n        id.privateKey,\n        id.name\n      );\n    } else {\n      logger.debug(`Gaia read URL for ${appOrigin} is ${profile.apps[appOrigin]}`);\n      gaiaUrls = { dataUrls: [], error: null };\n    }\n\n    if (gaiaUrls.hasOwnProperty('error') && gaiaUrls.error) {\n      errorMsg = `Failed to upload new profile: ${gaiaUrls.error}`;\n      errorStatusCode = 502;\n      throw new Error(errorMsg);\n    }\n\n    // success!\n    // redirect to application\n    logger.debug(`Handled sign-in to ${appOrigin} using ${id.name}`);\n    const appUri = blockstack.updateQueryStringParameter(redirectUri, 'authResponse', authResponse);\n\n    logger.info(`Redirect to ${appUri}`);\n    res.writeHead(302, { Location: appUri });\n    res.end();\n  } catch (e) {\n    logger.error(e);\n    logger.error(errorMsg);\n    sendJSON(res, { error: `Unable to process signin request: ${errorMsg}` }, errorStatusCode);\n  }\n}\n","import * as blockstack from 'blockstack';\nimport * as bitcoin from 'bitcoinjs-lib';\nimport * as process from 'process';\nimport * as fs from 'fs';\nimport * as winston from 'winston';\nimport cors from 'cors';\n\nimport BN from 'bn.js';\nimport * as crypto from 'crypto';\nimport * as bip39 from 'bip39';\nimport express from 'express';\nimport * as path from 'path';\nimport { prompt } from 'inquirer';\nimport fetch from 'node-fetch';\nimport {\n  makeSTXTokenTransfer,\n  makeContractDeploy,\n  makeContractCall,\n  callReadOnlyFunction,\n  broadcastTransaction,\n  estimateTransfer,\n  estimateContractDeploy,\n  estimateContractFunctionCall,\n  SignedTokenTransferOptions,\n  ContractDeployOptions,\n  SignedContractCallOptions,\n  ReadOnlyFunctionOptions,\n  ContractCallPayload,\n  ClarityValue,\n  ClarityAbi,\n  getAbi,\n  validateContractCall,\n  PostConditionMode,\n  cvToString,\n  StacksTransaction,\n  TxBroadcastResult,\n  getAddressFromPrivateKey,\n  TransactionVersion,\n} from '@stacks/transactions';\n\nimport { StacksMainnet, StacksTestnet } from '@stacks/network';\n\nconst c32check = require('c32check');\n\nimport { UserData } from '@stacks/auth';\nimport crossfetch from 'cross-fetch';\n\nimport { StackingClient, StackerInfo } from '@stacks/stacking';\n\nimport { FaucetsApi, AccountsApi, Configuration } from '@stacks/blockchain-api-client';\n\nimport { GaiaHubConfig } from '@stacks/storage';\n\nimport {\n  getOwnerKeyInfo,\n  getPaymentKeyInfo,\n  getStacksWalletKeyInfo,\n  getApplicationKeyInfo,\n  extractAppKey,\n  STX_WALLET_COMPATIBLE_SEED_STRENGTH,\n  PaymentKeyInfoType,\n  OwnerKeyInfoType,\n  StacksKeyInfoType,\n} from './keys';\n\nimport {\n  CLI_ARGS,\n  getCLIOpts,\n  CLIOptAsString,\n  CLIOptAsStringArray,\n  CLIOptAsBool,\n  checkArgs,\n  loadConfig,\n  makeCommandUsageString,\n  makeAllCommandsList,\n  USAGE,\n  DEFAULT_CONFIG_PATH,\n  DEFAULT_CONFIG_REGTEST_PATH,\n  DEFAULT_CONFIG_TESTNET_PATH,\n  ID_ADDRESS_PATTERN,\n  STACKS_ADDRESS_PATTERN,\n  DEFAULT_MAX_ID_SEARCH_INDEX,\n} from './argparse';\n\nimport { encryptBackupPhrase, decryptBackupPhrase } from './encrypt';\n\nimport { CLINetworkAdapter, CLI_NETWORK_OPTS, getNetwork, NameInfoType } from './network';\n\nimport { gaiaAuth, gaiaConnect, gaiaUploadProfileAll, getGaiaAddressFromProfile } from './data';\n\nimport {\n  JSONStringify,\n  getPrivateKeyAddress,\n  canonicalPrivateKey,\n  decodePrivateKey,\n  makeProfileJWT,\n  getNameInfoEasy,\n  getpass,\n  getBackupPhrase,\n  mkdirs,\n  getIDAddress,\n  IDAppKeys,\n  getIDAppKeys,\n  makePromptsFromArgList,\n  parseClarityFunctionArgAnswers,\n  ClarityFunctionArg,\n  generateExplorerTxPageUrl,\n} from './utils';\n\nimport { handleAuth, handleSignIn } from './auth';\n\n// global CLI options\nlet txOnly = false;\nlet estimateOnly = false;\nlet safetyChecks = true;\nlet receiveFeesPeriod = 52595;\nlet gracePeriod = 5000;\nlet noExit = false;\nlet maxIDSearchIndex = DEFAULT_MAX_ID_SEARCH_INDEX;\n\nlet BLOCKSTACK_TEST = !!process.env.BLOCKSTACK_TEST;\n\nexport function getMaxIDSearchIndex() {\n  return maxIDSearchIndex;\n}\n\nexport interface WhoisInfoType {\n  address: string;\n  blockchain: string;\n  block_renewed_at: number;\n  did: string;\n  expire_block: number;\n  grace_period: number;\n  last_transaction_height: number;\n  last_txid: string;\n  owner_address: string;\n  owner_script: string;\n  renewal_deadline: number;\n  resolver: string | null;\n  status: string;\n  zonefile: string | null;\n  zonefile_hash: string | null;\n}\n\n/*\n * Sign a profile.\n * @path (string) path to the profile\n * @privateKey (string) the owner key (must be single-sig)\n */\n// TODO: fix, network is never used\n// @ts-ignore\nfunction profileSign(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const profilePath = args[0];\n  const profileData = JSON.parse(fs.readFileSync(profilePath).toString());\n  return Promise.resolve().then(() => makeProfileJWT(profileData, args[1]));\n}\n\n/*\n * Verify a profile with an address or public key\n * @path (string) path to the profile\n * @publicKeyOrAddress (string) public key or address\n */\nfunction profileVerify(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const profilePath = args[0];\n  let publicKeyOrAddress = args[1];\n\n  // need to coerce mainnet\n  if (publicKeyOrAddress.match(ID_ADDRESS_PATTERN)) {\n    publicKeyOrAddress = network.coerceMainnetAddress(publicKeyOrAddress.slice(3));\n  }\n\n  const profileString = fs.readFileSync(profilePath).toString();\n\n  return Promise.resolve().then(() => {\n    let profileToken = null;\n\n    try {\n      const profileTokens = JSON.parse(profileString);\n      profileToken = profileTokens[0].token;\n    } catch (e) {\n      // might be a raw token\n      profileToken = profileString;\n    }\n\n    if (!profileToken) {\n      throw new Error(`Data at ${profilePath} does not appear to be a signed profile`);\n    }\n\n    const profile = blockstack.extractProfile(profileToken, publicKeyOrAddress);\n    return JSONStringify(profile);\n  });\n}\n\n/*\n * Store a signed profile for a name or an address.\n * * verify that the profile was signed by the name's owner address\n * * verify that the private key matches the name's owner address\n *\n * Assumes that the URI records are all Gaia hubs\n *\n * @nameOrAddress (string) name or address that owns the profile\n * @path (string) path to the signed profile token\n * @privateKey (string) owner private key for the name\n * @gaiaUrl (string) this is the write endpoint of the Gaia hub to use\n */\nfunction profileStore(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const nameOrAddress = args[0];\n  const signedProfilePath = args[1];\n  const privateKey = decodePrivateKey(args[2]);\n  const gaiaHubUrl = args[3];\n\n  const signedProfileData = fs.readFileSync(signedProfilePath).toString();\n\n  const ownerAddress = getPrivateKeyAddress(network, privateKey);\n  const ownerAddressMainnet = network.coerceMainnetAddress(ownerAddress);\n\n  let nameInfoPromise: Promise<NameInfoType | null>;\n  let name = '';\n\n  if (nameOrAddress.startsWith('ID-')) {\n    // ID-address\n    nameInfoPromise = Promise.resolve().then(() => {\n      return {\n        address: nameOrAddress.slice(3),\n      };\n    });\n  } else {\n    // name; find the address\n    nameInfoPromise = getNameInfoEasy(network, nameOrAddress);\n    name = nameOrAddress;\n  }\n\n  const verifyProfilePromise = profileVerify(network, [\n    signedProfilePath,\n    `ID-${ownerAddressMainnet}`,\n  ]);\n\n  return Promise.all([nameInfoPromise, verifyProfilePromise])\n    .then(([nameInfo, _verifiedProfile]: [NameInfoType | null, any]) => {\n      if (\n        safetyChecks &&\n        (!nameInfo ||\n          network.coerceAddress(nameInfo.address) !== network.coerceAddress(ownerAddress))\n      ) {\n        throw new Error(\n          'Name owner address either could not be found, or does not match ' +\n            `private key address ${ownerAddress}`\n        );\n      }\n      return gaiaUploadProfileAll(network, [gaiaHubUrl], signedProfileData, args[2], name);\n    })\n    .then((gaiaUrls: { dataUrls?: string[] | null; error?: string | null }) => {\n      if (gaiaUrls.hasOwnProperty('error')) {\n        return JSONStringify({ dataUrls: gaiaUrls.dataUrls!, error: gaiaUrls.error! }, true);\n      } else {\n        return JSONStringify({ profileUrls: gaiaUrls.dataUrls! });\n      }\n    });\n}\n\n/*\n * Get the app private key(s) from a backup phrase and an ID-address\n * args:\n * @mnemonic (string) the 12-word phrase\n * @nameOrIDAddress (string) the name or ID-address\n * @appOrigin (string) the application's origin URL\n */\nasync function getAppKeys(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const mnemonic = await getBackupPhrase(args[0]);\n  const nameOrIDAddress = args[1];\n  const origin = args[2];\n  const idAddress = await getIDAddress(network, nameOrIDAddress);\n  const networkInfo = await getApplicationKeyInfo(network, mnemonic, idAddress, origin);\n  return JSONStringify(networkInfo);\n}\n\n/*\n * Get the owner private key(s) from a backup phrase\n * args:\n * @mnemonic (string) the 12-word phrase\n * @max_index (integer) (optional) the profile index maximum\n */\nasync function getOwnerKeys(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const mnemonic = await getBackupPhrase(args[0]);\n  let maxIndex = 1;\n  if (args.length > 1 && !!args[1]) {\n    maxIndex = parseInt(args[1]);\n  }\n\n  const keyInfo: OwnerKeyInfoType[] = [];\n  for (let i = 0; i < maxIndex; i++) {\n    keyInfo.push(await getOwnerKeyInfo(network, mnemonic, i));\n  }\n\n  return JSONStringify(keyInfo);\n}\n\n/*\n * Get the payment private key from a backup phrase\n * args:\n * @mnemonic (string) the 12-word phrase\n */\nasync function getPaymentKey(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const mnemonic = await getBackupPhrase(args[0]);\n  // keep the return value consistent with getOwnerKeys\n  const keyObj = await getPaymentKeyInfo(network, mnemonic);\n  const keyInfo: PaymentKeyInfoType[] = [];\n  keyInfo.push(keyObj);\n  return JSONStringify(keyInfo);\n}\n\n/*\n * Get the payment private key from a backup phrase used by the Stacks wallet\n * args:\n * @mnemonic (string) the 24-word phrase\n */\nasync function getStacksWalletKey(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const mnemonic = await getBackupPhrase(args[0]);\n  // keep the return value consistent with getOwnerKeys\n  const keyObj = await getStacksWalletKeyInfo(network, mnemonic);\n  const keyInfo: StacksKeyInfoType[] = [];\n  keyInfo.push(keyObj);\n  return JSONStringify(keyInfo);\n}\n\n/*\n * Make a private key and output it\n * args:\n * @mnemonic (string) OPTIONAL; the 12-word phrase\n */\nasync function makeKeychain(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  let mnemonic: string;\n  if (args[0]) {\n    mnemonic = await getBackupPhrase(args[0]);\n  } else {\n    mnemonic = await bip39.generateMnemonic(\n      STX_WALLET_COMPATIBLE_SEED_STRENGTH,\n      crypto.randomBytes\n    );\n  }\n\n  const stacksKeyInfo = await getStacksWalletKeyInfo(network, mnemonic);\n  return JSONStringify({\n    mnemonic: mnemonic,\n    keyInfo: stacksKeyInfo,\n  });\n}\n\n/*\n * Get an address's tokens and their balances.\n * Takes either a Bitcoin or Stacks address\n * args:\n * @address (string) the address\n */\nfunction balance(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  let address = args[0];\n\n  if (BLOCKSTACK_TEST) {\n    // force testnet address if we're in regtest or testnet mode\n    address = network.coerceAddress(address);\n  }\n\n  // temporary hack to use network config from stacks-transactions lib\n  const txNetwork = network.isMainnet() ? new StacksMainnet() : new StacksTestnet();\n  txNetwork.coreApiUrl = network.legacyNetwork.blockstackAPIUrl;\n\n  return fetch(txNetwork.getAccountApiUrl(address))\n    .then(response => response.json())\n    .then(response => {\n      let balanceHex = response.balance;\n      if (response.balance.startsWith('0x')) {\n        balanceHex = response.balance.substr(2);\n      }\n      let lockedHex = response.locked;\n      if (response.locked.startsWith('0x')) {\n        lockedHex = response.locked.substr(2);\n      }\n      let unlockHeight = response.unlock_height;\n      const balance = new BN(balanceHex, 16);\n      const locked = new BN(lockedHex, 16);\n      const res = {\n        balance: balance.toString(10),\n        locked: locked.toString(10),\n        unlock_height: unlockHeight,\n        nonce: response.nonce,\n      };\n      return Promise.resolve(JSONStringify(res));\n    });\n}\n\n/*\n * Get a page of the account's history\n * args:\n * @address (string) the account address\n * @page (int) the page of the history to fetch (optional)\n */\nfunction getAccountHistory(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const address = c32check.c32ToB58(args[0]);\n\n  if (args.length >= 2 && !!args[1]) {\n    const page = parseInt(args[1]);\n    return Promise.resolve()\n      .then(() => {\n        return network.getAccountHistoryPage(address, page);\n      })\n      .then(accountStates =>\n        JSONStringify(\n          accountStates.map((s: any) => {\n            const new_s = {\n              address: c32check.b58ToC32(s.address),\n              credit_value: s.credit_value.toString(),\n              debit_value: s.debit_value.toString(),\n            };\n            return new_s;\n          })\n        )\n      );\n  } else {\n    // all pages\n    let history: any[] = [];\n\n    function getAllAccountHistoryPages(page: number): Promise<any[]> {\n      return network.getAccountHistoryPage(address, page).then((results: any[]) => {\n        if (results.length == 0) {\n          return history;\n        } else {\n          history = history.concat(results);\n          return getAllAccountHistoryPages(page + 1);\n        }\n      });\n    }\n\n    return getAllAccountHistoryPages(0).then((accountStates: any[]) =>\n      JSONStringify(\n        accountStates.map((s: any) => {\n          const new_s = {\n            address: c32check.b58ToC32(s.address),\n            credit_value: s.credit_value.toString(),\n            debit_value: s.debit_value.toString(),\n          };\n          return new_s;\n        })\n      )\n    );\n  }\n}\n\n// /*\n//  * Get the account's state(s) at a particular block height\n//  * args:\n//  * @address (string) the account address\n//  * @blockHeight (int) the height at which to query\n//  */\n// function getAccountAt(network: CLINetworkAdapter, args: string[]) : Promise<string> {\n//   const address = c32check.c32ToB58(args[0]);\n//   const blockHeight = parseInt(args[1]);\n\n//   return Promise.resolve().then(() => {\n//     return network.getAccountAt(address, blockHeight);\n//   })\n//     .then(accountStates => accountStates.map((s : any) => {\n//       const new_s = {\n//         address: c32check.b58ToC32(s.address),\n//         credit_value: s.credit_value.toString(),\n//         debit_value: s.debit_value.toString()\n//       };\n//       return new_s;\n//     }))\n//     .then(history => JSONStringify(history));\n// }\n\n// /*\n//  * Sends BTC from one private key to another address\n//  * args:\n//  * @recipientAddress (string) the recipient's address\n//  * @amount (string) the amount of BTC to send\n//  * @privateKey (string) the private key that owns the BTC\n//  */\n// function sendBTC(network: CLINetworkAdapter, args: string[]) : Promise<string> {\n//   const destinationAddress = args[0];\n//   const amount = parseInt(args[1]);\n//   const paymentKeyHex = decodePrivateKey(args[2]);\n\n//   if (amount <= 5500) {\n//     throw new Error('Invalid amount (must be greater than 5500)');\n//   }\n\n//   let paymentKey;\n//   if (typeof paymentKeyHex === 'string') {\n//     // single-sig\n//     paymentKey = blockstack.PubkeyHashSigner.fromHexString(paymentKeyHex);\n//   }\n//   else {\n//     // multi-sig or segwit\n//     paymentKey = paymentKeyHex;\n//   }\n\n//   const txPromise = blockstack.transactions.makeBitcoinSpend(destinationAddress, paymentKey, amount, !hasKeys(paymentKeyHex))\n//     .catch((e : Error) => {\n//       if (e.name === 'InvalidAmountError') {\n//         return JSONStringify({\n//           'status': false,\n//           'error': e.message\n//         }, true);\n//       }\n//       else {\n//         throw e;\n//       }\n//     });\n\n//   if (txOnly) {\n//     return txPromise;\n//   }\n//   else {\n//     return txPromise.then((tx : string) => {\n//       return network.broadcastTransaction(tx);\n//     })\n//       .then((txid : string) => {\n//         return txid;\n//       });\n//   }\n// }\n\n/*\n * Send tokens from one account private key to another account's address.\n * args:\n * @recipientAddress (string) the recipient's account address\n * @tokenAmount (int) the number of tokens to send\n * @fee (int) the transaction fee to be paid\n * @nonce (int) integer nonce needs to be incremented after each transaction from an account\n * @privateKey (string) the hex-encoded private key to use to send the tokens\n * @memo (string) OPTIONAL: a 34-byte memo to include\n */\nasync function sendTokens(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const recipientAddress = args[0];\n  const tokenAmount = new BN(args[1]);\n  const fee = new BN(args[2]);\n  const nonce = new BN(args[3]);\n  const privateKey = args[4];\n\n  let memo = '';\n\n  if (args.length > 4 && !!args[5]) {\n    memo = args[5];\n  }\n\n  // temporary hack to use network config from stacks-transactions lib\n  const txNetwork = network.isMainnet() ? new StacksMainnet() : new StacksTestnet();\n  txNetwork.coreApiUrl = network.legacyNetwork.blockstackAPIUrl;\n\n  const options: SignedTokenTransferOptions = {\n    recipient: recipientAddress,\n    amount: tokenAmount,\n    senderKey: privateKey,\n    fee,\n    nonce,\n    memo,\n    network: txNetwork,\n  };\n\n  const tx: StacksTransaction = await makeSTXTokenTransfer(options);\n\n  if (estimateOnly) {\n    return estimateTransfer(tx, txNetwork).then(cost => {\n      return cost.toString(10);\n    });\n  }\n\n  if (txOnly) {\n    return Promise.resolve(tx.serialize().toString('hex'));\n  }\n\n  return broadcastTransaction(tx, txNetwork)\n    .then((response: TxBroadcastResult) => {\n      if (response.hasOwnProperty('error')) {\n        return response;\n      }\n      return {\n        txid: `0x${tx.txid()}`,\n        transaction: generateExplorerTxPageUrl(tx.txid(), txNetwork),\n      };\n    })\n    .catch(error => {\n      return error.toString();\n    });\n}\n\n/*\n * Depoly a Clarity smart contract.\n * args:\n * @source (string) path to the contract source file\n * @contractName (string) the name of the contract\n * @fee (int) the transaction fee to be paid\n * @nonce (int) integer nonce needs to be incremented after each transaction from an account\n * @privateKey (string) the hex-encoded private key to use to send the tokens\n */\nasync function contractDeploy(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const sourceFile = args[0];\n  const contractName = args[1];\n  const fee = new BN(args[2]);\n  const nonce = new BN(args[3]);\n  const privateKey = args[4];\n\n  const source = fs.readFileSync(sourceFile).toString();\n\n  // temporary hack to use network config from stacks-transactions lib\n  const txNetwork = network.isMainnet() ? new StacksMainnet() : new StacksTestnet();\n  txNetwork.coreApiUrl = network.legacyNetwork.blockstackAPIUrl;\n\n  const options: ContractDeployOptions = {\n    contractName,\n    codeBody: source,\n    senderKey: privateKey,\n    fee,\n    nonce,\n    network: txNetwork,\n    postConditionMode: PostConditionMode.Allow,\n  };\n\n  const tx = await makeContractDeploy(options);\n\n  if (estimateOnly) {\n    return estimateContractDeploy(tx, txNetwork).then(cost => {\n      return cost.toString(10);\n    });\n  }\n\n  if (txOnly) {\n    return Promise.resolve(tx.serialize().toString('hex'));\n  }\n\n  return broadcastTransaction(tx, txNetwork)\n    .then(response => {\n      if (response.hasOwnProperty('error')) {\n        return response;\n      }\n      return {\n        txid: `0x${tx.txid()}`,\n        transaction: generateExplorerTxPageUrl(tx.txid(), txNetwork),\n      };\n    })\n    .catch(error => {\n      return error.toString();\n    });\n}\n\n/*\n * Call a Clarity smart contract function.\n * args:\n * @contractAddress (string) the address of the contract\n * @contractName (string) the name of the contract\n * @functionName (string) the name of the function to call\n * @fee (int) the transaction fee to be paid\n * @nonce (int) integer nonce needs to be incremented after each transaction from an account\n * @privateKey (string) the hex-encoded private key to use to send the tokens\n */\nasync function contractFunctionCall(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const contractAddress = args[0];\n  const contractName = args[1];\n  const functionName = args[2];\n  const fee = new BN(args[3]);\n  const nonce = new BN(args[4]);\n  const privateKey = args[5];\n\n  // temporary hack to use network config from stacks-transactions lib\n  const txNetwork = network.isMainnet() ? new StacksMainnet() : new StacksTestnet();\n  txNetwork.coreApiUrl = network.legacyNetwork.blockstackAPIUrl;\n\n  let abi: ClarityAbi;\n  let abiArgs: ClarityFunctionArg[];\n  let functionArgs: ClarityValue[] = [];\n\n  return getAbi(contractAddress, contractName, txNetwork)\n    .then(responseAbi => {\n      abi = responseAbi;\n      const filtered = abi.functions.filter(fn => fn.name === functionName);\n      if (filtered.length === 1) {\n        abiArgs = filtered[0].args;\n        return makePromptsFromArgList(abiArgs);\n      } else {\n        return null;\n      }\n    })\n    .then(prompts => prompt(prompts!))\n    .then(answers => {\n      functionArgs = parseClarityFunctionArgAnswers(answers, abiArgs);\n\n      const options: SignedContractCallOptions = {\n        contractAddress,\n        contractName,\n        functionName,\n        functionArgs,\n        senderKey: privateKey,\n        fee,\n        nonce,\n        network: txNetwork,\n        postConditionMode: PostConditionMode.Allow,\n      };\n\n      return makeContractCall(options);\n    })\n    .then(tx => {\n      if (!validateContractCall(tx.payload as ContractCallPayload, abi)) {\n        throw new Error('Failed to validate function arguments against ABI');\n      }\n\n      if (estimateOnly) {\n        return estimateContractFunctionCall(tx, txNetwork).then(cost => {\n          return cost.toString(10);\n        });\n      }\n\n      if (txOnly) {\n        return Promise.resolve(tx.serialize().toString('hex'));\n      }\n\n      return broadcastTransaction(tx, txNetwork)\n        .then(response => {\n          if (response.hasOwnProperty('error')) {\n            return response;\n          }\n          return {\n            txid: `0x${tx.txid()}`,\n            transaction: generateExplorerTxPageUrl(tx.txid(), txNetwork),\n          };\n        })\n        .catch(error => {\n          return error.toString();\n        });\n    });\n}\n\n/*\n * Call a read-only Clarity smart contract function.\n * args:\n * @contractAddress (string) the address of the contract\n * @contractName (string) the name of the contract\n * @functionName (string) the name of the function to call\n * @senderAddress (string) the sender address\n */\nasync function readOnlyContractFunctionCall(\n  network: CLINetworkAdapter,\n  args: string[]\n): Promise<string> {\n  const contractAddress = args[0];\n  const contractName = args[1];\n  const functionName = args[2];\n  const senderAddress = args[3];\n\n  // temporary hack to use network config from stacks-transactions lib\n  const txNetwork = network.isMainnet() ? new StacksMainnet() : new StacksTestnet();\n  txNetwork.coreApiUrl = network.legacyNetwork.blockstackAPIUrl;\n\n  let abi: ClarityAbi;\n  let abiArgs: ClarityFunctionArg[];\n  let functionArgs: ClarityValue[] = [];\n\n  return getAbi(contractAddress, contractName, txNetwork)\n    .then(responseAbi => {\n      abi = responseAbi;\n      const filtered = abi.functions.filter(fn => fn.name === functionName);\n      if (filtered.length === 1) {\n        abiArgs = filtered[0].args;\n        return makePromptsFromArgList(abiArgs);\n      } else {\n        return null;\n      }\n    })\n    .then(prompts => prompt(prompts!))\n    .then(answers => {\n      functionArgs = parseClarityFunctionArgAnswers(answers, abiArgs);\n\n      const options: ReadOnlyFunctionOptions = {\n        contractAddress,\n        contractName,\n        functionName,\n        functionArgs,\n        senderAddress,\n        network: txNetwork,\n      };\n\n      return callReadOnlyFunction(options);\n    })\n    .then(returnValue => {\n      return cvToString(returnValue);\n    })\n    .catch(error => {\n      return error.toString();\n    });\n}\n\n// /*\n//  * Get the number of confirmations of a txid.\n//  * args:\n//  * @txid (string) the transaction ID as a hex string\n//  */\n// function getConfirmations(network: CLINetworkAdapter, args: string[]) : Promise<string> {\n//   const txid = args[0];\n//   return Promise.all([network.getBlockHeight(), network.getTransactionInfo(txid)])\n//     .then(([blockHeight, txInfo]) => {\n//       return JSONStringify({\n//         'blockHeight': txInfo.block_height,\n//         'confirmations': blockHeight - txInfo.block_height + 1\n//       });\n//     })\n//     .catch((e) => {\n//       if (e.message.toLowerCase() === 'unconfirmed transaction') {\n//         return JSONStringify({\n//           'blockHeight': 'unconfirmed',\n//           'confirmations': 0\n//         });\n//       }\n//       else {\n//         throw e;\n//       }\n//     });\n// }\n\n/*\n * Get the address of a private key\n * args:\n * @private_key (string) the hex-encoded private key or key bundle\n */\nfunction getKeyAddress(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const privateKey = decodePrivateKey(args[0]);\n  return Promise.resolve().then(() => {\n    const addr = getPrivateKeyAddress(network, privateKey);\n    return JSONStringify({\n      BTC: addr,\n      STACKS: c32check.b58ToC32(addr),\n    });\n  });\n}\n\n/*\n * Get a file from Gaia.\n * args:\n * @username (string) the blockstack ID of the user who owns the data\n * @origin (string) the application origin\n * @path (string) the file to read\n * @appPrivateKey (string) OPTIONAL: the app private key to decrypt/verify with\n * @decrypt (string) OPTINOAL: if '1' or 'true', then decrypt\n * @verify (string) OPTIONAL: if '1' or 'true', then search for and verify a signature file\n *  along with the data\n */\nfunction gaiaGetFile(network: CLINetworkAdapter, args: string[]): Promise<string | Buffer> {\n  const username = args[0];\n  const origin = args[1];\n  const path = args[2];\n  let appPrivateKey = args[3];\n  let decrypt = false;\n  let verify = false;\n\n  if (!!appPrivateKey && args.length > 4 && !!args[4]) {\n    decrypt = args[4].toLowerCase() === 'true' || args[4].toLowerCase() === '1';\n  }\n\n  if (!!appPrivateKey && args.length > 5 && !!args[5]) {\n    verify = args[5].toLowerCase() === 'true' || args[5].toLowerCase() === '1';\n  }\n\n  if (!appPrivateKey) {\n    // make a fake private key (it won't be used)\n    appPrivateKey = 'fda1afa3ff9ef25579edb5833b825ac29fae82d03db3f607db048aae018fe882';\n  }\n\n  // force mainnet addresses\n  blockstack.config.network.layer1 = bitcoin.networks.bitcoin;\n  return gaiaAuth(network, appPrivateKey, null)\n    .then((_userData: UserData) =>\n      blockstack.getFile(path, {\n        decrypt: decrypt,\n        verify: verify,\n        app: origin,\n        username: username,\n      })\n    )\n    .then((data: ArrayBuffer | Buffer | string) => {\n      if (data instanceof ArrayBuffer) {\n        return Buffer.from(data);\n      } else {\n        return data;\n      }\n    });\n}\n\n/*\n * Put a file into a Gaia hub\n * args:\n * @hubUrl (string) the URL to the write endpoint of the gaia hub\n * @appPrivateKey (string) the private key used to authenticate to the gaia hub\n * @dataPath (string) the path (on disk) to the data to store\n * @gaiaPath (string) the path (in Gaia) where the data will be stored\n * @encrypt (string) OPTIONAL: if '1' or 'true', then encrypt the file\n * @sign (string) OPTIONAL: if '1' or 'true', then sign the file and store the signature too.\n */\nfunction gaiaPutFile(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const hubUrl = args[0];\n  const appPrivateKey = args[1];\n  const dataPath = args[2];\n  const gaiaPath = path.normalize(args[3].replace(/^\\/+/, ''));\n\n  let encrypt = false;\n  let sign = false;\n\n  if (args.length > 4 && !!args[4]) {\n    encrypt = args[4].toLowerCase() === 'true' || args[4].toLowerCase() === '1';\n  }\n  if (args.length > 5 && !!args[5]) {\n    sign = args[5].toLowerCase() === 'true' || args[5].toLowerCase() === '1';\n  }\n\n  const data = fs.readFileSync(dataPath);\n\n  // force mainnet addresses\n  // TODO\n  blockstack.config.network.layer1 = bitcoin.networks.bitcoin;\n  return gaiaAuth(network, appPrivateKey, hubUrl)\n    .then((_userData: UserData) => {\n      return blockstack.putFile(gaiaPath, data, { encrypt: encrypt, sign: sign });\n    })\n    .then((url: string) => {\n      return JSONStringify({ urls: [url] });\n    });\n}\n\n/*\n * Delete a file in a Gaia hub\n * args:\n * @hubUrl (string) the URL to the write endpoint of the gaia hub\n * @appPrivateKey (string) the private key used to authenticate to the gaia hub\n * @gaiaPath (string) the path (in Gaia) to delete\n * @wasSigned (string) OPTIONAL: if '1' or 'true'.  Delete the signature file as well.\n */\nfunction gaiaDeleteFile(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const hubUrl = args[0];\n  const appPrivateKey = args[1];\n  const gaiaPath = path.normalize(args[2].replace(/^\\/+/, ''));\n\n  let wasSigned = false;\n\n  if (args.length > 3 && !!args[3]) {\n    wasSigned = args[3].toLowerCase() === 'true' || args[3].toLowerCase() === '1';\n  }\n\n  // force mainnet addresses\n  // TODO\n  blockstack.config.network.layer1 = bitcoin.networks.bitcoin;\n  return gaiaAuth(network, appPrivateKey, hubUrl)\n    .then((_userData: UserData) => {\n      return blockstack.deleteFile(gaiaPath, { wasSigned: wasSigned });\n    })\n    .then(() => {\n      return JSONStringify('ok');\n    });\n}\n\n/*\n * List files in a Gaia hub\n * args:\n * @hubUrl (string) the URL to the write endpoint of the gaia hub\n * @appPrivateKey (string) the private key used to authenticate to the gaia hub\n */\nfunction gaiaListFiles(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const hubUrl = args[0];\n  const appPrivateKey = args[1];\n\n  // force mainnet addresses\n  // TODO\n  let count = 0;\n  blockstack.config.network.layer1 = bitcoin.networks.bitcoin;\n  return gaiaAuth(network, canonicalPrivateKey(appPrivateKey), hubUrl)\n    .then((_userData: UserData) => {\n      return blockstack.listFiles((name: string) => {\n        // print out incrementally\n        console.log(name);\n        count += 1;\n        return true;\n      });\n    })\n    .then(() => JSONStringify(count));\n}\n\n/*\n * Group array items into batches\n */\nfunction batchify<T>(input: T[], batchSize: number = 50): T[][] {\n  const output = [];\n  let currentBatch = [];\n  for (let i = 0; i < input.length; i++) {\n    currentBatch.push(input[i]);\n    if (currentBatch.length >= batchSize) {\n      output.push(currentBatch);\n      currentBatch = [];\n    }\n  }\n  if (currentBatch.length > 0) {\n    output.push(currentBatch);\n  }\n  return output;\n}\n\n/*\n * Dump all files from a Gaia hub bucket to a directory on disk.\n * args:\n * @nameOrIDAddress (string) the name or ID address that owns the bucket to dump\n * @appOrigin (string) the application for which to dump data\n * @hubUrl (string) the URL to the write endpoint of the gaia hub\n * @mnemonic (string) the 12-word phrase or ciphertext\n * @dumpDir (string) the directory to hold the dumped files\n */\nfunction gaiaDumpBucket(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const nameOrIDAddress = args[0];\n  const appOrigin = args[1];\n  const hubUrl = args[2];\n  const mnemonicOrCiphertext = args[3];\n  let dumpDir = args[4];\n\n  if (dumpDir.length === 0) {\n    throw new Error('Invalid directory (not given)');\n  }\n  if (dumpDir[0] !== '/') {\n    // relative path.  make absolute\n    const cwd = fs.realpathSync('.');\n    dumpDir = path.normalize(`${cwd}/${dumpDir}`);\n  }\n\n  mkdirs(dumpDir);\n\n  function downloadFile(hubConfig: GaiaHubConfig, fileName: string): Promise<any> {\n    const gaiaReadUrl = `${hubConfig.url_prefix.replace(/\\/+$/, '')}/${hubConfig.address}`;\n    const fileUrl = `${gaiaReadUrl}/${fileName}`;\n    const destPath = `${dumpDir}/${fileName.replace(/\\//g, '\\\\x2f')}`;\n\n    console.log(`Download ${fileUrl} to ${destPath}`);\n    return fetch(fileUrl)\n      .then((resp: any) => {\n        if (resp.status !== 200) {\n          throw new Error(`Bad status code for ${fileUrl}: ${resp.status}`);\n        }\n\n        // javascript can be incredibly stupid at fetching data despite being a Web language...\n        const contentType = resp.headers.get('Content-Type');\n        if (\n          contentType === null ||\n          contentType.startsWith('text') ||\n          contentType === 'application/json'\n        ) {\n          return resp.text();\n        } else {\n          return resp.arrayBuffer();\n        }\n      })\n      .then((filebytes: Buffer | ArrayBuffer) => {\n        return new Promise((resolve, reject) => {\n          try {\n            fs.writeFileSync(destPath, Buffer.from(filebytes), { encoding: null, mode: 0o660 });\n            resolve();\n          } catch (e) {\n            reject(e);\n          }\n        });\n      });\n  }\n\n  // force mainnet addresses\n  // TODO: better way of doing this\n  blockstack.config.network.layer1 = bitcoin.networks.bitcoin;\n\n  const fileNames: string[] = [];\n  let gaiaHubConfig: GaiaHubConfig;\n  let appPrivateKey: string;\n  let ownerPrivateKey: string;\n\n  return getIDAppKeys(network, nameOrIDAddress, appOrigin, mnemonicOrCiphertext)\n    .then((keyInfo: IDAppKeys) => {\n      appPrivateKey = keyInfo.appPrivateKey;\n      ownerPrivateKey = keyInfo.ownerPrivateKey;\n      return gaiaAuth(network, appPrivateKey, hubUrl, ownerPrivateKey);\n    })\n    .then((_userData: UserData) => {\n      return gaiaConnect(network, hubUrl, appPrivateKey);\n    })\n    .then((hubConfig: GaiaHubConfig) => {\n      gaiaHubConfig = hubConfig;\n      return blockstack.listFiles(name => {\n        fileNames.push(name);\n        return true;\n      });\n    })\n    .then((fileCount: number) => {\n      console.log(`Download ${fileCount} files...`);\n      const fileBatches: string[][] = batchify(fileNames);\n      let filePromiseChain: Promise<any> = Promise.resolve();\n      for (let i = 0; i < fileBatches.length; i++) {\n        const filePromises = fileBatches[i].map(fileName => downloadFile(gaiaHubConfig, fileName));\n        const batchPromise = Promise.all(filePromises);\n        filePromiseChain = filePromiseChain.then(() => batchPromise);\n      }\n\n      return filePromiseChain.then(() => JSONStringify(fileCount));\n    });\n}\n\n/*\n * Restore all of the files in a Gaia bucket dump to a new Gaia hub\n * args:\n * @nameOrIDAddress (string) the name or ID address that owns the bucket to dump\n * @appOrigin (string) the origin of the app for which to restore data\n * @hubUrl (string) the URL to the write endpoint of the new gaia hub\n * @mnemonic (string) the 12-word phrase or ciphertext\n * @dumpDir (string) the directory to hold the dumped files\n */\nfunction gaiaRestoreBucket(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const nameOrIDAddress = args[0];\n  const appOrigin = args[1];\n  const hubUrl = args[2];\n  const mnemonicOrCiphertext = args[3];\n  let dumpDir = args[4];\n\n  if (dumpDir.length === 0) {\n    throw new Error('Invalid directory (not given)');\n  }\n  if (dumpDir[0] !== '/') {\n    // relative path.  make absolute\n    const cwd = fs.realpathSync('.');\n    dumpDir = path.normalize(`${cwd}/${dumpDir}`);\n  }\n\n  const fileList = fs.readdirSync(dumpDir);\n  const fileBatches = batchify(fileList, 10);\n\n  let appPrivateKey: string;\n  let ownerPrivateKey: string;\n\n  // force mainnet addresses\n  // TODO better way of doing this\n  blockstack.config.network.layer1 = bitcoin.networks.bitcoin;\n\n  return getIDAppKeys(network, nameOrIDAddress, appOrigin, mnemonicOrCiphertext)\n    .then((keyInfo: IDAppKeys) => {\n      appPrivateKey = keyInfo.appPrivateKey;\n      ownerPrivateKey = keyInfo.ownerPrivateKey;\n      return gaiaAuth(network, appPrivateKey, hubUrl, ownerPrivateKey);\n    })\n    .then((_userData: UserData) => {\n      let uploadPromise: Promise<any> = Promise.resolve();\n      for (let i = 0; i < fileBatches.length; i++) {\n        const uploadBatchPromises = fileBatches[i].map((fileName: string) => {\n          const filePath = path.join(dumpDir, fileName);\n          const dataBuf = fs.readFileSync(filePath);\n          const gaiaPath = fileName.replace(/\\\\x2f/g, '/');\n          return blockstack\n            .putFile(gaiaPath, dataBuf, { encrypt: false, sign: false })\n            .then((url: string) => {\n              console.log(`Uploaded ${fileName} to ${url}`);\n            });\n        });\n        uploadPromise = uploadPromise.then(() => Promise.all(uploadBatchPromises));\n      }\n      return uploadPromise;\n    })\n    .then(() => JSONStringify(fileList.length));\n}\n\n/*\n * Set the Gaia hub for an application for a blockstack ID.\n * args:\n * @blockstackID (string) the blockstack ID of the user\n * @profileHubUrl (string) the URL to the write endpoint of the user's profile gaia hub\n * @appOrigin (string) the application's Origin\n * @hubUrl (string) the URL to the write endpoint of the app's gaia hub\n * @mnemonic (string) the 12-word backup phrase, or the ciphertext of it\n */\nasync function gaiaSetHub(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  network.setCoerceMainnetAddress(true);\n\n  const blockstackID = args[0];\n  const ownerHubUrl = args[1];\n  const appOrigin = args[2];\n  const hubUrl = args[3];\n  const mnemonicPromise = getBackupPhrase(args[4]);\n\n  const nameInfoPromise = getNameInfoEasy(network, blockstackID).then(\n    (nameInfo: NameInfoType | null) => {\n      if (!nameInfo) {\n        throw new Error('Name not found');\n      }\n      return nameInfo;\n    }\n  );\n\n  const profilePromise = blockstack.lookupProfile(blockstackID);\n\n  const [nameInfo, nameProfile, mnemonic]: [NameInfoType, any, string] = await Promise.all([\n    nameInfoPromise,\n    profilePromise,\n    mnemonicPromise,\n  ]);\n\n  if (!nameProfile) {\n    throw new Error('No profile found');\n  }\n  if (!nameInfo) {\n    throw new Error('Name not found');\n  }\n  if (!nameInfo.zonefile) {\n    throw new Error('No zone file found');\n  }\n\n  if (!nameProfile.apps) {\n    nameProfile.apps = {};\n  }\n\n  // get owner ID-address\n  const ownerAddress = network.coerceMainnetAddress(nameInfo.address);\n  const idAddress = `ID-${ownerAddress}`;\n\n  // get owner and app key info\n  const appKeyInfo = await getApplicationKeyInfo(network, mnemonic, idAddress, appOrigin);\n  const ownerKeyInfo = await getOwnerKeyInfo(network, mnemonic, appKeyInfo.ownerKeyIndex);\n\n  // do we already have an address set for this app?\n  let existingAppAddress: string | null = null;\n  let appPrivateKey: string;\n  try {\n    existingAppAddress = getGaiaAddressFromProfile(network, nameProfile, appOrigin);\n    appPrivateKey = extractAppKey(network, appKeyInfo, existingAppAddress);\n  } catch (e) {\n    console.log(`No profile application entry for ${appOrigin}`);\n    appPrivateKey = extractAppKey(network, appKeyInfo);\n  }\n\n  appPrivateKey = `${canonicalPrivateKey(appPrivateKey)}01`;\n  const appAddress = network.coerceMainnetAddress(getPrivateKeyAddress(network, appPrivateKey));\n\n  if (existingAppAddress && appAddress !== existingAppAddress) {\n    throw new Error(`BUG: ${existingAppAddress} !== ${appAddress}`);\n  }\n\n  const profile = nameProfile;\n  const ownerPrivateKey = ownerKeyInfo.privateKey;\n\n  const ownerGaiaHubPromise = gaiaConnect(network, ownerHubUrl, ownerPrivateKey);\n  const appGaiaHubPromise = gaiaConnect(network, hubUrl, appPrivateKey);\n\n  const [ownerHubConfig, appHubConfig]: [GaiaHubConfig, GaiaHubConfig] = await Promise.all([\n    ownerGaiaHubPromise,\n    appGaiaHubPromise,\n  ]);\n\n  if (!ownerHubConfig.url_prefix) {\n    throw new Error('Invalid owner hub config: no url_prefix defined');\n  }\n\n  if (!appHubConfig.url_prefix) {\n    throw new Error('Invalid app hub config: no url_prefix defined');\n  }\n\n  const gaiaReadUrl = appHubConfig.url_prefix.replace(/\\/+$/, '');\n\n  const newAppEntry: Record<string, string> = {};\n  newAppEntry[appOrigin] = `${gaiaReadUrl}/${appAddress}/`;\n\n  const apps = Object.assign({}, profile.apps ? profile.apps : {}, newAppEntry);\n  profile.apps = apps;\n\n  // sign the new profile\n  const signedProfile = makeProfileJWT(profile, ownerPrivateKey);\n  const profileUrls: {\n    dataUrls?: string[] | null;\n    error?: string | null;\n  } = await gaiaUploadProfileAll(\n    network,\n    [ownerHubUrl],\n    signedProfile,\n    ownerPrivateKey,\n    blockstackID\n  );\n\n  if (profileUrls.error) {\n    return JSONStringify({\n      error: profileUrls.error,\n    });\n  } else {\n    return JSONStringify({\n      profileUrls: profileUrls.dataUrls!,\n    });\n  }\n}\n\n/*\n * Convert an address between mainnet and testnet, and between\n * base58check and c32check.\n * args:\n * @address (string) the input address.  can be in any format\n */\nfunction addressConvert(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const addr = args[0];\n  let b58addr: string;\n  let c32addr: string;\n  let testnetb58addr: string;\n  let testnetc32addr: string;\n\n  if (addr.match(STACKS_ADDRESS_PATTERN)) {\n    c32addr = addr;\n    b58addr = c32check.c32ToB58(c32addr);\n  } else if (addr.match(/[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+/)) {\n    c32addr = c32check.b58ToC32(addr);\n    b58addr = addr;\n  } else {\n    throw new Error(`Unrecognized address ${addr}`);\n  }\n\n  if (network.isTestnet()) {\n    testnetb58addr = network.coerceAddress(b58addr);\n    testnetc32addr = c32check.b58ToC32(testnetb58addr);\n  }\n\n  return Promise.resolve().then(() => {\n    const result: any = {\n      mainnet: {\n        STACKS: c32addr,\n        BTC: b58addr,\n      },\n      testnet: undefined,\n    };\n\n    if (network.isTestnet()) {\n      result.testnet = {\n        STACKS: testnetc32addr,\n        BTC: testnetb58addr,\n      };\n    }\n\n    return JSONStringify(result);\n  });\n}\n\n/*\n * Run an authentication daemon on a given port.\n * args:\n * @gaiaHubUrl (string) the write endpoint of your app Gaia hub, where app data will be stored\n * @mnemonic (string) your 12-word phrase, optionally encrypted.  If encrypted, then\n * a password will be prompted.\n * @profileGaiaHubUrl (string) the write endpoint of your profile Gaia hub, where your profile\n *   will be stored (optional)\n * @port (number) the port to listen on (optional)\n */\nfunction authDaemon(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const gaiaHubUrl = args[0];\n  const mnemonicOrCiphertext = args[1];\n  let port = 3000; // default port\n  let profileGaiaHub = gaiaHubUrl;\n\n  if (args.length > 2 && !!args[2]) {\n    profileGaiaHub = args[2];\n  }\n\n  if (args.length > 3 && !!args[3]) {\n    port = parseInt(args[3]);\n  }\n\n  if (port < 0 || port > 65535) {\n    return Promise.resolve().then(() => JSONStringify({ error: 'Invalid port' }));\n  }\n\n  const mnemonicPromise = getBackupPhrase(mnemonicOrCiphertext);\n\n  return mnemonicPromise\n    .then((mnemonic: string) => {\n      noExit = true;\n\n      // load up all of our identity addresses, profiles, profile URLs, and Gaia connections\n      const authServer = express();\n      authServer.use(cors());\n\n      authServer.get(/^\\/auth\\/*$/, (req: express.Request, res: express.Response) => {\n        return handleAuth(network, mnemonic, gaiaHubUrl, profileGaiaHub, port, req, res);\n      });\n\n      authServer.get(/^\\/signin\\/*$/, (req: express.Request, res: express.Response) => {\n        return handleSignIn(network, mnemonic, gaiaHubUrl, profileGaiaHub, req, res);\n      });\n\n      authServer.listen(port, () => console.log(`Authentication server started on ${port}`));\n      return 'Press Ctrl+C to exit';\n    })\n    .catch((e: Error) => {\n      return JSONStringify({ error: e.message });\n    });\n}\n\n/*\n * Encrypt a backup phrase\n * args:\n * @backup_phrase (string) the 12-word phrase to encrypt\n * @password (string) the password (will be interactively prompted if not given)\n */\n// TODO: fix: network is never used\n// @ts-ignore\nfunction encryptMnemonic(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const mnemonic = args[0];\n  if (mnemonic.split(/ +/g).length !== 12) {\n    throw new Error('Invalid backup phrase: must be 12 words');\n  }\n\n  const passwordPromise: Promise<string> = new Promise((resolve, reject) => {\n    let pass = '';\n    if (args.length === 2 && !!args[1]) {\n      pass = args[1];\n      resolve(pass);\n    } else {\n      if (!process.stdin.isTTY) {\n        // password must be given as an argument\n        const errMsg = 'Password argument required on non-interactive mode';\n        reject(new Error(errMsg));\n      } else {\n        // prompt password\n        getpass('Enter password: ', (pass1: string) => {\n          getpass('Enter password again: ', (pass2: string) => {\n            if (pass1 !== pass2) {\n              const errMsg = 'Passwords do not match';\n              reject(new Error(errMsg));\n            } else {\n              resolve(pass1);\n            }\n          });\n        });\n      }\n    }\n  });\n\n  return passwordPromise\n    .then((pass: string) => encryptBackupPhrase(mnemonic, pass))\n    .then((cipherTextBuffer: Buffer) => cipherTextBuffer.toString('base64'))\n    .catch((e: Error) => {\n      return JSONStringify({ error: e.message });\n    });\n}\n\n/* Decrypt a backup phrase\n * args:\n * @encrypted_backup_phrase (string) the encrypted base64-encoded backup phrase\n * @password 9string) the password (will be interactively prompted if not given)\n */\n// TODO: fix: network is never used\n// @ts-ignore\nfunction decryptMnemonic(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  const ciphertext = args[0];\n\n  const passwordPromise: Promise<string> = new Promise((resolve, reject) => {\n    if (args.length === 2 && !!args[1]) {\n      const pass = args[1];\n      resolve(pass);\n    } else {\n      if (!process.stdin.isTTY) {\n        // password must be given\n        reject(new Error('Password argument required in non-interactive mode'));\n      } else {\n        // prompt password\n        getpass('Enter password: ', p => {\n          resolve(p);\n        });\n      }\n    }\n  });\n\n  return passwordPromise\n    .then((pass: string) => decryptBackupPhrase(Buffer.from(ciphertext, 'base64'), pass))\n    .catch((e: Error) => {\n      return JSONStringify({\n        error:\n          'Failed to decrypt (wrong password or corrupt ciphertext), ' + `details: ${e.message}`,\n      });\n    });\n}\n\nasync function stackingStatus(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  let stxAddress = args[0];\n\n  const txNetwork = network.isMainnet() ? new StacksMainnet() : new StacksTestnet();\n  const stacker = new StackingClient(stxAddress, txNetwork);\n\n  return stacker\n    .getStatus()\n    .then((status: StackerInfo) => {\n      if (status.stacked) {\n        return {\n          amount_microstx: status.details!.amount_microstx,\n          first_reward_cycle: status.details!.first_reward_cycle,\n          lock_period: status.details!.lock_period,\n          unlock_height: status.details!.unlock_height,\n          pox_address: {\n            version: status.details!.pox_address.version.toString('hex'),\n            hashbytes: status.details!.pox_address.hashbytes.toString('hex'),\n          },\n        };\n      } else {\n        return 'Account not actively participating in Stacking';\n      }\n    })\n    .catch((error: any) => {\n      return error.toString();\n    });\n}\n\nasync function canStack(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  let amount = new BN(args[0]);\n  let cycles = Number(args[1]);\n  let poxAddress = args[2];\n  let stxAddress = args[3];\n\n  const txNetwork = network.isMainnet() ? new StacksMainnet() : new StacksTestnet();\n\n  const apiConfig = new Configuration({\n    fetchApi: crossfetch,\n    basePath: txNetwork.coreApiUrl,\n  });\n  const accounts = new AccountsApi(apiConfig);\n\n  const balancePromise = accounts.getAccountBalance({\n    principal: stxAddress,\n  });\n\n  const stacker = new StackingClient(stxAddress, txNetwork);\n\n  const poxInfoPromise = stacker.getPoxInfo();\n\n  const stackingEligiblePromise = stacker.canStack({ poxAddress, cycles });\n\n  return Promise.all([balancePromise, poxInfoPromise, stackingEligiblePromise])\n    .then(([balance, poxInfo, stackingEligible]) => {\n      const minAmount = new BN(poxInfo.min_amount_ustx);\n      const balanceBN = new BN(balance.stx.balance);\n\n      if (minAmount.gt(amount)) {\n        throw new Error(\n          `Stacking amount less than required minimum of ${minAmount.toString()} microstacks`\n        );\n      }\n\n      if (amount.gt(balanceBN)) {\n        throw new Error(\n          `Stacking amount greater than account balance of ${balanceBN.toString()} microstacks`\n        );\n      }\n\n      if (!stackingEligible.eligible) {\n        throw new Error(`Account cannot participate in stacking. ${stackingEligible.reason}`);\n      }\n\n      return stackingEligible;\n    })\n    .catch(error => {\n      return error;\n    });\n}\n\nasync function stack(network: CLINetworkAdapter, args: string[]): Promise<string> {\n  let amount = new BN(args[0]);\n  let cycles = Number(args[1]);\n  let poxAddress = args[2];\n  let privateKey = args[3];\n\n  // let fee = new BN(0);\n  // let nonce = new BN(0);\n\n  // if (args.length > 3 && !!args[4]) {\n  //   fee = new BN(args[4]);\n  // }\n\n  // if (args.length > 4 && !!args[5]) {\n  //   nonce = new BN(args[5]);\n  // }\n\n  const txNetwork = network.isMainnet() ? new StacksMainnet() : new StacksTestnet();\n  const txVersion = txNetwork.isMainnet() ? TransactionVersion.Mainnet : TransactionVersion.Testnet;\n\n  const apiConfig = new Configuration({\n    fetchApi: crossfetch,\n    basePath: txNetwork.coreApiUrl,\n  });\n  const accounts = new AccountsApi(apiConfig);\n\n  const stxAddress = getAddressFromPrivateKey(privateKey, txVersion);\n\n  const balancePromise = accounts.getAccountBalance({\n    principal: stxAddress,\n  });\n\n  const stacker = new StackingClient(stxAddress, txNetwork);\n\n  const poxInfoPromise = stacker.getPoxInfo();\n\n  const coreInfoPromise = stacker.getCoreInfo();\n\n  const stackingEligiblePromise = stacker.canStack({ poxAddress, cycles });\n\n  return Promise.all([balancePromise, poxInfoPromise, coreInfoPromise, stackingEligiblePromise])\n    .then(([balance, poxInfo, coreInfo, stackingEligible]) => {\n      const minAmount = new BN(poxInfo.min_amount_ustx);\n      const balanceBN = new BN(balance.stx.balance);\n      const burnChainBlockHeight = coreInfo.burn_block_height;\n      const startBurnBlock = burnChainBlockHeight + 3;\n\n      if (minAmount.gt(amount)) {\n        throw new Error(\n          `Stacking amount less than required minimum of ${minAmount.toString()} microstacks`\n        );\n      }\n\n      if (amount.gt(balanceBN)) {\n        throw new Error(\n          `Stacking amount greater than account balance of ${balanceBN.toString()} microstacks`\n        );\n      }\n\n      if (!stackingEligible.eligible) {\n        throw new Error(`Account cannot participate in stacking. ${stackingEligible.reason}`);\n      }\n\n      return stacker.stack({\n        amountMicroStx: amount,\n        poxAddress,\n        cycles,\n        privateKey,\n        burnBlockHeight: startBurnBlock,\n      });\n    })\n    .then((response: TxBroadcastResult) => {\n      if (response.hasOwnProperty('error')) {\n        return response;\n      }\n      return {\n        txid: `0x${response}`,\n        transaction: generateExplorerTxPageUrl(response as string, txNetwork),\n      };\n    })\n    .catch(error => {\n      return error;\n    });\n}\n\nfunction faucetCall(_: CLINetworkAdapter, args: string[]): Promise<string> {\n  let address = args[0];\n  // console.log(address);\n\n  const apiConfig = new Configuration({\n    fetchApi: crossfetch,\n    basePath: 'https://stacks-node-api.blockstack.org',\n  });\n\n  const faucets = new FaucetsApi(apiConfig);\n\n  return faucets\n    .runFaucetStx({ address })\n    .then((faucetTx: any) => {\n      return JSONStringify({\n        txid: faucetTx.txId!,\n        transaction: generateExplorerTxPageUrl(faucetTx.txId!, new StacksTestnet()),\n      });\n    })\n    .catch((error: any) => error.toString());\n}\n\n/* Print out all documentation on usage in JSON\n */\ntype DocsArgsType = {\n  name: string;\n  type: string;\n  value: string;\n  format: string;\n};\n\ntype FormattedDocsType = {\n  command: string;\n  args: DocsArgsType[];\n  usage: string;\n  group: string;\n};\n\nfunction printDocs(_network: CLINetworkAdapter, _args: string[]): Promise<string> {\n  return Promise.resolve().then(() => {\n    const formattedDocs: FormattedDocsType[] = [];\n    const commandNames: string[] = Object.keys(CLI_ARGS.properties);\n    for (let i = 0; i < commandNames.length; i++) {\n      const commandName = commandNames[i];\n      const args: DocsArgsType[] = [];\n      const usage = CLI_ARGS.properties[commandName].help;\n      const group = CLI_ARGS.properties[commandName].group;\n\n      for (let j = 0; j < CLI_ARGS.properties[commandName].items.length; j++) {\n        const argItem = CLI_ARGS.properties[commandName].items[j];\n        args.push({\n          name: argItem.name,\n          type: argItem.type,\n          value: argItem.realtype,\n          format: argItem.pattern ? argItem.pattern : '.+',\n        } as DocsArgsType);\n      }\n\n      formattedDocs.push({\n        command: commandName,\n        args: args,\n        usage: usage,\n        group: group,\n      } as FormattedDocsType);\n    }\n    return JSONStringify(formattedDocs);\n  });\n}\n\ntype CommandFunction = (network: CLINetworkAdapter, args: string[]) => Promise<string | Buffer>;\n\n/*\n * Decrypt a backup phrase\n * args:\n * @p\n/*\n * Global set of commands\n */\nconst COMMANDS: Record<string, CommandFunction> = {\n  authenticator: authDaemon,\n  // 'announce': announce,\n  balance: balance,\n  can_stack: canStack,\n  call_contract_func: contractFunctionCall,\n  call_read_only_contract_func: readOnlyContractFunctionCall,\n  convert_address: addressConvert,\n  decrypt_keychain: decryptMnemonic,\n  deploy_contract: contractDeploy,\n  docs: printDocs,\n  encrypt_keychain: encryptMnemonic,\n  gaia_deletefile: gaiaDeleteFile,\n  gaia_dump_bucket: gaiaDumpBucket,\n  gaia_getfile: gaiaGetFile,\n  gaia_listfiles: gaiaListFiles,\n  gaia_putfile: gaiaPutFile,\n  gaia_restore_bucket: gaiaRestoreBucket,\n  gaia_sethub: gaiaSetHub,\n  get_address: getKeyAddress,\n  get_account_history: getAccountHistory,\n  get_app_keys: getAppKeys,\n  get_owner_keys: getOwnerKeys,\n  get_payment_key: getPaymentKey,\n  get_stacks_wallet_key: getStacksWalletKey,\n  make_keychain: makeKeychain,\n  profile_sign: profileSign,\n  profile_store: profileStore,\n  profile_verify: profileVerify,\n  // 'send_btc': sendBTC,\n  send_tokens: sendTokens,\n  stack: stack,\n  stacking_status: stackingStatus,\n  faucet: faucetCall,\n};\n\n/*\n * CLI main entry point\n */\nexport function CLIMain() {\n  const argv = process.argv;\n  const opts = getCLIOpts(argv);\n\n  const cmdArgs: any = checkArgs(\n    CLIOptAsStringArray(opts, '_') ? CLIOptAsStringArray(opts, '_')! : []\n  );\n  if (!cmdArgs.success) {\n    if (cmdArgs.error) {\n      console.log(cmdArgs.error);\n    }\n    if (cmdArgs.usage) {\n      if (cmdArgs.command) {\n        console.log(makeCommandUsageString(cmdArgs.command));\n        console.log('Use \"help\" to list all commands.');\n      } else {\n        console.log(USAGE);\n        console.log(makeAllCommandsList());\n      }\n    }\n    process.exit(1);\n  } else {\n    txOnly = CLIOptAsBool(opts, 'x');\n    estimateOnly = CLIOptAsBool(opts, 'e');\n    safetyChecks = !CLIOptAsBool(opts, 'U');\n    receiveFeesPeriod = opts['N'] ? parseInt(CLIOptAsString(opts, 'N')!) : receiveFeesPeriod;\n    gracePeriod = opts['G'] ? parseInt(CLIOptAsString(opts, 'N')!) : gracePeriod;\n    maxIDSearchIndex = opts['M'] ? parseInt(CLIOptAsString(opts, 'M')!) : maxIDSearchIndex;\n\n    const debug = CLIOptAsBool(opts, 'd');\n    const consensusHash = CLIOptAsString(opts, 'C');\n    const integration_test = CLIOptAsBool(opts, 'i');\n    const testnet = CLIOptAsBool(opts, 't');\n    const magicBytes = CLIOptAsString(opts, 'm');\n    const apiUrl = CLIOptAsString(opts, 'H');\n    const transactionBroadcasterUrl = CLIOptAsString(opts, 'T');\n    const nodeAPIUrl = CLIOptAsString(opts, 'I');\n    const utxoUrl = CLIOptAsString(opts, 'X');\n    const bitcoindUsername = CLIOptAsString(opts, 'u');\n    const bitcoindPassword = CLIOptAsString(opts, 'p');\n\n    if (integration_test) {\n      BLOCKSTACK_TEST = integration_test;\n    }\n\n    const configPath = CLIOptAsString(opts, 'c')\n      ? CLIOptAsString(opts, 'c')\n      : integration_test\n      ? DEFAULT_CONFIG_REGTEST_PATH\n      : testnet\n      ? DEFAULT_CONFIG_TESTNET_PATH\n      : DEFAULT_CONFIG_PATH;\n\n    const namespaceBurnAddr = CLIOptAsString(opts, 'B');\n    const feeRate = CLIOptAsString(opts, 'F') ? parseInt(CLIOptAsString(opts, 'F')!) : 0;\n    const priceToPay = CLIOptAsString(opts, 'P') ? CLIOptAsString(opts, 'P') : '0';\n    const priceUnits = CLIOptAsString(opts, 'D');\n\n    const networkType = testnet ? 'testnet' : integration_test ? 'regtest' : 'mainnet';\n\n    const configData = loadConfig(configPath!, networkType);\n\n    if (debug) {\n      configData.logConfig.level = 'debug';\n    } else {\n      configData.logConfig.level = 'info';\n    }\n    if (bitcoindUsername) {\n      configData.bitcoindUsername = bitcoindUsername;\n    }\n    if (bitcoindPassword) {\n      configData.bitcoindPassword = bitcoindPassword;\n    }\n\n    if (utxoUrl) {\n      configData.utxoServiceUrl = utxoUrl;\n    }\n\n    winston.configure({\n      level: configData.logConfig.level,\n      transports: [new winston.transports.Console(configData.logConfig)],\n    });\n\n    const cliOpts: CLI_NETWORK_OPTS = {\n      consensusHash: consensusHash ? consensusHash : null,\n      feeRate: feeRate ? feeRate : null,\n      namespaceBurnAddress: namespaceBurnAddr ? namespaceBurnAddr : null,\n      priceToPay: priceToPay ? priceToPay : null,\n      priceUnits: priceUnits ? priceUnits : null,\n      receiveFeesPeriod: receiveFeesPeriod ? receiveFeesPeriod : null,\n      gracePeriod: gracePeriod ? gracePeriod : null,\n      altAPIUrl: apiUrl ? apiUrl : configData.blockstackAPIUrl,\n      altTransactionBroadcasterUrl: transactionBroadcasterUrl\n        ? transactionBroadcasterUrl\n        : configData.broadcastServiceUrl,\n      nodeAPIUrl: nodeAPIUrl ? nodeAPIUrl : configData.blockstackNodeUrl,\n    };\n\n    // wrap command-line options\n    const wrappedNetwork = getNetwork(\n      configData,\n      !!BLOCKSTACK_TEST || !!integration_test || !!testnet\n    );\n    const blockstackNetwork = new CLINetworkAdapter(wrappedNetwork, cliOpts);\n    if (magicBytes) {\n      // blockstackNetwork.MAGIC_BYTES = magicBytes;\n    }\n\n    // blockstack.config.network = blockstackNetwork;\n    blockstack.config.logLevel = 'error';\n\n    if (cmdArgs.command === 'help') {\n      console.log(makeCommandUsageString(cmdArgs.args[0]));\n      process.exit(0);\n    }\n\n    const method = COMMANDS[cmdArgs.command];\n    let exitcode = 0;\n\n    method(blockstackNetwork, cmdArgs.args)\n      .then((result: string | Buffer) => {\n        try {\n          // if this is a JSON object with 'status', set the exit code\n          if (result instanceof Buffer) {\n            return result;\n          } else {\n            const resJson: any = JSON.parse(result);\n            if (resJson.hasOwnProperty('status') && !resJson.status) {\n              exitcode = 1;\n            }\n            return result;\n          }\n        } catch (e) {\n          return result;\n        }\n      })\n      .then((result: string | Buffer) => {\n        if (result instanceof Buffer) {\n          process.stdout.write(result);\n        } else {\n          console.log(result);\n        }\n      })\n      .then(() => {\n        if (!noExit) {\n          process.exit(exitcode);\n        }\n      })\n      .catch((e: Error) => {\n        console.error(e.stack);\n        console.error(e.message);\n        if (!noExit) {\n          process.exit(1);\n        }\n      });\n  }\n}\n","#!/usr/bin/env node\n\nimport { CLIMain } from './cli';\n\nexport { CLIMain };\n// implement just enough of window to be useful to blockstack.js.\n// do this here, so we can be *sure* it's in RAM.\nconst localStorageRAM: Record<string, any> = {};\n\n// @ts-ignore\ndeclare let global: any;\n\nglobal['window'] = {\n  location: {\n    origin: 'localhost',\n  },\n  localStorage: {\n    getItem: function(itemName: string) {\n      return localStorageRAM[itemName];\n    },\n    setItem: function(itemName: string, itemValue: any) {\n      localStorageRAM[itemName] = itemValue;\n    },\n    removeItem: function(itemName: string) {\n      delete localStorageRAM[itemName];\n    },\n  },\n};\n\nglobal['localStorage'] = global['window'].localStorage;\n\nCLIMain();\n"],"names":["runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","NAME_PATTERN","ADDRESS_CHARS","ADDRESS_PATTERN","ID_ADDRESS_PATTERN","STACKS_ADDRESS_PATTERN","PRIVATE_KEY_PATTERN_ANY","PRIVATE_KEY_PATTERN","URL_PATTERN","SUBDOMAIN_PATTERN","LOG_CONFIG_DEFAULTS","level","handleExceptions","timestamp","stringify","colorize","json","CONFIG_DEFAULTS","blockstackAPIUrl","blockstackNodeUrl","broadcastServiceUrl","utxoServiceUrl","logConfig","CONFIG_REGTEST_DEFAULTS","bitcoindPassword","bitcoindUsername","CONFIG_TESTNET_DEFAULTS","assign","CLI_ARGS","properties","announce","items","realtype","pattern","minItems","maxItems","help","group","authenticator","balance","can_stack","call_contract_func","call_read_only_contract_func","convert_address","decrypt_keychain","deploy_contract","docs","encrypt_keychain","faucet","gaia_dump_bucket","gaia_getfile","gaia_putfile","gaia_deletefile","gaia_listfiles","gaia_restore_bucket","gaia_sethub","get_account_history","get_account_at","get_address","get_blockchain_record","get_blockchain_history","get_confirmations","get_namespace_blockchain_record","get_app_keys","get_owner_keys","get_payment_key","get_stacks_wallet_key","get_zonefile","lookup","names","make_keychain","make_zonefile","name_import","namespace_preorder","namespace_reveal","namespace_ready","price","price_namespace","profile_sign","profile_store","profile_verify","renew","register","register_addr","register_subdomain","revoke","send_btc","send_tokens","stack","stacking_status","transfer","tx_preorder","tx_register","update","whois","zonefile_push","get_did_configuration","additionalProperties","strict","USAGE","process","formatHelpString","indent","limit","helpString","lines","split","buf","pad","linebuf","words","filter","word","substring","j","getCommandGroups","groups","commands","command","makeAllCommandsList","groupNames","sort","res","cmds","join","map","line","trim","replace","makeCommandUsageString","helps","makeAllCommandsHelp","commandInfo","cmdFormat","commandName","commandArgs","rawUsage","kwUsage","kwPad","console","log","toUpperCase","raw","kw","formatCommandHelpLines","formattedHelp","CLIOptAsString","opts","CLIOptAsBool","CLIOptAsStringArray","Array","s","reduce","x","y","isStringArray","decryptBackupPhrase","dataBuffer","password","blockstack","ZoneFile","require","CLITransactionSigner","address","isComplete","getAddress","_this","signTransaction","_txIn","_signingIndex","signerVersion","NullSigner","MultiSigKeySigner","redeemScript","privateKeys","Buffer","from","chunks","bitcoinjs","decompile","_this2","m","parseInt","toASM","toBase58Check","hash160","network","layer1","scriptHash","e","logger","_this3","txIn","signingIndex","_this4","keyHex","ecPair","sign","SegwitP2SHKeySigner","witnessScript","_this5","_this6","findUTXO","utxos","private_tx","__TX","txidBuf","ins","hash","outpoint","index","txid","tx_hash","tx_output_n","_this7","getUTXOs","utxo","decodePrivateKey","serializedPrivateKey","match","addrString","startsWith","addr","parseNullSigner","serializedPrivateKeys","matches","parts","privkeys","pk","pubkeys","getPublicKeyFromPrivateKey","multisigInfo","p2ms","output","parseMultiSigKeys","p2wpkh","pubkey","p2sh","redeem","p2wsh","parseSegwitP2SHKeys","JSONStringify","stderr","stdout","isTTY","JSON","privateKey","publicKey","getPrivateKeyAddress","ecKeyPair","coerceAddress","canonicalPrivateKey","privkey","makeProfileJWT","profileData","signedToken","getNameInfoEasy","getNameInfo","nameInfo","message","nameLookup","includeProfile","nameInfoPromise","profilePromise","zonefilePromise","zonefile","all","profileObj","grace_period","expire_block","renewal_deadline","profileUrl","zonefileJSON","parseZoneFile","uri","profile","getpass","promptStr","cb","silentOutput","stream","write","_chunk","_encoding","callback","rl","readline","input","stdin","terminal","question","passwd","close","getBackupPhrase","backupPhraseOrCiphertext","p","pass","getIDAddress","nameOrIDAddress","getOwnerKeyFromIDAddress","mnemonic","idAddress","getOwnerKeyInfo","keyInfo","getIDAppKeys","appOrigin","mnemonicOrCiphertext","getApplicationKeyInfo","appPrivateKey","extractAppKey","ownerPrivateKey","makePromptsFromArgList","expectedArgs","prompts","argToPrompt","typeString","getTypeString","isClarityAbiPrimitive","choices","isClarityAbiBuffer","isClarityAbiResponse","isClarityAbiOptional","isClarityAbiTuple","isClarityAbiList","parseClarityFunctionArgAnswers","answers","functionArgs","expectedArg","answerToClarityValue","answer","uintCV","intCV","trueCV","falseCV","standardPrincipalCV","bufferCVFromString","generateExplorerTxPageUrl","version","TransactionVersion","Testnet","c32check","walletFromMnemonic","bip39","bip32","getNodePrivateKey","node","bitcoin","fromPrivateKey","identity","getIdentityAddressNode","getAddressFromBIP32Node","getPaymentKeyInfo","getBitcoinPrivateKey","BTC","STACKS","b58ToC32","getStacksWalletKeyInfo","master","child","derivePath","isTestnet","p2pkh","regtest","btcAddress","findIdentityIndex","maxIndex","getMaxIDSearchIndex","wallet","appDomain","idIndex","identityOwnerAddressNode","appsNode","getAppsNode","legacyAppPrivateKey","getLegacyAppPrivateKey","toBase58","getIdentitySalt","legacyKeyInfo","ownerKeyIndex","appKeyInfo","appAddress","coerceMainnetAddress","BN","CLINetworkAdapter","consensusHash","feeRate","namespaceBurnAddress","priceToPay","priceUnits","receiveFeesPeriod","gracePeriod","altAPIUrl","nodeAPIUrl","altTransactionBroadcasterUrl","legacyNetwork","BlockstackNetwork","btc","optAlwaysCoerceAddress","isMainnet","pubKeyHash","testnet","setCoerceMainnetAddress","addressInfo","fromBase58Check","addressVersion","newVersion","getFeeRate","Math","floor","getConsensusHash","c","getGracePeriod","g","getNamePrice","units","String","amount","priceInfo","getNamespacePrice","namespaceID","getNamespaceBurnAddress","namespace","useCLI","fetch","getBlockHeight","resp","blockHeight","status","namespaceInfo","reveal_block","ni","blockchain","did","last_txid","resolver","zonefile_hash","getBlockchainNameRecord","fixedAddresses","addrAttr","getNameHistory","page","historyInfo","fixedHistory","historyBlock","fixedHistoryList","fixedHistoryEntry","historyEntry","_this8","getAccountHistoryPage","broadcastTransaction","tx","broadcastZoneFile","getNamesOwned","makeAssociationToken","identityKey","appPublicKey","salt","crypto","associationTokenClaim","childToAssociate","iss","exp","Date","getTime","jsontokens","gaiaAuth","hubUrl","associationToken","authSessionToken","hubURL","window","localStorage","setItem","accounts","makeFakeAuthResponseToken","gaiaConnect","gaiaHubUrl","addressMainnet","addressMainnetCanonical","connectToGaiaHub","hubConfig","gaiaUploadProfileAll","gaiaUrls","gaiaData","blockstackID","uploadPromises","gaiaUrl","urlInfo","URL","protocol","host","gaiaHubURL","hubconf","gaiaReadPrefix","url_prefix","gaiaReadUrlPath","path","profileUrlPath","gaiaFindProfileName","profilePath","gaiaUploadProfile","publicUrls","dataUrls","getGaiaAddressFromProfile","apps","existingAppAddress","appUrl","getGaiaAddressFromURL","SIGNIN_HEADER","SIGNIN_DESC","SIGNIN_SCOPES","SIGNIN_FMT_NAME","SIGNIN_FMT_ID","authTransitNonce","getAppPrivateKey","id","makeSignInLink","authPort","authRequest","domain_name","authResponseTmp","email","public_keys","authResponsePayload","payload","id_public","metadata","redirect_uri","scopes","nonce","tokenSigner","authResponse","makeAuthPage","manifest","ids","signinBody","signinDescription","signinScopes","signinEntry","loadNamedIdentitiesLoop","identities","nameList","loadNamedIdentities","loadUnnamedIdentity","sendJSON","data","statusCode","writeHead","end","getIdentityInfo","_appGaiaHub","_profileGaiaHub","nameInfoPromises","nameDatas","nextIndex","profileGaiaHub","port","req","authToken","query","errorMsg","appManifest","decodedAuthToken","decodedAuthPayload","authPage","_context7","updateProfileApps","appGaiaConfig","needProfileUpdate","_e","account","gaiaPrefix","changed","updateProfileAPISettings","api","gaiaHubConfig","server","appGaiaHub","authResponseQP","nameLookupUrl","errorStatusCode","needProfileAPIUpdate","authResponseToken","redirectUri","newProfileData","profileAPIUpdate","needProfileSigninUpdate","includes","profileJWT","appUri","Location","txOnly","estimateOnly","safetyChecks","noExit","maxIDSearchIndex","BLOCKSTACK_TEST","profileVerify","args","publicKeyOrAddress","profileString","fs","profileToken","parse","token","origin","recipientAddress","tokenAmount","fee","memo","txNetwork","StacksMainnet","StacksTestnet","coreApiUrl","options","recipient","senderKey","makeSTXTokenTransfer","estimateTransfer","cost","serialize","response","transaction","sourceFile","contractName","source","codeBody","postConditionMode","PostConditionMode","Allow","makeContractDeploy","estimateContractDeploy","contractAddress","functionName","getAbi","responseAbi","filtered","abi","functions","abiArgs","prompt","makeContractCall","validateContractCall","estimateContractFunctionCall","senderAddress","callReadOnlyFunction","returnValue","cvToString","batchify","batchSize","currentBatch","ownerHubUrl","mnemonicPromise","nameProfile","ownerAddress","ownerKeyInfo","ownerGaiaHubPromise","appGaiaHubPromise","appHubConfig","gaiaReadUrl","newAppEntry","signedProfile","profileUrls","stxAddress","stacker","StackingClient","getStatus","stacked","amount_microstx","details","first_reward_cycle","lock_period","unlock_height","pox_address","hashbytes","cycles","Number","poxAddress","apiConfig","Configuration","fetchApi","crossfetch","basePath","AccountsApi","balancePromise","getAccountBalance","principal","poxInfoPromise","getPoxInfo","stackingEligiblePromise","canStack","stackingEligible","minAmount","min_amount_ustx","balanceBN","stx","gt","eligible","reason","txVersion","Mainnet","getAddressFromPrivateKey","coreInfoPromise","getCoreInfo","coreInfo","startBurnBlock","burn_block_height","amountMicroStx","burnBlockHeight","COMMANDS","authServer","express","use","cors","get","handleAuth","handleSignIn","listen","getAccountApiUrl","balanceHex","substr","lockedHex","locked","unlockHeight","b58addr","c32addr","testnetb58addr","testnetc32addr","c32ToB58","mainnet","ciphertext","_network","_args","formattedDocs","commandNames","usage","argItem","format","pass1","pass2","cipherTextBuffer","gaiaPath","wasSigned","toLowerCase","_userData","dumpDir","cwd","pathParts","tmpPath","mode","S_IFDIR","code","mkdirs","fileNames","fileCount","fileBatches","filePromiseChain","filePromises","fileName","fileUrl","destPath","contentType","headers","text","arrayBuffer","filebytes","encoding","downloadFile","batchPromise","username","decrypt","verify","app","ArrayBuffer","count","dataPath","encrypt","url","urls","fileList","uploadPromise","uploadBatchPromises","filePath","dataBuf","accountStates","credit_value","debit_value","history","getAllAccountHistoryPages","results","concat","nameOrAddress","signedProfilePath","signedProfileData","ownerAddressMainnet","verifyProfilePromise","_","FaucetsApi","runFaucetStx","faucetTx","txId","CLIMain","argv","optsTable","remainingArgv","argvBuff","opt","getCLIOpts","cmdArgs","argList","success","allCommandArgs","parsedCommandArgs","argsList","commandProps","isArray","orderedArgs","foundArgs","argName","argValue","mergedArgs","orderedArgIndex","arguments","getCommandArgs","commandSchema","ajv","Ajv","validate","errors","schemaPath","params","checkArgs","debug","integration_test","apiUrl","transactionBroadcasterUrl","utxoUrl","configPath","namespaceBurnAddr","configData","configFile","networkType","configRet","loadConfig","winston","transports","Console","cliOpts","wrappedNetwork","regTest","LocalRegtest","BitcoindAPI","BlockchainInfoApi","getNetwork","blockstackNetwork","logLevel","exitcode","resJson","localStorageRAM","global","location","getItem","itemName","itemValue","removeItem"],"mappings":"y1FAOIA,EAAW,SAAUC,OAGnBC,EAAKC,OAAOC,UACZC,EAASH,EAAGI,eAEZC,EAA4B,mBAAXC,OAAwBA,OAAS,GAClDC,EAAiBF,EAAQG,UAAY,aACrCC,EAAsBJ,EAAQK,eAAiB,kBAC/CC,EAAoBN,EAAQO,aAAe,yBAEtCC,EAAOC,EAAKC,EAAKC,UACxBf,OAAOgB,eAAeH,EAAKC,EAAK,CAC9BC,MAAOA,EACPE,YAAY,EACZC,cAAc,EACdC,UAAU,IAELN,EAAIC,OAIXF,EAAO,GAAI,IACX,MAAOQ,GACPR,EAAS,SAASC,EAAKC,EAAKC,UACnBF,EAAIC,GAAOC,YAIbM,EAAKC,EAASC,EAASC,EAAMC,OAGhCC,EAAY1B,OAAO2B,QADFJ,GAAWA,EAAQtB,qBAAqB2B,EAAYL,EAAUK,GACtC3B,WACzC4B,EAAU,IAAIC,EAAQL,GAAe,WAIzCC,EAAUK,iBAsMcT,EAASE,EAAMK,OACnCG,EA/KuB,wBAiLpB,SAAgBC,EAAQC,MA/KT,cAgLhBF,QACI,IAAIG,MAAM,mCAhLE,cAmLhBH,EAA6B,IAChB,UAAXC,QACIC,QAyQL,CAAEnB,WAzfPqB,EAyfyBC,MAAM,OAjQ/BR,EAAQI,OAASA,EACjBJ,EAAQK,IAAMA,IAED,KACPI,EAAWT,EAAQS,YACnBA,EAAU,KACRC,EAAiBC,EAAoBF,EAAUT,MAC/CU,EAAgB,IACdA,IAAmBE,EAAkB,gBAClCF,MAIY,SAAnBV,EAAQI,OAGVJ,EAAQa,KAAOb,EAAQc,MAAQd,EAAQK,SAElC,GAAuB,UAAnBL,EAAQI,OAAoB,IAlNhB,mBAmNjBD,QACFA,EAjNc,YAkNRH,EAAQK,IAGhBL,EAAQe,kBAAkBf,EAAQK,SAEN,WAAnBL,EAAQI,QACjBJ,EAAQgB,OAAO,SAAUhB,EAAQK,KAGnCF,EA5NkB,gBA8Ndc,EAASC,EAASzB,EAASE,EAAMK,MACjB,WAAhBiB,EAAOE,KAAmB,IAG5BhB,EAAQH,EAAQQ,KAjOA,YAFK,iBAuOjBS,EAAOZ,MAAQO,iBAIZ,CACL1B,MAAO+B,EAAOZ,IACdG,KAAMR,EAAQQ,MAGS,UAAhBS,EAAOE,OAChBhB,EA/OgB,YAkPhBH,EAAQI,OAAS,QACjBJ,EAAQK,IAAMY,EAAOZ,OA9QPe,CAAiB3B,EAASE,EAAMK,GAE7CH,WAcAqB,EAASG,EAAIrC,EAAKqB,aAEhB,CAAEc,KAAM,SAAUd,IAAKgB,EAAGC,KAAKtC,EAAKqB,IAC3C,MAAOd,SACA,CAAE4B,KAAM,QAASd,IAAKd,IAhBjCtB,EAAQuB,KAAOA,MA2BXoB,EAAmB,YAMdb,cACAwB,cACAC,SAILC,EAAoB,GACxBA,EAAkBhD,GAAkB,kBAC3BiD,UAGLC,EAAWxD,OAAOyD,eAClBC,EAA0BF,GAAYA,EAASA,EAASG,EAAO,MAC/DD,GACAA,IAA4B3D,GAC5BG,EAAOiD,KAAKO,EAAyBpD,KAGvCgD,EAAoBI,OAGlBE,EAAKP,EAA2BpD,UAClC2B,EAAU3B,UAAYD,OAAO2B,OAAO2B,YAW7BO,EAAsB5D,IAC5B,OAAQ,QAAS,UAAU6D,SAAQ,SAAS7B,GAC3CrB,EAAOX,EAAWgC,GAAQ,SAASC,UAC1BqB,KAAKxB,QAAQE,EAAQC,kBAkCzB6B,EAAcrC,EAAWsC,OAgC5BC,OAgCClC,iBA9BYE,EAAQC,YACdgC,WACA,IAAIF,GAAY,SAASG,EAASC,aAnCpCC,EAAOpC,EAAQC,EAAKiC,EAASC,OAChCtB,EAASC,EAASrB,EAAUO,GAASP,EAAWQ,MAChC,UAAhBY,EAAOE,KAEJ,KACDsB,EAASxB,EAAOZ,IAChBnB,EAAQuD,EAAOvD,aACfA,GACiB,iBAAVA,GACPb,EAAOiD,KAAKpC,EAAO,WACdiD,EAAYG,QAAQpD,EAAMwD,SAASC,MAAK,SAASzD,GACtDsD,EAAO,OAAQtD,EAAOoD,EAASC,MAC9B,SAAShD,GACViD,EAAO,QAASjD,EAAK+C,EAASC,MAI3BJ,EAAYG,QAAQpD,GAAOyD,MAAK,SAASC,GAI9CH,EAAOvD,MAAQ0D,EACfN,EAAQG,MACP,SAASI,UAGHL,EAAO,QAASK,EAAOP,EAASC,MAvBzCA,EAAOtB,EAAOZ,KAiCZmC,CAAOpC,EAAQC,EAAKiC,EAASC,aAI1BH,EAaLA,EAAkBA,EAAgBO,KAChCN,EAGAA,GACEA,cAkHD1B,EAAoBF,EAAUT,OACjCI,EAASK,EAAS/B,SAASsB,EAAQI,gBAzTrCG,IA0TEH,EAAsB,IAGxBJ,EAAQS,SAAW,KAEI,UAAnBT,EAAQI,OAAoB,IAE1BK,EAAS/B,SAAT,SAGFsB,EAAQI,OAAS,SACjBJ,EAAQK,SArUZE,EAsUII,EAAoBF,EAAUT,GAEP,UAAnBA,EAAQI,eAGHQ,EAIXZ,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAIyC,UAChB,yDAGGlC,MAGLK,EAASC,EAASd,EAAQK,EAAS/B,SAAUsB,EAAQK,QAErC,UAAhBY,EAAOE,YACTnB,EAAQI,OAAS,QACjBJ,EAAQK,IAAMY,EAAOZ,IACrBL,EAAQS,SAAW,KACZG,MAGLmC,EAAO9B,EAAOZ,WAEZ0C,EAOFA,EAAKvC,MAGPR,EAAQS,EAASuC,YAAcD,EAAK7D,MAGpCc,EAAQiD,KAAOxC,EAASyC,QAQD,WAAnBlD,EAAQI,SACVJ,EAAQI,OAAS,OACjBJ,EAAQK,SAzXVE,GAmYFP,EAAQS,SAAW,KACZG,GANEmC,GA3BP/C,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAIyC,UAAU,oCAC5B9C,EAAQS,SAAW,KACZG,YAoDFuC,EAAaC,OAChBC,EAAQ,CAAEC,OAAQF,EAAK,IAEvB,KAAKA,IACPC,EAAME,SAAWH,EAAK,IAGpB,KAAKA,IACPC,EAAMG,WAAaJ,EAAK,GACxBC,EAAMI,SAAWL,EAAK,SAGnBM,WAAWC,KAAKN,YAGdO,EAAcP,OACjBpC,EAASoC,EAAMQ,YAAc,GACjC5C,EAAOE,KAAO,gBACPF,EAAOZ,IACdgD,EAAMQ,WAAa5C,WAGZhB,EAAQL,QAIV8D,WAAa,CAAC,CAAEJ,OAAQ,SAC7B1D,EAAYqC,QAAQkB,EAAczB,WAC7BoC,OAAM,YA8BJhC,EAAOiC,MACVA,EAAU,KACRC,EAAiBD,EAAStF,MAC1BuF,SACKA,EAAe1C,KAAKyC,MAGA,mBAAlBA,EAASd,YACXc,MAGJE,MAAMF,EAASG,QAAS,KACvBC,GAAK,EAAGlB,EAAO,SAASA,WACjBkB,EAAIJ,EAASG,WAChB7F,EAAOiD,KAAKyC,EAAUI,UACxBlB,EAAK/D,MAAQ6E,EAASI,GACtBlB,EAAKzC,MAAO,EACLyC,SAIXA,EAAK/D,WAzeTqB,EA0eI0C,EAAKzC,MAAO,EAELyC,UAGFA,EAAKA,KAAOA,SAKhB,CAAEA,KAAMmB,YAIRA,UACA,CAAElF,WAzfPqB,EAyfyBC,MAAM,UA7ZnCe,EAAkBnD,UAAY2D,EAAGsC,YAAc7C,EAC/CA,EAA2B6C,YAAc9C,EACzCA,EAAkB+C,YAAcvF,EAC9ByC,EACA3C,EACA,qBAaFZ,EAAQsG,oBAAsB,SAASC,OACjCC,EAAyB,mBAAXD,GAAyBA,EAAOH,oBAC3CI,IACHA,IAASlD,GAG2B,uBAAnCkD,EAAKH,aAAeG,EAAKC,QAIhCzG,EAAQ0G,KAAO,SAASH,UAClBrG,OAAOyG,eACTzG,OAAOyG,eAAeJ,EAAQhD,IAE9BgD,EAAOK,UAAYrD,EACnBzC,EAAOyF,EAAQ3F,EAAmB,sBAEpC2F,EAAOpG,UAAYD,OAAO2B,OAAOiC,GAC1ByC,GAOTvG,EAAQ6G,MAAQ,SAASzE,SAChB,CAAEqC,QAASrC,IAsEpB2B,EAAsBE,EAAc9D,WACpC8D,EAAc9D,UAAUO,GAAuB,kBACtC+C,MAETzD,EAAQiE,cAAgBA,EAKxBjE,EAAQ8G,MAAQ,SAAStF,EAASC,EAASC,EAAMC,EAAauC,QACxC,IAAhBA,IAAwBA,EAAc6C,aAEtCC,EAAO,IAAI/C,EACb1C,EAAKC,EAASC,EAASC,EAAMC,GAC7BuC,UAGKlE,EAAQsG,oBAAoB7E,GAC/BuF,EACAA,EAAKhC,OAAON,MAAK,SAASF,UACjBA,EAAOjC,KAAOiC,EAAOvD,MAAQ+F,EAAKhC,WAuKjDjB,EAAsBD,GAEtBhD,EAAOgD,EAAIlD,EAAmB,aAO9BkD,EAAGtD,GAAkB,kBACZiD,MAGTK,EAAGmD,SAAW,iBACL,sBAkCTjH,EAAQkH,KAAO,SAASC,OAClBD,EAAO,OACN,IAAIlG,KAAOmG,EACdD,EAAKxB,KAAK1E,UAEZkG,EAAKE,UAIE,SAASpC,SACPkC,EAAKjB,QAAQ,KACdjF,EAAMkG,EAAKG,SACXrG,KAAOmG,SACTnC,EAAK/D,MAAQD,EACbgE,EAAKzC,MAAO,EACLyC,SAOXA,EAAKzC,MAAO,EACLyC,IAsCXhF,EAAQ6D,OAASA,EAMjB7B,EAAQ7B,UAAY,CAClBiG,YAAapE,EAEb6D,MAAO,SAASyB,WACTC,KAAO,OACPvC,KAAO,OAGPpC,KAAOa,KAAKZ,WApgBjBP,OAqgBKC,MAAO,OACPC,SAAW,UAEXL,OAAS,YACTC,SAzgBLE,OA2gBKmD,WAAWzB,QAAQ2B,IAEnB2B,MACE,IAAIb,KAAQhD,KAEQ,MAAnBgD,EAAKe,OAAO,IACZpH,EAAOiD,KAAKI,KAAMgD,KACjBT,OAAOS,EAAKgB,MAAM,WAChBhB,QAnhBXnE,IAyhBFoF,KAAM,gBACCnF,MAAO,MAGRoF,EADYlE,KAAKgC,WAAW,GACLG,cACH,UAApB+B,EAAWzE,WACPyE,EAAWvF,WAGZqB,KAAKmE,MAGd9E,kBAAmB,SAAS+E,MACtBpE,KAAKlB,WACDsF,MAGJ9F,EAAU0B,cACLqE,EAAOC,EAAKC,UACnBhF,EAAOE,KAAO,QACdF,EAAOZ,IAAMyF,EACb9F,EAAQiD,KAAO+C,EAEXC,IAGFjG,EAAQI,OAAS,OACjBJ,EAAQK,SApjBZE,KAujBY0F,MAGP,IAAI9B,EAAIzC,KAAKgC,WAAWQ,OAAS,EAAGC,GAAK,IAAKA,EAAG,KAChDd,EAAQ3B,KAAKgC,WAAWS,GACxBlD,EAASoC,EAAMQ,cAEE,SAAjBR,EAAMC,cAIDyC,EAAO,UAGZ1C,EAAMC,QAAU5B,KAAK8D,KAAM,KACzBU,EAAW7H,EAAOiD,KAAK+B,EAAO,YAC9B8C,EAAa9H,EAAOiD,KAAK+B,EAAO,iBAEhC6C,GAAYC,EAAY,IACtBzE,KAAK8D,KAAOnC,EAAME,gBACbwC,EAAO1C,EAAME,UAAU,GACzB,GAAI7B,KAAK8D,KAAOnC,EAAMG,kBACpBuC,EAAO1C,EAAMG,iBAGjB,GAAI0C,MACLxE,KAAK8D,KAAOnC,EAAME,gBACbwC,EAAO1C,EAAME,UAAU,OAG3B,CAAA,IAAI4C,QAMH,IAAI7F,MAAM,6CALZoB,KAAK8D,KAAOnC,EAAMG,kBACbuC,EAAO1C,EAAMG,gBAU9BxC,OAAQ,SAASG,EAAMd,OAChB,IAAI8D,EAAIzC,KAAKgC,WAAWQ,OAAS,EAAGC,GAAK,IAAKA,EAAG,KAChDd,EAAQ3B,KAAKgC,WAAWS,MACxBd,EAAMC,QAAU5B,KAAK8D,MACrBnH,EAAOiD,KAAK+B,EAAO,eACnB3B,KAAK8D,KAAOnC,EAAMG,WAAY,KAC5B4C,EAAe/C,SAKnB+C,IACU,UAATjF,GACS,aAATA,IACDiF,EAAa9C,QAAUjD,GACvBA,GAAO+F,EAAa5C,aAGtB4C,EAAe,UAGbnF,EAASmF,EAAeA,EAAavC,WAAa,UACtD5C,EAAOE,KAAOA,EACdF,EAAOZ,IAAMA,EAET+F,QACGhG,OAAS,YACT6C,KAAOmD,EAAa5C,WAClB5C,GAGFc,KAAK2E,SAASpF,IAGvBoF,SAAU,SAASpF,EAAQwC,MACL,UAAhBxC,EAAOE,WACHF,EAAOZ,UAGK,UAAhBY,EAAOE,MACS,aAAhBF,EAAOE,UACJ8B,KAAOhC,EAAOZ,IACM,WAAhBY,EAAOE,WACX0E,KAAOnE,KAAKrB,IAAMY,EAAOZ,SACzBD,OAAS,cACT6C,KAAO,OACa,WAAhBhC,EAAOE,MAAqBsC,SAChCR,KAAOQ,GAGP7C,GAGT0F,OAAQ,SAAS9C,OACV,IAAIW,EAAIzC,KAAKgC,WAAWQ,OAAS,EAAGC,GAAK,IAAKA,EAAG,KAChDd,EAAQ3B,KAAKgC,WAAWS,MACxBd,EAAMG,aAAeA,cAClB6C,SAAShD,EAAMQ,WAAYR,EAAMI,UACtCG,EAAcP,GACPzC,UAKJ,SAAS0C,OACX,IAAIa,EAAIzC,KAAKgC,WAAWQ,OAAS,EAAGC,GAAK,IAAKA,EAAG,KAChDd,EAAQ3B,KAAKgC,WAAWS,MACxBd,EAAMC,SAAWA,EAAQ,KACvBrC,EAASoC,EAAMQ,cACC,UAAhB5C,EAAOE,KAAkB,KACvBoF,EAAStF,EAAOZ,IACpBuD,EAAcP,UAETkD,SAML,IAAIjG,MAAM,0BAGlBkG,cAAe,SAASzC,EAAUf,EAAYE,eACvCzC,SAAW,CACd/B,SAAUoD,EAAOiC,GACjBf,WAAYA,EACZE,QAASA,GAGS,SAAhBxB,KAAKtB,cAGFC,SA7rBPE,GAgsBOK,IAQJ3C,EA7sBM,CAotBgBwI,EAAOxI,aAIpCyI,mBAAqB1I,EACrB,MAAO2I,GAUPC,SAAS,IAAK,yBAAdA,CAAwC5I,OCtuB7B6I,EAAe,yBAIfC,EAAgB,qEAIhBC,OAAuBD,OAEvBE,SAA4BF,MAE5BG,4CAmBAC,EAA6BC,8MAQ7BC,EAAc,kBAEdC,EAAoB,6CAyB3BC,EAA2C,CAC/CC,MAAO,OACPC,kBAAkB,EAClBC,WAAW,EACXC,WAAW,EACXC,UAAU,EACVC,MAAM,GAGFC,EAAmC,CACvCC,iBAAkB,mCAClBC,kBAAmB,mCACnBC,oBAAqB,mDACrBC,eAAgB,0BAChBC,UAAWZ,GAGPa,EAA2C,CAC/CL,iBAAkB,yBAClBC,kBAAmB,yBACnBC,oBAAqB,yBACrBC,eAAgB,yBAChBC,UAAWZ,EACXc,iBAAkB,mBAClBC,iBAAkB,cAKdC,EAA0B,CAC9BR,8DACAC,+DACAC,iFACAC,4DACAC,UAAW/J,OAAOoK,OAAO,GAAIjB,EAAqB,CAAEC,MAAO,WA4BhDiB,GAAW,CACtBrH,KAAM,SACNsH,WAAY,CACVC,SAAU,CACRvH,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,eACNvD,KAAM,SACNyH,SAAU,gBACVC,QArG2B,oBAuG7B,CACEnE,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,itCAoBFC,MAAO,iBAETC,cAAe,CACb/H,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,eACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,gBACNvD,KAAM,SACNyH,SAAU,yBACVC,QAAS,MAEX,CACEnE,KAAM,mBACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,OACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAGbC,SAAU,EACVC,SAAU,EACVC,KACE,+uBAeFC,MAAO,kBAETE,QAAS,CACPhI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,UACVC,QAAY9B,MAAmBE,IAGnC6B,SAAU,EACVC,SAAU,EACVC,KACE,ieAgBFC,MAAO,sBAETG,UAAW,CACTjI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,SACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,SACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,cACNvD,KAAM,SACNyH,SAAU,UACVC,WAAY9B,GAEd,CACErC,KAAM,cACNvD,KAAM,SACNyH,SAAU,UACVC,WAAY5B,IAGhB6B,SAAU,EACVC,SAAU,EACVC,KACE,gQAQFC,MAAO,sBAETI,mBAAoB,CAClBlI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,mBACNvD,KAAM,SACNyH,SAAU,UACVC,WAAY5B,GAEd,CACEvC,KAAM,gBACNvD,KAAM,SACNyH,SAAU,SACVC,QAAS,iCAEX,CACEnE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,SACVC,QAAS,mCAEX,CACEnE,KAAM,MACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,QACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,8ZAUFC,MAAO,sBAETK,6BAA8B,CAC5BnI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,mBACNvD,KAAM,SACNyH,SAAU,UACVC,WAAY5B,GAEd,CACEvC,KAAM,gBACNvD,KAAM,SACNyH,SAAU,SACVC,QAAS,iCAEX,CACEnE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,SACVC,QAAS,mCAEX,CACEnE,KAAM,iBACNvD,KAAM,SACNyH,SAAU,UACVC,WAAY5B,IAGhB6B,SAAU,EACVC,SAAU,EACVC,KACE,ySAQFC,MAAO,sBAETM,gBAAiB,CACfpI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,UACVC,QAAY9B,MAAmBE,IAGnC6B,SAAU,EACVC,SAAU,EACVC,KACE,8cAcFC,MAAO,sBAETO,iBAAkB,CAChBrI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,0BACNvD,KAAM,SACNyH,SAAU,0BACVC,QAAS,WAEX,CACEnE,KAAM,WACNvD,KAAM,SACNyH,SAAU,WACVC,QAAS,OAGbC,SAAU,EACVC,SAAU,EACVC,KACE,4bASFC,MAAO,kBAETQ,gBAAiB,CACftI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,cACNvD,KAAM,SACNyH,SAAU,OACVC,QAAS,MAEX,CACEnE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,SACVC,QAAS,iCAEX,CACEnE,KAAM,MACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,QACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,uWASFC,MAAO,sBAETS,KAAM,CACJvI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,SACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAS,WAGbC,SAAU,EACVC,SAAU,EACVC,KAAM,mEACNC,MAAO,OAETU,iBAAkB,CAChBxI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAS,MAEX,CACEnE,KAAM,WACNvD,KAAM,SACNyH,SAAU,WACVC,QAAS,OAGbC,SAAU,EACVC,SAAU,EACVC,KACE,ydAUFC,MAAO,kBAETW,OAAQ,CACNzI,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,UACVC,QAAY9B,MAAmBE,IAGnC6B,SAAU,EACVC,SAAU,EACVC,KACE,oeAUFC,MAAO,kBAETY,iBAAkB,CAChB1I,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,qBACNvD,KAAM,SACNyH,SAAU,qBACVC,QAAY7B,MAAsBH,MAAgBQ,GAEpD,CACE3C,KAAM,aACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,WACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,gBACNvD,KAAM,SACNyH,SAAU,0BAEZ,CACElE,KAAM,WACNvD,KAAM,SACNyH,SAAU,OACVC,QAAS,OAGbC,SAAU,EACVC,SAAU,EACVC,KACE,yrBAaFC,MAAO,QAETa,aAAc,CACZ3I,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAYhC,MAAgBQ,OAE9B,CACE3C,KAAM,aACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,WACNvD,KAAM,SACNyH,SAAU,WACVC,QAAS,MAEX,CACEnE,KAAM,kBACNvD,KAAM,SACNyH,SAAU,cACVC,QAhnBsC,oBAknBxC,CACEnE,KAAM,UACNvD,KAAM,SACNyH,SAAU,UACVC,QA3lBqB,sBA6lBvB,CACEnE,KAAM,SACNvD,KAAM,SACNyH,SAAU,UACVC,QAjmBqB,uBAomBzBC,SAAU,EACVC,SAAU,EACVC,KACE,mtDA4BFC,MAAO,QAETc,aAAc,CACZ5I,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,WACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,kBACNvD,KAAM,SACNyH,SAAU,cACVC,QA7qBsC,oBA+qBxC,CACEnE,KAAM,YACNvD,KAAM,SACNyH,SAAU,OACVC,QAAS,MAEX,CACEnE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,WACVC,QAAS,MAEX,CACEnE,KAAM,UACNvD,KAAM,SACNyH,SAAU,UACVC,QApqBqB,sBAsqBvB,CACEnE,KAAM,OACNvD,KAAM,SACNyH,SAAU,UACVC,QA1qBqB,uBA6qBzBC,SAAU,EACVC,SAAU,EACVC,KACE,20DA+BFC,MAAO,QAETe,gBAAiB,CACf7I,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,WACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,kBACNvD,KAAM,SACNyH,SAAU,cACVC,QAzvBsC,oBA2vBxC,CACEnE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,WACVC,QAAS,MAEX,CACEnE,KAAM,aACNvD,KAAM,SACNyH,SAAU,UACVC,QA1uBqB,uBA6uBzBC,SAAU,EACVC,SAAU,EACVC,KACE,4WAQFC,MAAO,QAETgB,eAAgB,CACd9I,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,WACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,kBACNvD,KAAM,SACNyH,SAAU,cACVC,QAlyBsC,qBAqyB1CC,SAAU,EACVC,SAAU,EACVC,KACE,+gBAaFC,MAAO,QAETiB,oBAAqB,CACnB/I,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,qBACNvD,KAAM,SACNyH,SAAU,qBACVC,QAAY7B,MAAsBH,MAAgBQ,GAEpD,CACE3C,KAAM,aACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,WACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,gBACNvD,KAAM,SACNyH,SAAU,0BAEZ,CACElE,KAAM,WACNvD,KAAM,SACNyH,SAAU,OACVC,QAAS,OAGbC,SAAU,EACVC,SAAU,EACVC,KACE,u/BAaFC,MAAO,QAETkB,YAAa,CACXhJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,YAAahC,MAAgBQ,OAE/B,CACE3C,KAAM,iBACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,aACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,eACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,GAEX,CACE1C,KAAM,gBACNvD,KAAM,SACNyH,SAAU,2BAGdE,SAAU,EACVC,SAAU,EACVC,KACE,y2CA4BFC,MAAO,QAETmB,oBAAqB,CACnBjJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS5B,GAEX,CACEvC,KAAM,OACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,aAGbC,SAAU,EACVC,SAAU,EACVC,KACE,iwDAkDFC,MAAO,sBAEToB,eAAgB,CACdlJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS5B,GAEX,CACEvC,KAAM,cACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,aAGbC,SAAU,EACVC,SAAU,EACVC,KACE,unBAmBFC,MAAO,sBAETqB,YAAa,CACXnJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,2mBAcFC,MAAO,kBAETsB,sBAAuB,CACrBpJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,YAAahC,MAAgBQ,QAGjCyB,SAAU,EACVC,SAAU,EACVC,KACE,sKAEFC,MAAO,2BAETuB,uBAAwB,CACtBrJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAYhC,MAAgBQ,OAE9B,CACE3C,KAAM,OACNvD,KAAM,SACNyH,SAAU,cACVC,QAAS,aAGbC,SAAU,EACVC,SAAU,EACVC,KACE,gMAGFC,MAAO,2BAETwB,kBAAmB,CACjBtJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,OACNvD,KAAM,SACNyH,SAAU,iBACVC,QA/kCkB,qBAklCtBC,SAAU,EACVC,SAAU,EACVC,KACE,6PAUFC,MAAO,iBAETyB,gCAAiC,CAC/BvJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,eACNvD,KAAM,SACNyH,SAAU,eACVC,QAjpCuB,yBAopC3BC,SAAU,EACVC,SAAU,EACVC,KACE,wLAGFC,MAAO,wBAET0B,aAAc,CACZxJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,0BAEZ,CACElE,KAAM,qBACNvD,KAAM,SACNyH,SAAU,qBACVC,QAAYhC,MAAgBQ,MAAqBL,GAEnD,CACEtC,KAAM,aACNvD,KAAM,SACNyH,SAAU,MACVC,QAASzB,IAGb0B,SAAU,EACVC,SAAU,EACVC,KACE,s3CA4BFC,MAAO,kBAET2B,eAAgB,CACdzJ,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,0BAEZ,CACElE,KAAM,QACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,aAGbC,SAAU,EACVC,SAAU,EACVC,KACE,guCA+BFC,MAAO,kBAET4B,gBAAiB,CACf1J,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,2BAGdE,SAAU,EACVC,SAAU,EACVC,KACE,4oBAkBFC,MAAO,kBAET6B,sBAAuB,CACrB3J,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,2BAGdE,SAAU,EACVC,SAAU,EACVC,KACE,kwBAkBFC,MAAO,kBAET8B,aAAc,CACZ5J,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAzyC2B,qBA4yC/BC,SAAU,EACVC,SAAU,EACVC,KACE,mQASFC,MAAO,iBAETD,KAAM,CACJ7H,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,YAGdE,SAAU,EACVC,SAAU,EACVC,KAAM,yCACNC,MAAO,OAET+B,OAAQ,CACN7J,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAYhC,MAAgBQ,QAGhCyB,SAAU,EACVC,SAAU,EACVC,KACE,qHAMFC,MAAO,2BAETgC,MAAO,CACL9J,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,aACNvD,KAAM,SACNyH,SAAU,aACVC,QAAS7B,IAGb8B,SAAU,EACVC,SAAU,EACVC,KACE,kIAMFC,MAAO,2BAETiC,cAAe,CACb/J,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,2BAGdE,SAAU,EACVC,SAAU,EACVC,KACE,4kBAgBFC,MAAO,kBAETkC,cAAe,CACbhK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,YAAahC,MAAgBQ,OAE/B,CACE3C,KAAM,aACNvD,KAAM,SACNyH,SAAU,aACVC,QAAS7B,GAEX,CACEtC,KAAM,kBACNvD,KAAM,SACNyH,SAAU,MACVC,QAAS,MAEX,CACEnE,KAAM,eACNvD,KAAM,SACNyH,SAAU,MACVC,QAAS,OAGbC,SAAU,EACVC,SAAU,EACVC,KACE,gsBAeFC,MAAO,iBAETmC,YAAa,CACXjK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAShC,GAEX,CACEnC,KAAM,aACNvD,KAAM,SACNyH,SAAU,aACVC,QAAS7B,GAEX,CACEtC,KAAM,kBACNvD,KAAM,SACNyH,SAAU,MACVC,QAAS,MAEX,CACEnE,KAAM,aACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,WACNvD,KAAM,SACNyH,SAAU,OACVC,QAAS,MAEX,CACEnE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAr+C2B,qBAw+C/BC,SAAU,EACVC,SAAU,EACVC,KACE,iqDA6BFC,MAAO,wBAEToC,mBAAoB,CAClBlK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,eACNvD,KAAM,SACNyH,SAAU,eACVC,QApjDuB,wBAsjDzB,CACEnE,KAAM,iBACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS9B,GAEX,CACErC,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,sOAGFC,MAAO,wBAETqC,iBAAkB,CAChBnK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,eACNvD,KAAM,SACNyH,SAAU,eACVC,QAllDuB,wBAolDzB,CACEnE,KAAM,iBACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS9B,GAEX,CAEErC,KAAM,UACNvD,KAAM,SACNyH,SAAU,iBACVC,QA9jDiB,cAgkDnB,CAEEnE,KAAM,WACNvD,KAAM,SACNyH,SAAU,iBACVC,QArkDiB,cAukDnB,CAEEnE,KAAM,cACNvD,KAAM,SACNyH,SAAU,iBACVC,QA5kDiB,cA8kDnB,CAEEnE,KAAM,OACNvD,KAAM,SACNyH,SAAU,iBACVC,QAnlDiB,cAqlDnB,CAEEnE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,oBACVC,QAAS,iCAEX,CAEEnE,KAAM,oBACNvD,KAAM,SACNyH,SAAU,SACVC,QAjmDiB,cAmmDnB,CAEEnE,KAAM,oBACNvD,KAAM,SACNyH,SAAU,SACVC,QAxmDiB,cA0mDnB,CACEnE,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,GACVC,SAAU,GACVC,KACE,6NAGFC,MAAO,wBAETsC,gBAAiB,CACfpK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,eACNvD,KAAM,SACNyH,SAAU,eACVC,QAjqDuB,wBAmqDzB,CACEnE,KAAM,aACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,wJAEFC,MAAO,wBAETuC,MAAO,CACLrK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAShC,IAGbiC,SAAU,EACVC,SAAU,EACVC,KACE,4LAUFC,MAAO,2BAETwC,gBAAiB,CACftK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,eACNvD,KAAM,SACNyH,SAAU,eACVC,QAjtDuB,yBAotD3BC,SAAU,EACVC,SAAU,EACVC,KACE,mMAWFC,MAAO,wBAETyC,aAAc,CACZvK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,QAEZ,CACElE,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,QAnuDyB,wBAsuD7BC,SAAU,EACVC,SAAU,EACVC,KACE,wUAOFC,MAAO,YAET0C,cAAe,CACbxK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,qBACVC,QAAYhC,MAAgBQ,MAAqBL,GAEnD,CACEtC,KAAM,UACNvD,KAAM,SACNyH,SAAU,QAEZ,CACElE,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,QApwDyB,uBAswD3B,CACEnE,KAAM,WACNvD,KAAM,SACNyH,SAAU,QAGdE,SAAU,EACVC,SAAU,EACVC,KACE,kTAIFC,MAAO,YAET2C,eAAgB,CACdzK,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,QAEZ,CACElE,KAAM,aACNvD,KAAM,SACNyH,SAAU,aACVC,QAAY7B,EAAAA,0BAGhB8B,SAAU,EACVC,SAAU,EACVC,KACE,yaASFC,MAAO,YAET4C,MAAO,CACL1K,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,yBACVC,QAAShC,GAEX,CACEnC,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,iBACNvD,KAAM,SACNyH,SAAU,aACVC,QAAS7B,GAEX,CACEtC,KAAM,WACNvD,KAAM,SACNyH,SAAU,QAEZ,CACElE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAh0D2B,qBAm0D/BC,SAAU,EACVC,SAAU,EACVC,KACE,67DAwCFC,MAAO,4BAET6C,SAAU,CACR3K,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,yBACVC,QAAShC,GAEX,CACEnC,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,QAn5DyB,uBAq5D3B,CACEnE,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,WACNvD,KAAM,SACNyH,SAAU,OAEZ,CACElE,KAAM,WACNvD,KAAM,SACNyH,SAAU,SAGdE,SAAU,EACVC,SAAU,EACVC,KACE,kyDA+BFC,MAAO,4BAET8C,cAAe,CACb5K,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAShC,GAEX,CACEnC,KAAM,aACNvD,KAAM,SACNyH,SAAU,aACVC,QAAS7B,GAEX,CACEtC,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,kBACNvD,KAAM,SACNyH,SAAU,OAEZ,CACElE,KAAM,WACNvD,KAAM,SACNyH,SAAU,SAGdE,SAAU,EACVC,SAAU,EACVC,KACE,g/DAiCFC,MAAO,4BAET+C,mBAAoB,CAClB7K,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAASxB,GAEX,CACE3C,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,QA7hEyB,uBA+hE3B,CACEnE,KAAM,WACNvD,KAAM,SACNyH,SAAU,OAEZ,CACElE,KAAM,YACNvD,KAAM,SACNyH,SAAU,OAEZ,CACElE,KAAM,WACNvD,KAAM,SACNyH,SAAU,SAGdE,SAAU,EACVC,SAAU,EACVC,KACE,++BAgBFC,MAAO,4BAETgD,OAAQ,CACN9K,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,yBACVC,QAAShC,GAEX,CACEnC,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,quBAaFC,MAAO,4BAETiD,SAAU,CACR/K,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,oBACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS9B,GAEX,CACErC,KAAM,SACNvD,KAAM,SACNyH,SAAU,WACVC,QArmEiB,cAumEnB,CACEnE,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,45BAiBFC,MAAO,sBAETkD,YAAa,CACXhL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,UACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS5B,GAEX,CACEvC,KAAM,SACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,MACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,QACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,OACNvD,KAAM,SACNyH,SAAU,SACVC,QAAS,cAGbC,SAAU,EACVC,SAAU,EACVC,KACE,+1CAoCFC,MAAO,sBAETmD,MAAO,CACLjL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,SACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,SACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,cACNvD,KAAM,SACNyH,SAAU,UACVC,WAAY9B,GAEd,CACErC,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,MACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,YAEX,CACEnE,KAAM,QACNvD,KAAM,SACNyH,SAAU,UACVC,QAAS,aAGbC,SAAU,EACVC,SAAU,EACVC,KACE,+PAQFC,MAAO,sBAEToD,gBAAiB,CACflL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,cACNvD,KAAM,SACNyH,SAAU,UACVC,WAAY5B,IAGhB6B,SAAU,EACVC,SAAU,EACVC,KACE,iIAKFC,MAAO,sBAETqD,SAAU,CACRnL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,yBACVC,QAAShC,GAEX,CACEnC,KAAM,iBACNvD,KAAM,SACNyH,SAAU,aACVC,QAAS7B,GAEX,CACEtC,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAS,kBAEX,CACEnE,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,+rCAoBFC,MAAO,4BAETsD,YAAa,CACXpL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,yBACVC,QAAShC,GAEX,CACEnC,KAAM,aACNvD,KAAM,SACNyH,SAAU,aACVC,QAAS7B,GAEX,CACEtC,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,IAGhB4B,SAAU,EACVC,SAAU,EACVC,KACE,+bAOFC,MAAO,4BAETuD,YAAa,CACXrL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,yBACVC,QAAShC,GAEX,CACEnC,KAAM,aACNvD,KAAM,SACNyH,SAAU,aACVC,QAAS7B,GAEX,CACEtC,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,WACNvD,KAAM,SACNyH,SAAU,QAEZ,CACElE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAv5E2B,qBA05E/BC,SAAU,EACVC,SAAU,EACVC,KACE,8fAOFC,MAAO,4BAETwD,OAAQ,CACNtL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,yBACVC,QAAShC,GAEX,CACEnC,KAAM,WACNvD,KAAM,SACNyH,SAAU,QAEZ,CACElE,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,cACNvD,KAAM,SACNyH,SAAU,cACVC,WAAY3B,GAEd,CACExC,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAp8E2B,qBAu8E/BC,SAAU,EACVC,SAAU,EACVC,KACE,sgEAuCFC,MAAO,4BAETyD,MAAO,CACLvL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAShC,EAAe,IAAMQ,IAGlCyB,SAAU,EACVC,SAAU,EACVC,KACE,42BAqBFC,MAAO,2BAET0D,cAAe,CACbxL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,WACNvD,KAAM,SACNyH,SAAU,SAGdE,SAAU,EACVC,SAAU,EACVC,KACE,mZAWFC,MAAO,iBAET2D,sBAAuB,CACrBzL,KAAM,QACNwH,MAAO,CACL,CACEjE,KAAM,gBACNvD,KAAM,SACNyH,SAAU,gBACVC,QAAShC,EAAe,IAAMQ,GAEhC,CACE3C,KAAM,SACNvD,KAAM,SACNyH,SAAU,SACVC,QAAShC,EAAe,IAAMQ,GAEhC,CACE3C,KAAM,YACNvD,KAAM,SACNyH,SAAU,cACVC,QAzlFyB,wBA4lF7BC,SAAU,EACVC,SAAU,EACVC,KACE,yvCA+BFC,MAAO,QAGX4D,sBAAsB,EACtBC,QAAQ,GAIGC,aAAkBC,OAAa,izEA6D5C,SAASC,GAAiBC,EAAgBC,EAAeC,WACjDC,EAAQD,EAAWE,MAAM,MAC3BC,EAAM,GACNC,EAAM,GACDrJ,EAAI,EAAGA,EAAI+I,EAAQ/I,IAC1BqJ,GAAO,QAGJ,IAAIrJ,EAAI,EAAGA,EAAIkJ,EAAMnJ,OAAQC,IAAK,KACjCsJ,EAAUD,EAAI9H,QACZgI,EAAQL,EAAMlJ,GAAGmJ,MAAM,KAAKK,QAAO,SAAAC,UAAQA,EAAK1J,OAAS,QAC3C,GAAhBwJ,EAAMxJ,UAKO,MAAbwJ,EAAM,IAA2C,SAA7BL,EAAMlJ,GAAG0J,UAAU,EAAG,QAMzC,IAAIC,EAAI,EAAGA,EAAIJ,EAAMxJ,OAAQ4J,IAAK,IACb,IAApBJ,EAAMI,GAAG5J,OAAc,CAEzBuJ,GAAW,WAITA,EAAQH,MAAM,MAAM5H,OAAO,GAAG,GAAGxB,OAAS,EAAIwJ,EAAMI,GAAG5J,OAASiJ,IAClEM,GAAW,KACXA,GAAWD,GAEbC,GAAWC,EAAMI,GAAK,IAGxBP,GAAOE,EAAU,UAlBfF,GAAOF,EAAMlJ,GAAK,UANlBoJ,GAAO,YA0BJA,EA4ET,SAASQ,aACDC,EAA4B,GAC5BC,EAAW9P,OAAOgH,KAAKqD,GAASC,YAC7BtE,EAAI,EAAGA,EAAI8J,EAAS/J,OAAQC,IAAK,KAClC+J,EAAUD,EAAS9J,GACnB8E,EAAQT,GAASC,WAAWyF,GAASjF,MAEtC+E,EAAO1P,eAAe2K,GAQzB+E,EAAO/E,GAAOtF,KAAK,CACjBuK,QAASA,EACTlF,KAAMR,GAASC,WAAWyF,GAASlF,OATrCgF,EAAO/E,GAAS,CACd,CACEiF,QAASA,EACTlF,KAAMR,GAASC,WAAWyF,GAASlF,cAUpCgF,WAMOG,aACRH,EAASD,KACTK,EAAajQ,OAAOgH,KAAK6I,GAAQK,OAEnCC,wBAA4BtB,OAAa,oCACpC7I,EAAI,EAAGA,EAAIiK,EAAWlK,OAAQC,IAAK,CAC1CmK,QAAYF,EAAWjK,gBACjBoK,EAAO,GACJT,EAAI,EAAGA,EAAIE,EAAOI,EAAWjK,IAAID,OAAQ4J,IAChDS,EAAK5K,KAAKqK,EAAOI,EAAWjK,IAAI2J,GAAGI,SAarCI,GAAO,SATgBrB,GAAiB,EAAG,GAAIsB,EAAKC,KAAK,MAIpDlB,MAAM,UACNmB,KAAI,SAAAC,UAAQA,EAAKC,OAAOC,QAAQ,KAAM,SACtCJ,KAAK,UACR,KAGFF,GAAO,YAEFA,EAAIK,gBA6BGE,GAAuBX,OACjCI,EAAM,MACM,QAAZJ,4BAxBEF,EAASD,KACTK,EAAajQ,OAAOgH,KAAK6I,GAAQK,OAEjCS,EAAQ,GACVP,EAAO,GACFpK,EAAI,EAAGA,EAAIiK,EAAWlK,OAAQC,QAChC,IAAI2J,EAAI,EAAGA,EAAIE,EAAOI,EAAWjK,IAAID,OAAQ4J,IAChDS,EAAK5K,KAAKqK,EAAOI,EAAWjK,IAAI2J,GAAGI,SAIvCK,EAAOA,EAAKF,WACP,IAAIlK,EAAI,EAAGA,EAAIoK,EAAKrK,OAAQC,IAC/B2K,EAAMnL,KAAKkL,GAAuBN,EAAKpK,IAAIwK,eAGtCG,EAAMN,KAAK,QASTO,OAEJb,SACIC,SAGHa,EAAcxG,GAASC,WAAWyF,OACnCc,GAA2B,SAAZd,SACXC,SAGHnF,EAAOgG,EAAYhG,KAEnBiG,EA3JR,SACEC,EACAC,OAEIC,EAAW,GACXC,EAAU,GACVC,EAAQ,GACNN,EAAcxG,GAASC,WAAWyG,GAExCE,OAAgBF,UACX,IAAI/K,EAAI,EAAGA,EAAIgL,EAAYjL,OAAQC,IAAK,KACtCgL,EAAYhL,GAAGO,WAClB6K,QAAQC,IAAIN,GACZK,QAAQC,IAAIL,EAAYhL,IAClB,IAAI7D,MAAM,+CAGhB8O,GADEjL,EAAI,GAAK6K,EAAYlG,SACRqG,EAAYhL,GAAGO,KAAK+K,sBAEnBN,EAAYhL,GAAGO,KAAK+K,mBAIxCJ,OAAeH,UACV,IAAI/K,EAAI,EAAGA,EAAI+K,EAAYhL,OAAS,EAAGC,IAC1CmL,GAAS,QAGN,IAAInL,EAAI,EAAGA,EAAIgL,EAAYjL,OAAQC,IAAK,KACtCgL,EAAYhL,GAAGyE,eAClB2G,QAAQC,IAAIN,GACZK,QAAQC,IAAIL,EAAYhL,IAClB,IAAI7D,MAAM,mDAGhB+O,GADElL,EAAI,GAAK6K,EAAYlG,cACPqG,EAAYhL,GAAGO,SAAQyK,EAAYhL,GAAGyE,SAAS6G,oBAE9CN,EAAYhL,GAAGO,SAAQyK,EAAYhL,GAAGyE,SAAS6G,kBAElEJ,GAAW,KACXA,GAAWC,QAGN,CAAEI,IAAKN,EAAUO,GAAIN,GAgHVO,CAAuB1B,EAASc,EAAYrG,OACxDkH,EAAgB5C,GAAiB,EAAG,GAAIjE,UAG9CsF,eAAmBJ,OACnBI,GAAO,WACPA,GAAUW,EAAUS,SACpBpB,GAAUW,EAAUU,SACpBrB,GAAOuB,GACIlB,OAAS,cAiHNmB,GAAeC,EAAgB9Q,MACzC8Q,MAAAA,EAAK9Q,UACA,KACF,GAAyB,iBAAd8Q,EAAK9Q,YACX8Q,EAAK9Q,SAET,IAAIqB,iBAAiBrB,gCAIf+Q,GAAaD,EAAgB9Q,MAClB,kBAAd8Q,EAAK9Q,IAAoC,OAAd8Q,EAAK9Q,WAChC8Q,EAAK9Q,SAER,IAAIqB,iBAAiBrB,iCAcfgR,GAAoBF,EAAgB9Q,OAC5CC,EAAa6Q,EAAK9Q,MACpBC,MAAAA,SACK,KACF,GAdT,SAAuBA,UACjBA,aAAiBgR,OACZhR,EACJuP,KAAI,SAAC0B,SAAwB,iBAANA,KACvBC,QAAO,SAACC,EAAYC,UAAeD,GAAKC,KAAG,GAUrCC,CAAcrR,UAChBA,QAED,IAAIoB,iBAAiBrB,sCChkGfuR,GACdC,EACAC,UAEOC,kBAA2BF,EAAYC,GCmBhD,IAAME,GAAWC,QAAQ,aAyBnBC,yBAIQC,YAAAA,IAAAA,EAAU,SACfA,QAAUA,OACVC,YAAa,6BAGpBC,WAAA,6BACSjM,QAAQ1C,UAAUK,MAAK,kBAAMuO,EAAKH,cAG3CI,gBAAA,SAAgBC,EAAqCC,UAC5CrM,QAAQ1C,UAAUK,MAAK,kBAGhC2O,cAAA,kBACS,QAIEC,kFAAmBT,IAEnBU,0BAKCC,EAAsBC,gCAE3BD,aAAeE,OAAOC,KAAKH,EAAc,SACzCC,YAAcA,IACdV,YAAa,UAGVa,EAASC,SAAiBC,UAAUC,EAAKP,gBAE1CQ,EAAIC,SAASJ,SAAiBK,MAAM,CADzBN,EAAQ,KAC4BnM,MAAM,GAAI,MACzDqL,QAAUe,UAAkBM,cAC/BN,SAAiBO,QAAQL,EAAKP,cAC9Bd,SAAkB2B,QAAQC,OAAOC,YAEnC,MAAOC,SACPC,QAAaD,GACP,IAAInS,MAAM,0FAIpB2Q,WAAA,6BACSjM,QAAQ1C,UAAUK,MAAK,kBAAMgQ,EAAK5B,cAG3CI,gBAAA,SAAgByB,EAAoCC,qBAC3C7N,QAAQ1C,UAAUK,MAAK,WACVmQ,EAAKpB,YAAYhM,MAAM,EAAGoN,EAAKb,GACvChQ,SAAQ,SAAA8Q,OACVC,EAASrC,oBAA6BoC,GAC5CH,EAAKK,KAAKJ,EAAcG,EAAQF,EAAKrB,uBAK3CH,cAAA,kBACS,MAxC4BR,IA4C1BoC,0BAMCzB,EAAsB0B,EAAuBlB,EAAWP,sCAE7DD,aAAeE,OAAOC,KAAKH,EAAc,SACzC0B,cAAgBxB,OAAOC,KAAKuB,EAAe,SAC3CpC,QAAUe,UAAkBM,cAC/BN,SAAiBO,QAAQe,EAAK3B,cAC9Bd,SAAkB2B,QAAQC,OAAOC,cAG9Bd,YAAcA,IACdO,EAAIA,IACJjB,YAAa,sCAGpBC,WAAA,6BACSjM,QAAQ1C,UAAUK,MAAK,kBAAM0Q,EAAKtC,cAG3CuC,SAAA,SAASV,EAAoCC,EAAsBU,OAG3DC,EAAcZ,EAAaa,KAC3BC,EAAU,IAAI/B,OAAO6B,EAAWG,IAAId,GAAce,KAAKlO,SACvDmO,EAAWL,EAAWG,IAAId,GAAciB,MAE9CJ,EAAQrO,kBACF0O,EAAOL,EAAQxO,SAAS,OAErBf,EAAI,EAAGA,EAAIoP,EAAMrP,OAAQC,OAC5BoP,EAAMpP,GAAG6P,UAAYD,GAAQR,EAAMpP,GAAG8P,cAAgBJ,EAAU,KAC7DN,EAAMpP,GAAGjF,YACN,IAAIoB,uBAAuByT,WAAaF,0BAEzCN,EAAMpP,SAGX,IAAI7D,gCAAgCyT,WAAaF,MAGzD1C,gBAAA,SAAgByB,EAAoCC,qBAM3C7N,QAAQ1C,UACZK,MAAK,kBACGuR,EAAKjD,gBAEbtO,MAAK,SAAAoO,UACGJ,SAAkB2B,QAAQ6B,SAASpD,MAE3CpO,MAAK,SAAA4Q,OACEa,EAAOF,EAAKZ,SAASV,EAAMC,EAAcU,MAChC,IAAXW,EAAKjC,EAAS,KAEVe,EAASrC,oBAA6BuD,EAAKxC,YAAY,IAC7DkB,EAAKK,KAAKJ,EAAcG,EAAQkB,EAAKzC,kBAAclR,EAAW6T,EAAKlV,YAGjDgV,EAAKxC,YAAYhM,MAAM,EAAGwO,EAAKjC,GACvChQ,SAAQ,SAAA8Q,OACVC,EAASrC,oBAA6BoC,GAC5CH,EAAKK,KACHJ,EACAG,EACAkB,EAAKzC,kBACLlR,EACA6T,EAAKlV,MACLgV,EAAKf,wBAOjB7B,cAAA,kBACS,MAnF8BR,aAgOzBuD,GAAiBC,MACTA,EAAqBC,qGA9GbC,OACzBA,EAAWC,WAAW,iBACnB,IAAInU,MAAM,6BAGZoU,EAAOF,EAAW9O,MAAM,UAAUxB,eACjC,IAAIqN,GAAWmD,GA2GbC,CAAgBL,MAGAA,EAAqBC,MF9Ub,8BEiVxBD,KAGeA,EAAqBC,MF3UH,mEEgOVK,OAC1BC,EAAUD,EAAsBL,MFjOI,uDEkOrCM,QACG,IAAIvU,MAAM,+CAGZ2R,EAAIC,SAAS2C,EAAQ,IACrBC,EAAQF,EAAsBtH,MAAM,KACpCyH,EAAW,GACR5Q,EAAI,EAAGA,EAAI,IAAKA,IAAK,KACtB6Q,EAAKF,EAAM3Q,OACZ6Q,YAIAA,EAAGT,MFxPuB,6BEyPvB,IAAIjU,MAAM,8BAGlByU,EAASpR,KAAKqR,OAIVC,EAAUF,EAAStG,KAAI,SAAAuG,UACpBrD,OAAOC,KAAKsD,GAA2BF,GAAK,UAI/CG,EAAerD,WAAmBsD,KAAK,CAAEnD,EAAAA,EAAGgD,QAAAA,WAC3C,IAAIzD,GAAkB2D,EAAaE,OAAQnQ,SAAS,OAAQ6P,GAiF1DO,CAAkBhB,MAGDA,EAAqBC,MF7U/C,+EEkQkCK,OAC5BC,EAAUD,EAAsBL,MFnQtC,mEEoQKM,QACG,IAAIvU,MAAM,kDAGZ2R,EAAIC,SAAS2C,EAAQ,IACrBC,EAAQF,EAAsBtH,MAAM,KACpCyH,EAAW,GACR5Q,EAAI,EAAGA,EAAI,IAAKA,IAAK,KACtB6Q,EAAKF,EAAM3Q,OACZ6Q,YAIAA,EAAGT,MF9RuB,6BE+RvB,IAAIjU,MAAM,8BAGlByU,EAASpR,KAAKqR,OASZvD,EALEwD,EAAUF,EAAStG,KAAI,SAAAuG,UACpBrD,OAAOC,KAAKsD,GAA2BF,GAAK,UAKjD7B,EAAgB,MACV,IAANlB,EAAS,KAELsD,EAASzD,WAAmByD,OAAO,CAAEC,OAAQP,EAAQ,KAG3DxD,EAFaK,WAAmB2D,KAAK,CAAEC,OAAQH,IAE3BG,OAAQL,OAAQnQ,SAAS,WACxC,KAECkQ,EAAOtD,WAAmBsD,KAAK,CAAEnD,EAAAA,EAAGgD,QAAAA,IACpCU,EAAQ7D,WAAmB6D,MAAM,CAAED,OAAQN,IAGjD3D,EAFaK,WAAmB2D,KAAK,CAAEC,OAAQC,IAE3BD,OAAQL,OAAQnQ,SAAS,OAC7CiO,EAAgBwC,EAAMD,OAAQL,OAAQnQ,SAAS,cAG1C,IAAIgO,GAAoBzB,EAAc0B,EAAelB,EAAG8C,GAgCtDa,CAAoBtB,SAGvB,IAAIhU,MAAM,oCAUFuV,GAAc7W,EAAc8W,mBAAAA,IAAAA,GAAkB,IACtDA,GAAU9I,QAAQ+I,OAAOC,OAAWF,GAAU9I,QAAQ8I,OAAOE,MAC1DC,KAAKvO,UAAU1I,EAAK,KAAM,GAE1BiX,KAAKvO,UAAU1I,YAQVkW,GAA2BgB,UACvBvF,oBAA6BuF,GAC9BC,UAAUjR,SAAS,gBAOtBkR,GACd9D,EACA4D,WAxL0D3V,IA0L/B2V,EA1La5E,qBA2LzB4E,EACDnF,YAGNsF,EAAY1F,oBADPuF,UAEJ5D,EAAQgE,cAAc3F,kBAA2B0F,aAe5CE,GAAoBC,UACZ,IAAlBA,EAAQtS,QAAsC,OAAtBsS,EAAQ9Q,OAAO,GAClC8Q,EAAQ3I,UAAU,EAAG,IAEvB2I,WAsCOC,GAAeC,EAAqBR,OAC5CS,EAAchG,mBAA4B+F,EAAaR,UAGtDL,GADc,CADAlF,mBAA4BgG,cAgFnCC,GACdtE,EACA5N,UAEwB4N,EACrBuE,YAAYnS,GACZ/B,MAAK,SAACmU,UAA2BA,YAC3B,SAACjU,MACgB,mBAAlBA,EAAMkU,eACD,WAEDlU,cAWQmU,4EAAf,WACL1E,EACA5N,EACAuS,wGAAAA,IAAAA,GAA0B,GAEpBC,EAAkBN,GAAgBtE,EAAS5N,GAC3CyS,EAAiBF,EACnBtG,gBAAyBjM,UAAY,kBAAM,QAC3CM,QAAQ1C,UAAUK,MAAK,kBAAM,QAE3ByU,EAAkBF,EAAgBvU,MAAK,SAACmU,UAC5CA,EAAWA,EAASO,SAAW,iBAGWrS,QAAQsS,IAAI,CACtDH,EACAC,EACAF,cAHcG,gBAKZE,OALsBT,8BAQlB,IAAIxW,MAAM,8BAEdwW,EAASxY,eAAe,kBAAmBwY,EAASU,oCAChD,IAAIlX,MACR,4BAA4BwW,EAASW,aAArC,iCACkCX,EAASY,0BAI3CC,EAAa,UAETC,EAAehH,GAASiH,cAAcR,IAC3BS,KAAOF,EAAatZ,eAAe,aAClDqZ,EAAahH,kBAA2BiH,IAE1C,MAAOnF,GACP8E,EAAa,8BAGH,CACVF,SAAUA,EACVU,QAASR,EACTI,WAAYA,gFAUAK,GAAQC,EAAmBC,OACnCC,EAAe,IAAIC,WAAgB,CACvCC,MAAO,SAACC,EAAQC,EAAWC,GACzBA,OAIEC,EAAKC,kBAAyB,CAClCC,MAAO3L,QAAQ4L,MACfvD,OAAQ8C,EACRU,UAAU,IAGZ7L,QAAQ8I,OAAOuC,MAAMJ,GACrBQ,EAAGK,SAAS,IAAI,SAAAC,GACdN,EAAGO,QACHhM,QAAQ8I,OAAOuC,MAAM,MACrBH,EAAGa,eAWeE,0EAAf,WACLC,EACAxI,6EAEIwI,EAAyB5L,MAAM,OAAOpJ,OAAS,4CAE1CgV,0BAGoB,IAAIlU,SAAQ,SAAC1C,EAASC,GAC1CyK,QAAQ4L,MAAM5C,OAAUtF,EAK3BsH,GAAQ,oBAAoB,SAAAmB,GAC1B7W,EAAQ6W,MAJV5W,EAAO,IAAIjC,MAAM,wEAHf8Y,kBAWO5I,GAAoBmB,OAAOC,KAAKsH,EAA0B,UAAWE,uHAuChEC,0EAAf,WACL/G,EACAgH,sEAEIA,EAAgB/E,MAAMvN,4CACjBsS,0BAGgBhH,EAAQuE,YAAYyC,gDACrBvI,oFAQJwI,4EAAf,WACLjH,EACAkH,EACAC,0EAEI3F,EAAQ,yBAEY4F,GAAgBpH,EAASkH,EAAU1F,cAAnD6F,UACMF,YAAcA,2CACjBE,EAAQzD,mBAEjBpC,+FAekB8F,8EAAf,WACLtH,EACAgH,EACAO,EACAC,4FAEuBb,GAAgBa,iBAAjCN,kBACkBH,GAAa/G,EAASgH,iBAAxCG,kBACmBM,GAAsBzH,EAASkH,EAAUC,EAAWI,iBACvEG,EAAgBC,GAAc3H,oBACNiH,GAAyBjH,EAASkH,EAAUC,oCAC9D,CACVO,cAAAA,EACAE,uBACAV,SAAAA,gFAYYW,GAAuBC,WAC/BC,EAAU,GACPlW,EAAI,EAAGA,EAAIiW,EAAalW,OAAQC,IACvCkW,EAAQ1W,KAAK2W,GAAYF,EAAajW,YAEjCkW,WAQOC,GAAYja,OACpBqE,EAAOrE,EAAIqE,KACXvD,EAAOd,EAAIc,KACXoZ,EAAaC,gBAAcrZ,MAC7BsZ,wBAAsBtZ,GAAO,IAClB,YAATA,QACK,CACLA,KAAM,QACNuD,KAAAA,EACAqS,8CAA+CrS,eAAiB6V,GAE7D,GAAa,WAATpZ,QACF,CACLA,KAAM,QACNuD,KAAAA,EACAqS,8CAA+CrS,eAAiB6V,GAE7D,GAAa,SAATpZ,QACF,CACLA,KAAM,OACNuD,KAAAA,EACAqS,8CAA+CrS,eAAiB6V,EAChEG,QAAS,CAAC,OAAQ,UAEf,GAAa,cAATvZ,QACF,CACLA,KAAM,QACNuD,KAAAA,EACAqS,8CAA+CrS,eAAiB6V,SAG5D,IAAIja,kEAAkEia,GAEzE,GAAII,qBAAmBxZ,SACrB,CACLA,KAAM,QACNuD,KAAAA,EACAqS,8CAA+CrS,eAAiB6V,GAE7D,MAAIK,uBAAqBzZ,IAErB0Z,uBAAqB1Z,IAErB2Z,oBAAkB3Z,IAElB4Z,mBAAiB5Z,GALpB,IAAIb,kEAAkEia,YAYhES,GACdC,EACAb,WAEMc,EAA+B,GAC5B/W,EAAI,EAAGA,EAAIiW,EAAalW,OAAQC,IAAK,KACtCgX,EAAcf,EAAajW,GAEjC+W,EAAavX,KAAKyX,GADHH,EAAQE,EAAYzW,MACYyW,WAE1CD,WAGOE,GAAqBC,EAAahb,OAC1Cc,EAAOd,EAAIc,KACXoZ,EAAaC,gBAAcrZ,MAC7BsZ,wBAAsBtZ,GAAO,IAClB,YAATA,SACKma,SAAOD,GACT,GAAa,WAATla,SACFoa,QAAMF,GACR,GAAa,SAATla,QACQ,QAAVka,EAAmBG,WAAWC,YAChC,GAAa,cAATta,SAEFua,sBAAoBL,SAErB,IAAI/a,kEAAkEia,GAEzE,GAAII,qBAAmBxZ,UACrBwa,qBAAmBN,GACrB,MAAIT,uBAAqBzZ,IAErB0Z,uBAAqB1Z,IAErB2Z,oBAAkB3Z,IAElB4Z,mBAAiB5Z,GALpB,IAAIb,kEAAkEia,YAYhEqB,GAA0B7H,EAAczB,UAClDA,EAAQuJ,UAAYC,qBAAmBC,kDACQhI,4CAEAA,ECz3BrD,IAAMiI,GAAWnL,QAAQ,qBAkDVoL,wEAAf,WAAkCzC,kFACb0C,iBAAqB1C,mCACjC,IAAI7I,mBAA4BwL,uFAGzC,SAASC,GAAkBC,UAClB1L,oBAA6B2L,SAAeC,eAAeF,EAAKnG,sBAenDwD,8EAAf,WACLpH,EACAkH,EACA1F,EACA+H,4FAAAA,IAAAA,EAAkB,0BAEGI,GAAmBzC,iBAClCgD,SAAkBC,uBAAuB3I,GACzCY,EAAOpC,EAAQgE,cAAc3F,mBAA4B+L,wBAAwBF,IACjFhG,EAAU4F,GAAkBI,qBAC3B,CACLtG,WAAYM,EACZqF,QAASA,EACT/H,MAAOA,EACP2F,gBAAiB/E,+EAaCiI,0EAAf,WACLrK,EACAkH,4FAEqByC,GAAmBzC,iBAClChD,SAAiBoG,qBAAqB,GACtClI,EAAO0B,GAAqB9D,EAASkE,GACrC/T,EAA6B,CACjCyT,WAAYM,EACZzF,QAAS,CACP8L,IAAKnI,EACLoI,OAAQd,GAASe,SAASrI,IAE5BZ,MAAO,qBAEFrR,8EAYaua,0EAAf,WACL1K,EACAkH,wGAEmB0C,iBAAqB1C,iBAClCyD,EAASd,mBACTe,EAAQD,EAAOE,WAAW,sBAC1BnK,EAASsJ,SAAeC,eAAeW,EAAMhH,YAC7CM,EAAU7F,oBAA6BqC,GAEvC0B,EAAO0B,GAAqB9D,EAASkE,GAEvClE,EAAQ8K,eAEUd,WAAiBe,MAAM,CACzC7H,OAAQxC,EAAOmD,UACf7D,QAASgK,WAAiBgB,UAE5BC,IAJQxM,YAMYuL,WAAiBe,MAAM,CACzC7H,OAAQxC,EAAOmD,UACf7D,QAASgK,WAAiBA,UAE5BiB,IAJQxM,SAMJtO,EAA4B,CAChCyT,WAAYM,EACZzF,QAASiL,GAASe,SAASrI,GAC3B6I,WAAAA,EACAzJ,MAAO,qBAEFrR,+EAQa+a,8EAAf,WACLlL,EACAkH,EACAC,EACAgE,iFAEKA,IACHA,EAAWC,MAGqB,QAA9BjE,EAAU5L,UAAU,EAAG,yBACnB,IAAIvN,MAAM,kDAGG2b,GAAmBzC,UAAlCmE,SACGxZ,EAAI,cAAGA,EAAIsZ,uBACZjB,EAAWmB,EAAOlB,uBAAuBtY,GACzCuQ,EAAO/D,mBAA4B+L,wBAAwBF,GAE7DlK,EAAQgE,cAAc5B,KAAUpC,EAAQgE,cAAcmD,EAAU/T,MAAM,8CACjEvB,WALmBA,qDAStB,+EAkBY4V,gFAAf,WACLzH,EACAkH,EACAC,EACAmE,EACAC,mFAEKA,IACHA,GAAW,KAGTA,EAAU,mCACIL,GAAkBlL,EAASkH,EAAUC,gBAArDoE,UACc,yBACN,IAAIvd,MAAM,4EAIC2b,GAAmBzC,iBAClCsE,GADAH,UACkClB,uBAAuBoB,GACzDE,EAAWpN,mBAA4BqN,YAAYF,GAInDG,EAAsBtN,mBAA4BuN,uBACtDH,EAASI,WACTR,EAAOS,kBACPR,GAIItP,EAAsB,CAC1BqL,QAAS,CACPzD,WAAY,OACZnF,QAAS,QAEXsN,cAAe,CACbnI,WAAY+H,EACZlN,QAASqF,GAAqB9D,EAAY2L,SAE5CK,cAAeT,qBAEVvP,+EAMO2L,GACd3H,EACAiM,EAIAC,MAEIA,EAAY,IAEZlM,EAAQmM,qBAAqBF,EAAW5E,QAAQ5I,WAChDuB,EAAQmM,qBAAqBD,UAEtBD,EAAW5E,QAAQzD,cAG1B5D,EAAQmM,qBAAqBF,EAAWF,cAActN,WACtDuB,EAAQmM,qBAAqBD,UAEtBD,EAAWF,cAAcnI,iBAKA,SAAlCqI,EAAW5E,QAAQzD,YAA0BqI,EAAW5E,QAAQzD,WAE5DqI,EAAW5E,QAAQzD,WADnBqI,EAAWF,cAAcnI,WC7RjC,IAAMwI,GAAK7N,QAAQ,SA6CN8N,yBAYCrM,EAA4BvC,GActCA,EAAO5R,OAAOoK,OAAO,GAbiB,CACpCqW,cAAe,KACfC,QAAS,KACTC,qBAAsB,KACtBC,WAAY,KACZC,WAAY,KACZC,kBAAmB,KACnBC,YAAa,KACbC,UAAWpP,EAAKqP,WAChBC,6BAA8B/M,EAAQtK,oBACtCoX,WAAYrP,EAAKqP,YAGmBrP,QAEjCuP,cAAgB,IAAIC,oBACvBxP,EAAKqP,WACLrP,EAAKsP,6BACL/M,EAAQkN,IACRlN,EAAQC,aAELqM,cAAgB7O,EAAK6O,mBACrBC,QAAU9O,EAAK8O,aACfC,qBAAuB/O,EAAK+O,0BAC5BC,WAAahP,EAAKgP,gBAClBC,WAAajP,EAAKiP,gBAClBC,kBAAoBlP,EAAKkP,uBACzBC,YAAcnP,EAAKmP,iBACnBE,WAAarP,EAAKqP,gBAElBK,wBAAyB,6BAGhCC,UAAA,kBACShe,KAAK4d,cAAc/M,OAAOoN,aAAerD,WAAiBA,QAAQqD,cAG3EvC,UAAA,kBACS1b,KAAK4d,cAAc/M,OAAOoN,aAAerD,WAAiBsD,QAAQD,cAG3EE,wBAAA,SAAwB3gB,QACjBugB,uBAAyBvgB,KAGhCuf,qBAAA,SAAqB1N,OACb+O,EAAcxD,UAAgByD,gBAAgBhP,GAE9CiP,EAAiBF,EAAYjE,QAC/BoE,EAAa,SAEbD,IAAmBte,KAAK4d,cAAc/M,OAAOoN,WAC/CM,EAAa,EACJD,IAAmBte,KAAK4d,cAAc/M,OAAOC,aACtDyN,EAAa,GAER3D,UAAgBlK,cATH0N,EAAYlM,KASkBqM,MAGpDC,WAAA,kBACMxe,KAAKmd,QAEA7Z,QAAQ1C,QAAQZ,KAAKmd,SAE1Bnd,KAAK0b,YAEApY,QAAQ1C,QAAQ6d,KAAKC,MAAM,KArHf,MAuHd1e,KAAK4d,cAAcY,gBAG5BG,iBAAA,6BAEM3e,KAAKkd,cACA,IAAI5Z,SAAQ,SAAC1C,UAAiBA,EAAQ4O,EAAK0N,kBAE7Cld,KAAK4d,cAAce,mBAAmB1d,MAAK,SAAC2d,UAAcA,QAGnEC,eAAA,6BACM7e,KAAKwd,YACA,IAAIla,SAAQ,SAAC1C,UAAiBA,EAAQ0P,EAAKkN,gBAE7Cxd,KAAK4d,cAAciB,iBAAiB5d,MAAK,SAAC6d,UAAcA,QAGjEC,aAAA,SAAa/b,qBAEPhD,KAAKsd,YAActd,KAAKqd,WACnB,IAAI/Z,SAAQ,SAAC1C,UAClBA,EAAQ,CACNoe,MAAOC,OAAOhO,EAAKqM,YACnB4B,OAAQ,IAAIlC,GAAG/L,EAAKoM,iBAKnBrd,KAAK4d,cAAcmB,aAAa/b,GAAM/B,MAAK,SAACke,UAE5CA,EAAUH,QACbG,EAAY,CACVH,MAAO,MACPE,OAAQ,IAAIlC,GAAGiC,OAAOE,MAGnBA,QAIXC,kBAAA,SAAkBC,qBAEZrf,KAAKsd,YAActd,KAAKqd,WACnB,IAAI/Z,SAAQ,SAAC1C,UAClBA,EAAQ,CACNoe,MAAOC,OAAO7N,EAAKkM,YACnB4B,OAAQ,IAAIlC,GAAGiC,OAAO7N,EAAKiM,kBAK1B5gB,iBAAM2iB,4BAAkBC,GAAape,MAAK,SAACke,UAE3CA,EAAUH,QACbG,EAAY,CACVH,MAAO,MACPE,OAAQ,IAAIlC,GAAGiC,OAAOE,MAGnBA,QAIXG,wBAAA,SACEC,EACAC,EACAjC,8BADAiC,IAAAA,GAAkB,YAClBjC,IAAAA,GAA6B,GAGzBvd,KAAKod,sBAAwBoC,EACxB,IAAIlc,SAAQ,SAAC1C,UAAiBA,EAAQ8Q,EAAK0L,yBAG7C9Z,QAAQsS,IAAI,CACjB6J,UAASzf,KAAK4d,cAAcxX,mCAAkCmZ,GAC9Dvf,KAAK4d,cAAc8B,mBAElBze,MAAK,gBAAE0e,OAAMC,UACQ,MAAhBD,EAAKE,aACD,IAAIjhB,4BAA4B2gB,OACjC,GAAoB,MAAhBI,EAAKE,aACR,IAAIjhB,8BAA8B+gB,EAAKE,eAEtCvc,QAAQsS,IAAI,CAAC+J,EAAKzZ,OAAQ0Z,OAGpC3e,MAAK,gBAAE6e,OACFzQ,EAAU,qCACgB,IAA1ByQ,EAAc3F,UAEZoD,EAAoB,IACtBA,EAAoB7L,EAAK6L,mBAGvBuC,EAAcC,aAAexC,SAC/BlO,EAAUyQ,EAAczQ,UAGrBA,KAERpO,MAAK,SAACoO,UAAoBqC,EAAKkM,cAAchJ,cAAcvF,SAGhE8F,YAAA,SAAYnS,qBAEHhD,KAAK4d,cAAczI,YAAYnS,GAAM/B,MAAK,SAAC+e,SACjB,CAC7B3Q,QAASsC,EAAKoM,uBAAyBpM,EAAKoL,qBAAqBiD,EAAG3Q,SAAW2Q,EAAG3Q,QAClF4Q,WAAYD,EAAGC,WACfC,IAAKF,EAAGE,IACRnK,aAAciK,EAAGjK,aACjBD,aAAckK,EAAGlK,aACjBqK,UAAWH,EAAGG,UACdnK,iBAAkBgK,EAAGhK,iBACrBoK,SAAUJ,EAAGI,SACbP,OAAQG,EAAGH,OACXlK,SAAUqK,EAAGrK,SACb0K,cAAeL,EAAGK,qBAMxBC,wBAAA,SAAwBtd,qBAGfyc,UADQzf,KAAK4d,cAAcxX,kDAAiDpD,GAEhF/B,MAAK,SAAA0e,MACgB,MAAhBA,EAAKE,aACD,IAAIjhB,8BAA8B+gB,EAAKE,eAEtCF,EAAKzZ,UAGfjF,MAAK,SAAAmU,WAEEmL,EAAsC,SACrB,CAAC,UAAW,mBAAoB,oCAAsB,KAAlEC,OACLpL,EAASxY,eAAe4jB,IAAapL,EAASoL,KAChDD,EAAeC,GAAYhO,EAAKoL,cAAchJ,cAAcQ,EAASoL,YAGlE/jB,OAAOoK,OAAOuO,EAAUmL,SAIrCE,eAAA,SAAezd,EAAc0d,qBAGpBjB,UADQzf,KAAK4d,cAAcxX,8BAA6BpD,mBAAqB0d,GAEjFzf,MAAK,SAAA0e,MACgB,MAAhBA,EAAKE,aACD,IAAIjhB,8BAA8B+gB,EAAKE,eAExCF,EAAKzZ,UAEbjF,MAAK,SAAA0f,WAEEC,EAAsC,SACjBnkB,OAAOgH,KAAKkd,kBAAc,WAA1CE,OACHC,EAA0B,OACLH,EAAYE,mBAAe,SAEhDE,EAFKC,UACHT,EAAyC,SAExB,CAAC,UAAW,mBAAoB,oCAAsB,KAAlEC,OACLQ,EAAapkB,eAAe4jB,IAAaQ,EAAaR,KACxDD,EAAeC,GAAYS,EAAKrD,cAAchJ,cAAcoM,EAAaR,KAG7EO,EAAoBtkB,OAAOoK,OAAOma,EAAcT,GAChDO,EAAiB7e,KAAK8e,GAExBH,EAAaC,GAAgBC,SAExBF,QAIbhM,cAAA,SAAcvF,UACLrP,KAAK4d,cAAchJ,cAAcvF,MAG1C6R,sBAAA,SAAsB7R,EAAiBqR,UAC9B1gB,KAAK4d,cAAcsD,sBAAsB7R,EAASqR,MAG3DS,qBAAA,SAAqBC,UACZphB,KAAK4d,cAAcuD,qBAAqBC,MAGjDC,kBAAA,SAAkB1L,EAAkBtD,UAC3BrS,KAAK4d,cAAcyD,kBAAkB1L,EAAUtD,MAGxDiP,cAAA,SAAcjS,UACLrP,KAAK4d,cAAc0D,cAAcjS,SC/TtCH,GAAWC,QAAQ,sBAyDToS,GAAqBjJ,EAAuBkJ,OACpDC,EAAejO,GAA8BqB,GAAoByD,SAEjEoJ,EAAOC,cAAmB,IAAIne,SAAS,OAEvCoe,EAAwB,CAC5BC,iBAAkBJ,EAClBK,IAHwBtO,GAA2BgO,GAInDO,IANyB,UAMC,IAAIC,MAAOC,UAAY,IACjDP,KAAAA,UAEuB,IAAIQ,cAAuB,SAAUV,GAAajQ,KACzEqQ,YAUYO,GACdvR,EACA0H,EACA8J,EACA5J,OAGK5H,EAAQoN,kBACL,IAAIpf,MAAM,8CAGdyjB,EACA7J,GAAmBF,IACrB+J,EAAmBd,GAAqBjJ,EAAeE,QAGnD8J,EA1ER,SACEhK,EACAiK,EACAF,UASAG,OAAOC,aAAaC,QAAQ,iCANF,oEAQLzT,mBATG,mEAWtB,CAAExP,KAAM,UAAWkjB,SAAU,IAE7B,KACA,GACA,KACArK,OACAzZ,EAdA,qIAgBA0jB,EACAtT,SAAkB2B,QAAQxK,iBAC1Bic,GAgDuBO,CAA0BtK,EAAe8J,EAAQC,UAInEpT,sBAHkB2B,EAAQgN,cAAcxX,8BAGMkc,EAF3B,6EAWZO,GACdjS,EACAkS,EACAtO,EACAgE,OASI6J,EAPEU,EAAiBnS,EAAQmM,qBAC7BrI,GAAqB9D,EAAYiE,GAAoBL,UAEjDwO,EAA0BpS,EAAQmM,qBACtCrI,GAAqB9D,EAASiE,GAAoBL,YAIhDgE,IACF6J,EAAmBd,GAAqB/M,EAAYgE,IAG/CyK,mBAAiBH,EAAYjO,GAAoBL,GAAa6N,GAAkBphB,MACrF,SAAAiiB,MAEMtS,EAAQmM,qBAAqBmG,EAAU7T,WAAa0T,EACtDG,EAAU7T,QAAU0T,MACf,CAAA,GAAInS,EAAQmM,qBAAqBmG,EAAU7T,WAAa2T,QAGvD,IAAIpkB,MACR,wBACKgS,EAAQmM,qBAAqBmG,EAAU7T,wBACvC0T,SAAqBC,GAL5BE,EAAU7T,QAAU2T,SAQfE,cAyGGC,GACdvS,EACAwS,EACAC,EACA7O,EACA8O,OAgBMC,EAdoBH,EACvBrW,KAAI,SAAAyW,OACGC,EAAUC,QAAUF,UACrBC,EAAQE,UAGRF,EAAQG,KAIH3E,OAAOwE,EAAQE,eAAc1E,OAAOwE,EAAQG,MAN7C,MAQV3X,QAAO,SAAAuX,UAAWA,EAAQhhB,OAAS,KAEGuK,KAAI,SAAAyW,mBAlD7C5S,EACAiT,EACAR,EACA7O,EACA8O,OAEIJ,SACGL,GAAYjS,EAASiT,EAAYrP,GACrCvT,MAAK,SAAC6iB,UAvEX,SACElT,EACAsS,EACAI,UAEKA,GAAD,MAAiBA,EAGZ1S,EAAQuE,YAAYmO,GAAcriB,MAAK,SAACmU,OACzCa,UAEIC,EAAehH,GAASiH,cAAcf,EAASO,UACjDO,EAAaE,KAAOF,EAAatZ,eAAe,aAClDqZ,EAAahH,kBAA2BiH,IAE1C,MAAOnF,SACD,IAAInS,6CAC+BqgB,OAAOqE,qCAI9CrN,MAAAA,QACI,IAAIrX,6CAC+BqgB,OAAOqE,gCAM5CS,KAAoBb,EAAUc,WAAad,EAAU7T,QACrD4U,EAAkBhF,OAAOyE,QAAUK,GAAgBG,MACnDC,EAAiBlF,OAAOyE,QAAUzN,GAAYiO,UAE/CC,EAAepR,WAAWkR,SACvB,IAAIrlB,MACR,uCAAuCqgB,OAAOqE,GAA9C,qBACOS,6BAAyC9N,cAIhCkO,EAAehY,UAAU8X,EAAgBzhB,OAAS,MAlCjEc,QAAQ1C,UAAUK,MAAK,iBAAM,kBAuE3BmjB,CAAoBxT,EAD3BsS,EAAYY,EACmCR,MAEhDriB,MAAK,SAACojB,UACEpV,kBAA2BoV,EAAahB,EAAUH,MAkC3DoB,CAAkB1T,EAAS4S,EAASH,EAAU7O,EAAY8O,aAGrDhgB,QAAQsS,IAAI2N,GAChBtiB,MAAK,SAAAsjB,SACG,CAAEpjB,MAAO,KAAMqjB,SAAUD,aAE3B,SAAAxT,SACE,CAAE5P,2BAA4B4P,EAAEsE,QAAWmP,SAAU,kBA8DlDC,GACd7T,EACAyF,EACA8B,OAEK9B,QACG,IAAIzX,MAAM,kBAEbyX,EAAQqO,WACL,IAAI9lB,MAAM,uBAEbyX,EAAQqO,KAAKvM,SACV,IAAIvZ,0BAA0BuZ,OAKlCwM,EADEC,EAASvO,EAAQqO,KAAKvM,OAI1BwM,EAAqB/T,EAAQmM,8BAjCK6H,OAC9BzR,EAAUyR,EAAO/R,MAAM,yCACxBM,QACG,IAAIvU,MAAM,uCAEXuU,EAAQA,EAAQ3Q,OAAS,GA4BoBqiB,CAAsBD,IACxE,MAAO7T,SACD,IAAInS,iCAAiCgmB,UAGtCD,EC1VF,IAqCMG,yuBACAC,GAAc,gDACdC,GAAgB,gDAChBC,GAAkB,mEAClBC,GAAgB,8DA4BvBC,GAAmBxD,cAAmB,IAAIne,SAAS,gBAK1C4hB,8EAAf,WACExU,EACAkH,EACAuN,EACAlN,4FAEyBE,GACvBzH,EACAkH,EACAuN,EAAGtN,UACHI,EACAkN,EAAGjT,cALCyK,aASE8H,EAAqBF,GAA0B7T,EAASyU,EAAGhP,QAAS8B,GAC1EG,EAAgBC,GAAc3H,EAASiM,EAAY8H,GACnD,MAAO5T,GACPuH,EAAgBC,GAAc3H,EAASiM,4BAGlCvE,8EAMMgN,kFAAf,WACE1U,EACA2U,EACAzN,EACA0N,EACApD,EACAiD,6FAEMlN,EAAYqN,EAAYC,qBACFL,GAAiBxU,EAASkH,EAAUuN,EAAIlN,iBAE9DkK,EAAmBd,GAFnBjJ,SAEuD+M,EAAG7Q,YAC1DkR,EAAkBzW,mBACtBoW,EAAG7Q,WACH,GACA6Q,EAAGriB,KACH,CAAE2iB,WAAO9mB,EAAWoX,WAAYoP,EAAGpP,iBACnCpX,EACAyZ,OACAzZ,EACA2mB,EAAYI,YAAY,GACxBxD,EACAnT,SAAkB2B,QAAQxK,iBAC1Bic,GAIIwD,EAAsB3D,cAAuBwD,GAAiBI,SAC9DC,EAAYtpB,OAAOoK,OAAO,GAAIwe,IAC1BhP,QAAU,GAEpB0P,EAAUvR,gBAAa3V,EAEtBgnB,EAA4BG,SAAW,CACtCX,GAAIU,EACJ9P,WAAYoP,EAAGpP,WACfkC,UAAWA,EACX8N,aAAcT,EAAYS,aAC1BC,OAAQV,EAAYU,OACpBxE,KAAMC,cAAmB,IAAIne,SAAS,OACtC2iB,MAAOhB,IAIHiB,EAAc,IAAIlE,cAAuB,SAAUmD,EAAG7Q,YACtD6R,EAAeD,EAAY7U,KAAKsU,qBAE/B5W,iDACesW,YACpB,eACAc,gFAOWC,oFAAf,WACE1V,EACA2U,EACAzN,EACAsK,EACAmE,EACAf,EACAgB,gFAEIC,EAAa3B,GACX4B,EAAoB3B,GAAY7X,QAAQ,YAAaqZ,EAASvjB,MAAQ,iBAEtE2jB,EAAe3B,GAAc9X,QACjC,cACAsY,EAAYU,OAAO1jB,OAAS,EAAIgjB,EAAYU,OAAOpZ,KAAK,MAAQ,UAGlE2Z,KAAgBA,EAAaC,EAAoBC,EAExClkB,EAAI,cAAGA,EAAI+jB,EAAIhkB,4BAClBokB,UACAJ,EAAI/jB,GAAGO,kCACKiiB,aAENK,GAAe1U,EAAS2U,EAAUzN,EAAU0N,EAAapD,EAAQoE,EAAI/jB,wBAF7EmkB,OAA8B1Z,kBAC5B,uBAGCA,QAAQ,iBAAkBsZ,EAAI/jB,GAAGO,MACjCkK,QAAQ,cAAesZ,EAAI/jB,GAAGsV,+CAEnBmN,aAENI,GAAe1U,EAAS2U,EAAUzN,EAAU0N,EAAapD,EAAQoE,EAAI/jB,wBAF7EmkB,OAA4B1Z,kBAC1B,uBAEAA,QAAQ,cAAesZ,EAAI/jB,GAAGsV,mBAGlC0O,KAAgBA,EAAaG,UAhBCnkB,oDAmBhCgkB,GA1J2B,8FAkKdI,8EAAf,WACEjW,EACAkH,EACA1F,EACA0U,iFAGI1U,EAAQ,6BACJ,IAAIxT,MAAM,yCAGIoZ,GAAgBpH,EAASkH,EAAU1F,iBAAnD6F,kBACiBrH,EAAQ0Q,cAAcrJ,EAAQF,UAAU/T,MAAM,cAC7C,KADlB+iB,UACOvkB,iDAEJskB,eAEArkB,EAAI,EAAGA,EAAIskB,EAASvkB,OAAQC,IASnCqkB,EAAW7kB,KARyB,CAClCe,KAAM+jB,EAAStkB,GACfsV,UAAWE,EAAQF,UACnBvD,WAAYyD,EAAQzD,WACpBpC,MAAOA,EACPiE,QAAS,GACTJ,WAAY,sBAIH4Q,GAAwBjW,EAASkH,EAAU1F,EAAQ,EAAG0U,wHAOrDE,GACdpW,EACAkH,UAEO+O,GAAwBjW,EAASkH,EAAU,EAAG,aAMxCmP,4EAAf,WACErW,EACAkH,EACA1F,wFAEsB4F,GAAgBpH,EAASkH,EAAU1F,mCAC1C,CACbpP,KAAM,GACN+U,WAHIE,UAGeF,UACnBvD,WAAYyD,EAAQzD,WACpBpC,MAAOA,EACPiE,QAAS,GACTJ,WAAY,uEAQhB,SAASiR,GAASta,EAAuBua,EAAcC,GACrDpW,kBAAuBoW,OAAe7S,KAAKvO,UAAUmhB,IACrDva,EAAIya,UAAUD,EAAY,gBAAkB,qBAC5Cxa,EAAI+J,MAAMpC,KAAKvO,UAAUmhB,IACzBva,EAAI0a,eASSC,8EAAf,WACE3W,EACAkH,EACA0P,EACAC,uFAEA7W,EAAQuN,yBAAwB,qBAKX6I,GAAoBpW,EAASkH,iBAC1C4P,GADNZ,UACoC/Z,KAAI,SAAAsY,UAK1B/P,GAAW1E,EAASyU,EAAGriB,MAAM,UAAY,kBAAM,oBAIvCM,QAAQsS,IAAI8R,cAA9BC,SAEJ/W,EAAQuN,yBAAwB,GAChCwJ,EAAYA,EAAU1b,QAAO,SAAAwL,UAAKA,MAAAA,KAEzBhV,EAAI,EAAGA,EAAIklB,EAAUnlB,OAAQC,IAChCklB,EAAUllB,GAAI7F,eAAe,UAAa+qB,EAAUllB,GAAWtB,MAEjE2lB,EAAWrkB,GAAGwT,WAAa,IAE3B6Q,EAAWrkB,GAAGwT,WAAa0R,EAAUllB,GAAIwT,WACzC6Q,EAAWrkB,GAAG4T,QAAUsR,EAAUllB,GAAI4T,gBAIpCuR,EAAYd,EAAWtkB,OAAS,EAGtCskB,EAAaA,EAAW7a,QAAO,SAAAoZ,WAAQA,EAAGpP,mBAG1C6Q,YAAsBG,GAAoBrW,EAASkH,EAAU8P,4BAAlD3lB,6EAEX2O,EAAQuN,yBAAwB,yCAI3B2I,sHAaF,WACLlW,EACAkH,EACAgL,EACA+E,EACAC,EACAC,EACAnb,uFAEMob,EAAYD,EAAIE,MAAMzC,qDAEnBliB,QAAQ1C,UAAUK,MAAK,WAC5BimB,GAASta,EAAK,CAAEzL,MAAO,wBAA0B,uBAIjD+mB,EAAW,GACXpB,EAAkC,qBAGjBS,GAAgB3W,EAASkH,EAAUgL,EAAY+E,iBAAlEf,SAEAoB,EAAW,kDACSjZ,oBAA6B+Y,4CAG/CE,EAAW,iDACL,IAAItpB,MAAMspB,kBAElBA,EAAW,yCACejZ,mBAA4B+Y,cAAhDG,SAEND,EAAW,yBACLE,EAAmBlG,cAAuB8F,GAC1CK,EAAqBD,EAAiBtC,+BAE1CoC,EAAW,2CACL,IAAItpB,MAAMspB,kBAGlBA,EAAW,qCAGY5B,GACrB1V,EACAkX,EACAhQ,EACAgL,EACAqF,EACAE,EACAvB,WAGFla,EAAIya,UAAU,IAAK,gBAAkB,8BAV/BiB,UAUuE9lB,SAC7EoK,EAAI+J,MAAM2R,GACV1b,EAAI0a,wDAECY,IACHA,EAAWK,KAAElT,SAGfxH,QAAQC,IAAIya,KAAE7d,OACdsG,QAAakX,GACbhB,GAASta,EAAK,CAAEzL,6CAA8C+mB,GAAc,sFAQhF,SAASM,GACP5X,EACAyU,EACAlN,EACAsQ,EACApS,OAEIqS,GAAoB,SAGDplB,QAAQ1C,UAAUK,MAAK,kBACxCoV,MAAAA,EACKf,GAAW1E,EAASyU,EAAGriB,aAAY,SAAA2lB,UAAM,QAEzC,CAAEtS,QAASA,MAIApV,MAAK,SAAA+T,GACrBA,IACFqB,EAAUrB,EAAYqB,SAGnBA,IAEHrF,uBAA4BqU,EAAGriB,YAAWuR,KAAKvO,UAAUqQ,IACzDrF,qCAA0CqU,EAAGriB,MAC7C0lB,GAAoB,EACpBrS,EAAU,CACR5W,KAAM,UACNmpB,QAAS,GACTlE,KAAM,KAKNrO,MAAAA,EAAQqO,OACVgE,GAAoB,EAEpB1X,yDAA8DqU,EAAGriB,MACjEqT,EAAQqO,KAAO,QAGXmE,KAAgBJ,EAAczE,WAAayE,EAAcpZ,mBAE1DgH,EAAQqO,KAAK9nB,eAAeub,IAAe9B,EAAQqO,KAAKvM,GAOjD9B,EAAQqO,KAAKvM,GAAWpF,WAAW8V,KAC7CH,GAAoB,EACpB1X,QACE,gCAAgCmH,WAAkB9B,EAAQqO,KAAKvM,GAA/D,OACQ0Q,qBAA6BxD,EAAGriB,MAG1CqT,EAAQqO,KAAKvM,GAAa0Q,IAb1BH,GAAoB,EACpB1X,QACE,yBAAyB6X,UAAkB1Q,EAA3C,mBAA4EkN,EAAGriB,MAGjFqT,EAAQqO,KAAKvM,GAAa0Q,GAWrB,CAAExS,QAAAA,EAASyS,QAASJ,MAQ/B,SAASK,GACPnY,EACAyU,EACAoD,EACApS,OAEIqS,GAAoB,SAGDplB,QAAQ1C,UAAUK,MAAK,kBACxCoV,MAAAA,EACKf,GAAW1E,EAASyU,EAAGriB,aAAY,SAAA2lB,UAAM,QAEzC,CAAEtS,QAASA,MAIApV,MAAK,SAAA+T,UACrBA,IACFqB,EAAUrB,EAAYqB,SAGnBA,IAEHrF,uBAA4BqU,EAAGriB,YAAWuR,KAAKvO,UAAUqQ,IACzDrF,qCAA0CqU,EAAGriB,MAC7C0lB,GAAoB,EACpBrS,EAAU,CACR5W,KAAM,UACNmpB,QAAS,GACTI,IAAK,KAKL3S,MAAAA,EAAQ2S,MACVN,GAAoB,EAEpB1X,8CAAmDqU,EAAGriB,MACtDqT,EAAQ2S,IAAM,CACZC,cAAe,CACbjF,WAAYyE,EAAczE,YAE5BlB,WAAY2F,EAAcS,SAK3B7S,EAAQzZ,eAAe,QACvByZ,EAAQ2S,IAAIpsB,eAAe,kBAC3ByZ,EAAQ2S,IAAIC,cAAcrsB,eAAe,eACzCyZ,EAAQ2S,IAAIC,cAAcjF,YAC1B3N,EAAQ2S,IAAIpsB,eAAe,eAC3ByZ,EAAQ2S,IAAIlG,aAEb9R,gCAAqCqU,EAAGriB,YAAWuR,KAAKvO,UAAUqQ,IAClErF,gDAAqDqU,EAAGriB,MACxDqT,EAAQ2S,IAAM,CACZC,cAAe,CACbjF,WAAYyE,EAAczE,YAE5BlB,WAAY2F,EAAcS,SAIvB,CAAE7S,QAAAA,EAASyS,QAASJ,wCAiBxB,WACL9X,EACAkH,EACAqR,EACAtB,EACAE,EACAnb,uHAEMwc,EAAiBrB,EAAIE,MAAM5B,sDAExB/iB,QAAQ1C,UAAUK,MAAK,WAC5BimB,GAASta,EAAK,CAAEzL,MAAO,yBAA2B,uBAGhDkoB,EAAmBzY,EAAQgN,cAAcxX,8BAE3C8hB,EAAW,GACXoB,EAAkB,IAUlBC,GAAuB,qBAILta,qBAA8Bma,EAAgBC,4CAEhEnB,yCAAkDkB,EAC5C,IAAIxqB,MAAMspB,cAGZsB,EAAoBtH,cAAuBkH,GAGjD/D,GAFAQ,EAAsB2D,EAAkB1D,SAEfE,SAASX,GAClCpP,EAAa4P,EAAoBG,SAAS/P,WAC1CkC,EAAY0N,EAAoBG,SAAS7N,UACzCsR,EAAc5D,EAAoBG,SAASC,aAC3CC,EAASL,EAAoBG,SAASE,OACxBL,EAAoBG,SAASG,OAE9BhB,0BACL,IAAIvmB,MAAM,uFAIKoZ,GAAgBpH,EAASkH,EAAUuN,EAAGjT,sBAA7DiT,EAAG7Q,kBAAkEA,qBAEzC4Q,GAAiBxU,EAASkH,EAAUuN,EAAIlN,kBAA9DG,SAGNuN,EAAoBG,SAAW,CAC7B/P,WAAYA,GAGdoQ,EAAe,IAAInE,cAAuB,SAAUmD,EAAG7Q,YAAYjD,KAAKsU,GAExE7U,eAAoBmH,sBAA6B5D,KAAKvO,UAAUkgB,cAGrCrD,GAAYjS,EAASuY,EAAY7Q,kBAE5D4K,mBAC2B6F,GAAyBnY,EAASyU,EAAInC,kBAEjEqG,GAFIG,UAEkCZ,QACtCa,EAAmBD,EAAerT,kBACXmS,GAAkB5X,EAASyU,EAAIlN,EAAW+K,EAAWyG,cAEtEtT,GAFNqT,UAE+BrT,QACzBuT,EAA0BF,EAAeZ,SAAW5C,EAAO2D,SAAS,eAE1E7Y,iCAAsCqU,EAAGriB,YAAWuR,KAAKvO,UAAUqQ,KAM/DuT,0BACF5Y,uDAA4D6W,GACtDiC,EAAa/U,GAAesB,EAASgP,EAAG7Q,sBAC7B2O,GACfvS,EACA,CAACiX,GACDiC,EACAzE,EAAG7Q,WACH6Q,EAAGriB,cALLogB,qCAOSmG,0BAETvY,uDAA4D6W,GACtDiC,EAAa/U,GAAe4U,EAAkBtE,EAAG7Q,sBACtC2O,GACfvS,EACA,CAACiX,GACDiC,EACAzE,EAAG7Q,WACH6Q,EAAGriB,cALLogB,iCAQApS,6BAAkCmH,SAAgB9B,EAAQqO,KAAKvM,IAC/DiL,EAAW,CAAEoB,SAAU,GAAIrjB,MAAO,kBAGhCiiB,EAASxmB,eAAe,WAAYwmB,EAASjiB,6BAC/C+mB,mCAA4C9E,EAASjiB,MACrDmoB,EAAkB,IACZ,IAAI1qB,MAAMspB,WAKlBlX,8BAAmCmH,YAAmBkN,EAAGriB,MACnD+mB,EAAS9a,6BAAsCwa,EAAa,eAAgBpD,GAElFrV,sBAA2B+Y,GAC3Bnd,EAAIya,UAAU,IAAK,CAAE2C,SAAUD,IAC/Bnd,EAAI0a,wDAEJtW,cACAA,QAAakX,GACbhB,GAASta,EAAK,CAAEzL,2CAA4C+mB,GAAcoB,oFChqB9E,IAAMhP,GAAWnL,QAAQ,YAsErB8a,IAAS,EACTC,IAAe,EACfC,IAAe,EACf5M,GAAoB,MACpBC,GAAc,IACd4M,IAAS,EACTC,GPPuC,IOSvCC,KAAoBhf,MAAYgf,yBAEpBtO,YACPqO,GAuCT,SAASE,GAAc3Z,EAA4B4Z,OAC3CnG,EAAcmG,EAAK,GACrBC,EAAqBD,EAAK,GAG1BC,EAAmB5X,MAAMvN,KAC3BmlB,EAAqB7Z,EAAQmM,qBAAqB0N,EAAmBzmB,MAAM,SAGvE0mB,EAAgBC,eAAgBtG,GAAa7gB,kBAE5CF,QAAQ1C,UAAUK,MAAK,eACxB2pB,EAAe,SAIjBA,EADsBrW,KAAKsW,MAAMH,GACJ,GAAGI,MAChC,MAAO/Z,GAEP6Z,EAAeF,MAGZE,QACG,IAAIhsB,iBAAiBylB,oDAItBlQ,GADSlF,iBAA0B2b,EAAcH,yCA+E5D,WAA0B7Z,EAA4B4Z,8FAC7BjT,GAAgBiT,EAAK,kBAAtC1S,SACAF,EAAkB4S,EAAK,GACvBO,EAASP,EAAK,YACI7S,GAAa/G,EAASgH,iBAAxCG,mBACoBM,GAAsBzH,EAASkH,EAAUC,EAAWgT,oCACvE5W,iHAST,WAA4BvD,EAA4B4Z,8FAC/BjT,GAAgBiT,EAAK,WAAtC1S,SACFiE,EAAW,EACXyO,EAAKhoB,OAAS,GAAOgoB,EAAK,KAC5BzO,EAAWvL,SAASga,EAAK,KAGrBvS,EAA8B,GAC3BxV,EAAI,cAAGA,EAAIsZ,gCAClB9D,YAAmBD,GAAgBpH,EAASkH,EAAUrV,4BAA9CR,6BADoBQ,oDAIvB0R,GAAc8D,yGAQvB,WAA6BrH,EAA4B4Z,0FAChCjT,GAAgBiT,EAAK,kBAAtC1S,kBAEemD,GAAkBrK,EAASkH,iBAC1CG,EAAgC,IAC9BhW,+BACDkS,GAAc8D,wGAQvB,WAAkCrH,EAA4B4Z,0FACrCjT,GAAgBiT,EAAK,kBAAtC1S,kBAEewD,GAAuB1K,EAASkH,iBAC/CG,EAA+B,IAC7BhW,+BACDkS,GAAc8D,wGAQvB,WAA4BrH,EAA4B4Z,4EAElDA,EAAK,mCACUjT,GAAgBiT,EAAK,WAAtC1S,+CAEiB0C,mBJ5T8B,II8T7CmH,sBAFF7J,iCAM0BwD,GAAuB1K,EAASkH,oCACrD3D,GAAc,CACnB2D,SAAUA,EACVG,uHA6LJ,WAA0BrH,EAA4B4Z,+FAC9CQ,EAAmBR,EAAK,GACxBS,EAAc,IAAIjO,UAAGwN,EAAK,IAC1BU,EAAM,IAAIlO,UAAGwN,EAAK,IAClBrE,EAAQ,IAAInJ,UAAGwN,EAAK,IACpBhW,EAAagW,EAAK,GAEpBW,EAAO,GAEPX,EAAKhoB,OAAS,GAAOgoB,EAAK,KAC5BW,EAAOX,EAAK,KAIRY,EAAYxa,EAAQoN,YAAc,IAAIqN,gBAAkB,IAAIC,iBACxDC,WAAa3a,EAAQgN,cAAcxX,iBAEvColB,EAAsC,CAC1CC,UAAWT,EACX9L,OAAQ+L,EACRS,UAAWlX,EACX0W,IAAAA,EACA/E,MAAAA,EACAgF,KAAAA,EACAva,QAASwa,aAGyBO,uBAAqBH,cAAnDpK,UAEF8I,6CACK0B,mBAAiBxK,EAAIgK,GAAWnqB,MAAK,SAAA4qB,UACnCA,EAAKroB,SAAS,oBAIrBymB,6CACK3mB,QAAQ1C,QAAQwgB,EAAG0K,YAAYtoB,SAAS,0CAG1C2d,uBAAqBC,EAAIgK,GAC7BnqB,MAAK,SAAC8qB,UACDA,EAASnvB,eAAe,SACnBmvB,EAEF,CACL1Z,UAAW+O,EAAG/O,OACd2Z,YAAa9R,GAA0BkH,EAAG/O,OAAQ+Y,cAG/C,SAAAjqB,UACEA,EAAMqC,oHAanB,WAA8BoN,EAA4B4Z,+FAClDyB,EAAazB,EAAK,GAClB0B,EAAe1B,EAAK,GACpBU,EAAM,IAAIlO,UAAGwN,EAAK,IAClBrE,EAAQ,IAAInJ,UAAGwN,EAAK,IACpBhW,EAAagW,EAAK,GAElB2B,EAASxB,eAAgBsB,GAAYzoB,YAGrC4nB,EAAYxa,EAAQoN,YAAc,IAAIqN,gBAAkB,IAAIC,iBACxDC,WAAa3a,EAAQgN,cAAcxX,iBAEvColB,EAAiC,CACrCU,aAAAA,EACAE,SAAUD,EACVT,UAAWlX,EACX0W,IAAAA,EACA/E,MAAAA,EACAvV,QAASwa,EACTiB,kBAAmBC,oBAAkBC,iBAGtBC,qBAAmBhB,cAA9BpK,UAEF8I,6CACKuC,yBAAuBrL,EAAIgK,GAAWnqB,MAAK,SAAA4qB,UACzCA,EAAKroB,SAAS,oBAIrBymB,6CACK3mB,QAAQ1C,QAAQwgB,EAAG0K,YAAYtoB,SAAS,0CAG1C2d,uBAAqBC,EAAIgK,GAC7BnqB,MAAK,SAAA8qB,UACAA,EAASnvB,eAAe,SACnBmvB,EAEF,CACL1Z,UAAW+O,EAAG/O,OACd2Z,YAAa9R,GAA0BkH,EAAG/O,OAAQ+Y,cAG/C,SAAAjqB,UACEA,EAAMqC,oHAcnB,WAAoCoN,EAA4B4Z,iGACxDkC,EAAkBlC,EAAK,GACvB0B,EAAe1B,EAAK,GACpBmC,EAAenC,EAAK,GACpBU,EAAM,IAAIlO,UAAGwN,EAAK,IAClBrE,EAAQ,IAAInJ,UAAGwN,EAAK,IACpBhW,EAAagW,EAAK,IAGlBY,EAAYxa,EAAQoN,YAAc,IAAIqN,gBAAkB,IAAIC,iBACxDC,WAAa3a,EAAQgN,cAAcxX,iBAIzCoT,EAA+B,qBAE5BoT,SAAOF,EAAiBR,EAAcd,GAC1CnqB,MAAK,SAAA4rB,OAEEC,GADNC,EAAMF,GACeG,UAAU/gB,QAAO,SAAAtM,UAAMA,EAAGqD,OAAS2pB,YAChC,IAApBG,EAAStqB,OAEJiW,GADPwU,EAAUH,EAAS,GAAGtC,MAGf,QAGVvpB,MAAK,SAAA0X,UAAWuU,SAAOvU,MACvB1X,MAAK,SAAAsY,UACJC,EAAeF,GAA+BC,EAAS0T,GAchDE,mBAZoC,CACzCT,gBAAAA,EACAR,aAAAA,EACAS,aAAAA,EACAnT,aAAAA,EACAkS,UAAWlX,EACX0W,IAAAA,EACA/E,MAAAA,EACAvV,QAASwa,EACTiB,kBAAmBC,oBAAkBC,WAKxCtrB,MAAK,SAAAmgB,OACCgM,uBAAqBhM,EAAG0E,QAAgCiH,SACrD,IAAInuB,MAAM,4DAGdsrB,GACKmD,+BAA6BjM,EAAIgK,GAAWnqB,MAAK,SAAA4qB,UAC/CA,EAAKroB,SAAS,OAIrBymB,GACK3mB,QAAQ1C,QAAQwgB,EAAG0K,YAAYtoB,SAAS,QAG1C2d,uBAAqBC,EAAIgK,GAC7BnqB,MAAK,SAAA8qB,UACAA,EAASnvB,eAAe,SACnBmvB,EAEF,CACL1Z,UAAW+O,EAAG/O,OACd2Z,YAAa9R,GAA0BkH,EAAG/O,OAAQ+Y,cAG/C,SAAAjqB,UACEA,EAAMqC,uHAavB,WACEoN,EACA4Z,2FAEMkC,EAAkBlC,EAAK,GACvB0B,EAAe1B,EAAK,GACpBmC,EAAenC,EAAK,GACpB8C,EAAgB9C,EAAK,IAGrBY,EAAYxa,EAAQoN,YAAc,IAAIqN,gBAAkB,IAAIC,iBACxDC,WAAa3a,EAAQgN,cAAcxX,iBAIzCoT,EAA+B,qBAE5BoT,SAAOF,EAAiBR,EAAcd,GAC1CnqB,MAAK,SAAA4rB,OAEEC,EADAD,EACeG,UAAU/gB,QAAO,SAAAtM,UAAMA,EAAGqD,OAAS2pB,YAChC,IAApBG,EAAStqB,OAEJiW,GADPwU,EAAUH,EAAS,GAAGtC,MAGf,QAGVvpB,MAAK,SAAA0X,UAAWuU,SAAOvU,MACvB1X,MAAK,SAAAsY,UACJC,EAAeF,GAA+BC,EAAS0T,GAWhDM,uBATkC,CACvCb,gBAAAA,EACAR,aAAAA,EACAS,aAAAA,EACAnT,aAAAA,EACA8T,cAAAA,EACA1c,QAASwa,OAKZnqB,MAAK,SAAAusB,UACGC,aAAWD,aAEb,SAAArsB,UACEA,EAAMqC,iFAuMnB,SAASkqB,GAAYzW,EAAY0W,YAAAA,IAAAA,EAAoB,YAC7Cha,EAAS,GACXia,EAAe,GACVnrB,EAAI,EAAGA,EAAIwU,EAAMzU,OAAQC,IAChCmrB,EAAa3rB,KAAKgV,EAAMxU,IACpBmrB,EAAaprB,QAAUmrB,IACzBha,EAAO1R,KAAK2rB,GACZA,EAAe,WAGfA,EAAaprB,OAAS,GACxBmR,EAAO1R,KAAK2rB,GAEPja,oCA+KT,WAA0B/C,EAA4B4Z,uIACpD5Z,EAAQuN,yBAAwB,GAE1BmF,EAAekH,EAAK,GACpBqD,EAAcrD,EAAK,GACnBrS,EAAYqS,EAAK,GACjBpI,EAASoI,EAAK,GACdsD,EAAkBvW,GAAgBiT,EAAK,IAEvChV,EAAkBN,GAAgBtE,EAAS0S,GAAcriB,MAC7D,SAACmU,OACMA,QACG,IAAIxW,MAAM,yBAEXwW,KAILK,EAAiBxG,gBAAyBqU,aAE6BhgB,QAAQsS,IAAI,CACvFJ,EACAC,EACAqY,eAHK1Y,gBAAuB0C,OAAbiW,8BAOT,IAAInvB,MAAM,+BAEbwW,yBACG,IAAIxW,MAAM,6BAEbwW,EAASO,gCACN,IAAI/W,MAAM,qCAGbmvB,EAAYrJ,OACfqJ,EAAYrJ,KAAO,IAIfsJ,EAAepd,EAAQmM,qBAAqB3H,EAAS/F,SACrD0I,QAAkBiW,YAGC3V,GAAsBzH,EAASkH,EAAUC,EAAWI,kBAAvE0E,mBACqB7E,GAAgBpH,EAASkH,EAAU+E,EAAWD,uBAAnEqR,SAGFtJ,EAAoC,SAGtCA,EAAqBF,GAA0B7T,EAASmd,EAAa5V,GACrEG,EAAgBC,GAAc3H,EAASiM,EAAY8H,GACnD,MAAO5T,GACPlD,QAAQC,wCAAwCqK,GAChDG,EAAgBC,GAAc3H,EAASiM,MAGzCvE,EAAmBzD,GAAoByD,QACjCwE,EAAalM,EAAQmM,qBAAqBrI,GAAqB9D,EAAS0H,KAE1EqM,GAAsB7H,IAAe6H,yBACjC,IAAI/lB,cAAc+lB,UAA0B7H,kBAG9CzG,EAAU0X,EAGVG,EAAsBrL,GAAYjS,EAASid,EAF3CrV,EAAkByV,EAAazZ,YAG/B2Z,EAAoBtL,GAAYjS,EAASwR,EAAQ9J,aAEsBhV,QAAQsS,IAAI,CACvFsY,EACAC,eAFqBC,qBAKHpK,kCACZ,IAAIplB,MAAM,8DAGbwvB,EAAapK,kCACV,IAAIplB,MAAM,gEAGZyvB,EAAcD,EAAapK,WAAW9W,QAAQ,OAAQ,KAEtDohB,EAAsC,IAChCnW,GAAgBkW,MAAevR,MAErC4H,EAAOjoB,OAAOoK,OAAO,GAAIwP,EAAQqO,KAAOrO,EAAQqO,KAAO,GAAI4J,GACjEjY,EAAQqO,KAAOA,EAGT6J,EAAgBxZ,GAAesB,EAASmC,aAIpC2K,GACRvS,EACA,CAACid,GACDU,EACA/V,EACA8K,gBARIkL,UAWUrtB,gDACPgT,GAAc,CACnBhT,MAAOqtB,EAAYrtB,0CAGdgT,GAAc,CACnBqa,YAAaA,EAAYhK,iHAgM/B,WAA8B5T,EAA4B4Z,mFACpDiE,EAAajE,EAAK,GAEhBY,EAAYxa,EAAQoN,YAAc,IAAIqN,gBAAkB,IAAIC,gBAC5DoD,EAAU,IAAIC,iBAAeF,EAAYrD,qBAExCsD,EACJE,YACA3tB,MAAK,SAAC4e,UACDA,EAAOgP,QACF,CACLC,gBAAiBjP,EAAOkP,QAASD,gBACjCE,mBAAoBnP,EAAOkP,QAASC,mBACpCC,YAAapP,EAAOkP,QAASE,YAC7BC,cAAerP,EAAOkP,QAASG,cAC/BC,YAAa,CACXhV,QAAS0F,EAAOkP,QAASI,YAAYhV,QAAQ3W,SAAS,OACtD4rB,UAAWvP,EAAOkP,QAASI,YAAYC,UAAU5rB,SAAS,SAIvD,2DAGJ,SAACrC,UACCA,EAAMqC,mHAInB,WAAwBoN,EAA4B4Z,mGAC9CtL,EAAS,IAAIlC,UAAGwN,EAAK,IACrB6E,EAASC,OAAO9E,EAAK,IACrB+E,EAAa/E,EAAK,GAClBiE,EAAajE,EAAK,GAEhBY,EAAYxa,EAAQoN,YAAc,IAAIqN,gBAAkB,IAAIC,gBAE5DkE,EAAY,IAAIC,gBAAc,CAClCC,SAAUC,UACVC,SAAUxE,EAAUG,aAEhB5I,EAAW,IAAIkN,cAAYL,GAE3BM,EAAiBnN,EAASoN,kBAAkB,CAChDC,UAAWvB,IAGPC,EAAU,IAAIC,iBAAeF,EAAYrD,GAEzC6E,EAAiBvB,EAAQwB,aAEzBC,EAA0BzB,EAAQ0B,SAAS,CAAEb,WAAAA,EAAYF,OAAAA,sBAExD/rB,QAAQsS,IAAI,CAACka,EAAgBG,EAAgBE,IACjDlvB,MAAK,gBAAEwG,OAAkB4oB,OAClBC,EAAY,IAAItT,eAAWuT,iBAC3BC,EAAY,IAAIxT,UAAGvV,EAAQgpB,IAAIhpB,YAEjC6oB,EAAUI,GAAGxR,SACT,IAAItgB,uDACyC0xB,EAAU9sB,8BAI3D0b,EAAOwR,GAAGF,SACN,IAAI5xB,yDAC2C4xB,EAAUhtB,+BAI5D6sB,EAAiBM,eACd,IAAI/xB,iDAAiDyxB,EAAiBO,eAGvEP,YAEF,SAAAlvB,UACEA,2GAIb,WAAqByP,EAA4B4Z,yGAC3CtL,EAAS,IAAIlC,UAAGwN,EAAK,IACrB6E,EAASC,OAAO9E,EAAK,IACrB+E,EAAa/E,EAAK,GAClBhW,EAAagW,EAAK,GAahBY,EAAYxa,EAAQoN,YAAc,IAAIqN,gBAAkB,IAAIC,gBAC5DuF,EAAYzF,EAAUpN,YAAc5D,qBAAmB0W,QAAU1W,qBAAmBC,QAEpFmV,EAAY,IAAIC,gBAAc,CAClCC,SAAUC,UACVC,SAAUxE,EAAUG,aAEhB5I,EAAW,IAAIkN,cAAYL,GAE3Bf,EAAasC,2BAAyBvc,EAAYqc,GAElDf,EAAiBnN,EAASoN,kBAAkB,CAChDC,UAAWvB,IAGPC,EAAU,IAAIC,iBAAeF,EAAYrD,GAEzC6E,EAAiBvB,EAAQwB,aAEzBc,EAAkBtC,EAAQuC,cAE1Bd,EAA0BzB,EAAQ0B,SAAS,CAAEb,WAAAA,EAAYF,OAAAA,sBAExD/rB,QAAQsS,IAAI,CAACka,EAAgBG,EAAgBe,EAAiBb,IAClElvB,MAAK,gBAAEwG,OAAkBypB,OAAUb,OAC5BC,EAAY,IAAItT,eAAWuT,iBAC3BC,EAAY,IAAIxT,UAAGvV,EAAQgpB,IAAIhpB,SAE/B0pB,EADuBD,EAASE,kBACQ,KAE1Cd,EAAUI,GAAGxR,SACT,IAAItgB,uDACyC0xB,EAAU9sB,8BAI3D0b,EAAOwR,GAAGF,SACN,IAAI5xB,yDAC2C4xB,EAAUhtB,+BAI5D6sB,EAAiBM,eACd,IAAI/xB,iDAAiDyxB,EAAiBO,eAGvElC,EAAQhkB,MAAM,CACnB2mB,eAAgBnS,EAChBqQ,WAAAA,EACAF,OAAAA,EACA7a,WAAAA,EACA8c,gBAAiBH,OAGpBlwB,MAAK,SAAC8qB,UACDA,EAASnvB,eAAe,SACnBmvB,EAEF,CACL1Z,UAAW0Z,EACXC,YAAa9R,GAA0B6R,EAAoBX,cAGxD,SAAAjqB,UACEA,yEAkFb,IAAMowB,GAA4C,CAChD/pB,cAtXF,SAAoBoJ,EAA4B4Z,OACxC1H,EAAa0H,EAAK,GAClBpS,EAAuBoS,EAAK,GAC9B1C,EAAO,IACPD,EAAiB/E,SAEjB0H,EAAKhoB,OAAS,GAAOgoB,EAAK,KAC5B3C,EAAiB2C,EAAK,IAGpBA,EAAKhoB,OAAS,GAAOgoB,EAAK,KAC5B1C,EAAOtX,SAASga,EAAK,KAGnB1C,EAAO,GAAKA,EAAO,MACdxkB,QAAQ1C,UAAUK,MAAK,kBAAMkT,GAAc,CAAEhT,MAAO,oBAGrCoW,GAAgBa,GAGrCnX,MAAK,SAAC6W,GACLsS,IAAS,MAGHoH,EAAaC,mBACnBD,EAAWE,IAAIC,aAEfH,EAAWI,IAAI,eAAe,SAAC7J,EAAsBnb,kEAC5CilB,CAAWjhB,EAASkH,EAAUgL,EAAY+E,EAAgBC,EAAMC,EAAKnb,MAG9E4kB,EAAWI,IAAI,iBAAiB,SAAC7J,EAAsBnb,gEAC9CklB,CAAalhB,EAASkH,EAAUgL,EAAY+E,EAAgBE,EAAKnb,MAG1E4kB,EAAWO,OAAOjK,GAAM,kBAAMja,QAAQC,wCAAwCga,MACvE,iCAEF,SAAC/W,UACCoD,GAAc,CAAEhT,MAAO4P,EAAEsE,cAgVpC5N,QA31CF,SAAiBmJ,EAA4B4Z,OACvCnb,EAAUmb,EAAK,GAEfF,KAEFjb,EAAUuB,EAAQgE,cAAcvF,QAI5B+b,EAAYxa,EAAQoN,YAAc,IAAIqN,gBAAkB,IAAIC,uBAClEF,EAAUG,WAAa3a,EAAQgN,cAAcxX,iBAEtCqZ,UAAM2L,EAAU4G,iBAAiB3iB,IACrCpO,MAAK,SAAA8qB,UAAYA,EAAS7lB,UAC1BjF,MAAK,SAAA8qB,OACAkG,EAAalG,EAAStkB,QACtBskB,EAAStkB,QAAQsL,WAAW,QAC9Bkf,EAAalG,EAAStkB,QAAQyqB,OAAO,QAEnCC,EAAYpG,EAASqG,OACrBrG,EAASqG,OAAOrf,WAAW,QAC7Bof,EAAYpG,EAASqG,OAAOF,OAAO,QAEjCG,EAAetG,EAASmD,cACtBznB,EAAU,IAAIuV,UAAGiV,EAAY,IAC7BG,EAAS,IAAIpV,UAAGmV,EAAW,IAC3BvlB,EAAM,CACVnF,QAASA,EAAQjE,SAAS,IAC1B4uB,OAAQA,EAAO5uB,SAAS,IACxB0rB,cAAemD,EACflM,MAAO4F,EAAS5F,cAEX7iB,QAAQ1C,QAAQuT,GAAcvH,QA4zCzClF,yDACAC,kEACAC,4EACAC,gBAhbF,SAAwB+I,EAA4B4Z,OAE9C8H,EACAC,EACAC,EACAC,EAJEzf,EAAOwX,EAAK,MAMdxX,EAAKH,MAAMtN,GAEb+sB,EAAUhY,GAASoY,SADnBH,EAAUvf,OAEL,CAAA,IAAIA,EAAKH,MAAM,uEAId,IAAIjU,8BAA8BoU,GAHxCuf,EAAUjY,GAASe,SAASrI,GAC5Bsf,EAAUtf,SAKRpC,EAAQ8K,cACV8W,EAAiB5hB,EAAQgE,cAAc0d,GACvCG,EAAiBnY,GAASe,SAASmX,IAG9BlvB,QAAQ1C,UAAUK,MAAK,eACtBF,EAAc,CAClB4xB,QAAS,CACPvX,OAAQmX,EACRpX,IAAKmX,GAEPpU,aAASrf,UAGP+R,EAAQ8K,cACV3a,EAAOmd,QAAU,CACf9C,OAAQqX,EACRtX,IAAKqX,IAIFre,GAAcpT,OA2YvB+G,iBA1RF,SAAyB8I,EAA4B4Z,OAC7CoI,EAAapI,EAAK,UAEiB,IAAIlnB,SAAQ,SAAC1C,EAASC,GACzC,IAAhB2pB,EAAKhoB,QAAkBgoB,EAAK,GAE9B5pB,EADa4pB,EAAK,IAGblf,QAAcgJ,MAKjBgC,GAAQ,oBAAoB,SAAAmB,GAC1B7W,EAAQ6W,MAJV5W,EAAO,IAAIjC,MAAM,0DAWpBqC,MAAK,SAACyW,UAAiB5I,GAAoBmB,OAAOC,KAAK0iB,EAAY,UAAWlb,aACxE,SAAC3G,UACCoD,GAAc,CACnBhT,MACE,sEAA2E4P,EAAEsE,cAkQrFtN,+DACAC,KAlDF,SAAmB6qB,EAA6BC,UACvCxvB,QAAQ1C,UAAUK,MAAK,mBACtB8xB,EAAqC,GACrCC,EAAyBv2B,OAAOgH,KAAKqD,GAASC,YAC3CtE,EAAI,EAAGA,EAAIuwB,EAAaxwB,OAAQC,IAAK,SACtC+K,EAAcwlB,EAAavwB,GAC3B+nB,EAAuB,GACvByI,EAAQnsB,GAASC,WAAWyG,GAAalG,KACzCC,EAAQT,GAASC,WAAWyG,GAAajG,MAEtC6E,EAAI,EAAGA,EAAItF,GAASC,WAAWyG,GAAavG,MAAMzE,OAAQ4J,IAAK,KAChE8mB,EAAUpsB,GAASC,WAAWyG,GAAavG,MAAMmF,GACvDoe,EAAKvoB,KAAK,CACRe,KAAMkwB,EAAQlwB,KACdvD,KAAMyzB,EAAQzzB,KACdjC,MAAO01B,EAAQhsB,SACfisB,OAAQD,EAAQ/rB,QAAU+rB,EAAQ/rB,QAAU,OAIhD4rB,EAAc9wB,KAAK,CACjBuK,QAASgB,EACTgd,KAAMA,EACNyI,MAAOA,EACP1rB,MAAOA,WAGJ4M,GAAc4e,OAwBvB9qB,iBA5UF,SAAyB2I,EAA4B4Z,OAC7C1S,EAAW0S,EAAK,MACe,KAAjC1S,EAASlM,MAAM,OAAOpJ,aAClB,IAAI5D,MAAM,kDAGuB,IAAI0E,SAAQ,SAAC1C,EAASC,GAEzC,IAAhB2pB,EAAKhoB,QAAkBgoB,EAAK,GAE9B5pB,EADO4pB,EAAK,IAGPlf,QAAcgJ,MAMjBgC,GAAQ,oBAAoB,SAAC8c,GAC3B9c,GAAQ,0BAA0B,SAAC+c,GAC7BD,IAAUC,EAEZxyB,EAAO,IAAIjC,MADI,2BAGfgC,EAAQwyB,SATdvyB,EAAO,IAAIjC,MADI,0DAmBlBqC,MAAK,SAACyW,UNv5CFzI,kBMu5CuC6I,EAAUJ,MACrDzW,MAAK,SAACqyB,UAA6BA,EAAiB9vB,SAAS,oBACvD,SAACuN,UACCoD,GAAc,CAAEhT,MAAO4P,EAAEsE,cAySpC/M,gBAhyBF,SAAwBsI,EAA4B4Z,OAC5CpI,EAASoI,EAAK,GACdlS,EAAgBkS,EAAK,GACrB+I,EAAWrP,YAAesG,EAAK,GAAGtd,QAAQ,OAAQ,KAEpDsmB,GAAY,SAEZhJ,EAAKhoB,OAAS,GAAOgoB,EAAK,KAC5BgJ,EAAsC,SAA1BhJ,EAAK,GAAGiJ,eAAsD,MAA1BjJ,EAAK,GAAGiJ,eAK1DxkB,SAAkB2B,QAAQC,OAAS+J,WAAiBA,QAC7CuH,GAASvR,EAAS0H,EAAe8J,GACrCnhB,MAAK,SAACyyB,UACEzkB,aAAsBskB,EAAU,CAAEC,UAAWA,OAErDvyB,MAAK,kBACGkT,GAAc,UA8wBzBhM,iBAptBF,SAAwByI,EAA4B4Z,OAC5C5S,EAAkB4S,EAAK,GACvBrS,EAAYqS,EAAK,GACjBpI,EAASoI,EAAK,GACdpS,EAAuBoS,EAAK,GAC9BmJ,EAAUnJ,EAAK,MAEI,IAAnBmJ,EAAQnxB,aACJ,IAAI5D,MAAM,oCAEC,MAAf+0B,EAAQ,GAAY,KAEhBC,EAAMjJ,eAAgB,KAC5BgJ,EAAUzP,YAAkB0P,MAAOD,aLrVhBzP,MACD,IAAhBA,EAAK1hB,QAA4B,MAAZ0hB,EAAK,SACtB,IAAItlB,MAAM,iCAGZi1B,EAAY3P,EAAKhX,QAAQ,MAAO,IAAItB,MAAM,KAC5CkoB,EAAU,IACLrxB,EAAI,EAAGA,GAAKoxB,EAAUrxB,OAAQC,IAAK,QAGO,IAD9BkoB,YAAamJ,GAChBC,KAAOpJ,YAAaqJ,eAC1B,IAAIp1B,0BAA0Bk1B,GAEtC,MAAO/iB,MACQ,WAAXA,EAAEkjB,WAIEljB,EAFN4Z,YAAamJ,MAKbrxB,IAAMoxB,EAAUrxB,aAGpBsxB,EAAaA,MAAWD,EAAUpxB,IKgUpCyxB,CAAOP,GAwCP1kB,SAAkB2B,QAAQC,OAAS+J,WAAiBA,YAGhDqO,EACA3Q,EAFE6b,EAAsB,UAKrBjc,GAAatH,EAASgH,EAAiBO,EAAWC,GACtDnX,MAAK,SAACgX,UAGEkK,GAASvR,EAFhB0H,EAAgBL,EAAQK,cAEgB8J,EADtBnK,EAAQO,oBAG3BvX,MAAK,SAACyyB,UACE7Q,GAAYjS,EAASwR,EAAQ9J,MAErCrX,MAAK,SAACiiB,UACL+F,EAAgB/F,EACTjU,aAAqB,SAAAjM,UAC1BmxB,EAAUlyB,KAAKe,IACR,QAGV/B,MAAK,SAACmzB,GACLvmB,QAAQC,gBAAgBsmB,uBAClBC,EAA0B3G,GAASyG,GACrCG,EAAiChxB,QAAQ1C,qBACpC6B,OACD8xB,EAAeF,EAAY5xB,GAAGsK,KAAI,SAAAynB,mBAlExBtR,EAA0BsR,OAExCC,EADiBvR,EAAUc,WAAW9W,QAAQ,OAAQ,QAAOgW,EAAU7T,YAC3CmlB,EAC5BE,EAAcf,MAAWa,EAAStnB,QAAQ,MAAO,gBAEvDW,QAAQC,gBAAgB2mB,SAAcC,GAC/BjV,UAAMgV,GACVxzB,MAAK,SAAC0e,MACe,MAAhBA,EAAKE,aACD,IAAIjhB,6BAA6B61B,OAAY9U,EAAKE,YAIpD8U,EAAchV,EAAKiV,QAAQhD,IAAI,uBAEnB,OAAhB+C,GACAA,EAAY5hB,WAAW,SACP,qBAAhB4hB,EAEOhV,EAAKkV,OAELlV,EAAKmV,iBAGf7zB,MAAK,SAAC8zB,UACE,IAAIzxB,SAAQ,SAAC1C,EAASC,OAEzB8pB,gBAAiB+J,EAAUzkB,OAAOC,KAAK6kB,GAAY,CAAEC,SAAU,KAAMjB,KAAM,MAC3EnzB,IACA,MAAOmQ,GACPlQ,EAAOkQ,UAoCyCkkB,CAAahM,EAAeuL,MAC1EU,EAAe5xB,QAAQsS,IAAI2e,GACjCD,EAAmBA,EAAiBrzB,MAAK,kBAAMi0B,MAHxCzyB,EAAI,EAAGA,EAAI4xB,EAAY7xB,OAAQC,MAA/BA,UAMF6xB,EAAiBrzB,MAAK,kBAAMkT,GAAcigB,UA4nBrDhsB,aA33BF,SAAqBwI,EAA4B4Z,OACzC2K,EAAW3K,EAAK,GAChBO,EAASP,EAAK,GACdtG,EAAOsG,EAAK,GACdlS,EAAgBkS,EAAK,GACrB4K,GAAU,EACVC,GAAS,SAEP/c,GAAiBkS,EAAKhoB,OAAS,GAAOgoB,EAAK,KAC/C4K,EAAoC,SAA1B5K,EAAK,GAAGiJ,eAAsD,MAA1BjJ,EAAK,GAAGiJ,eAGlDnb,GAAiBkS,EAAKhoB,OAAS,GAAOgoB,EAAK,KAC/C6K,EAAmC,SAA1B7K,EAAK,GAAGiJ,eAAsD,MAA1BjJ,EAAK,GAAGiJ,eAGlDnb,IAEHA,EAAgB,oEAIlBrJ,SAAkB2B,QAAQC,OAAS+J,WAAiBA,QAC7CuH,GAASvR,EAAS0H,EAAe,MACrCrX,MAAK,SAACyyB,UACLzkB,UAAmBiV,EAAM,CACvBkR,QAASA,EACTC,OAAQA,EACRC,IAAKvK,EACLoK,SAAUA,OAGbl0B,MAAK,SAACkmB,UACDA,aAAgBoO,YACXtlB,OAAOC,KAAKiX,GAEZA,MAw1Bb5e,eAtwBF,SAAuBqI,EAA4B4Z,OAC3CpI,EAASoI,EAAK,GACdlS,EAAgBkS,EAAK,GAIvBgL,EAAQ,SACZvmB,SAAkB2B,QAAQC,OAAS+J,WAAiBA,QAC7CuH,GAASvR,EAASiE,GAAoByD,GAAgB8J,GAC1DnhB,MAAK,SAACyyB,UACEzkB,aAAqB,SAACjM,UAE3B6K,QAAQC,IAAI9K,GACZwyB,GAAS,GACF,QAGVv0B,MAAK,kBAAMkT,GAAcqhB,OAsvB5BntB,aA10BF,SAAqBuI,EAA4B4Z,OACzCpI,EAASoI,EAAK,GACdlS,EAAgBkS,EAAK,GACrBiL,EAAWjL,EAAK,GAChB+I,EAAWrP,YAAesG,EAAK,GAAGtd,QAAQ,OAAQ,KAEpDwoB,GAAU,EACVnkB,GAAO,EAEPiZ,EAAKhoB,OAAS,GAAOgoB,EAAK,KAC5BkL,EAAoC,SAA1BlL,EAAK,GAAGiJ,eAAsD,MAA1BjJ,EAAK,GAAGiJ,eAEpDjJ,EAAKhoB,OAAS,GAAOgoB,EAAK,KAC5BjZ,EAAiC,SAA1BiZ,EAAK,GAAGiJ,eAAsD,MAA1BjJ,EAAK,GAAGiJ,mBAG/CtM,EAAOwD,eAAgB8K,UAI7BxmB,SAAkB2B,QAAQC,OAAS+J,WAAiBA,QAC7CuH,GAASvR,EAAS0H,EAAe8J,GACrCnhB,MAAK,SAACyyB,UACEzkB,UAAmBskB,EAAUpM,EAAM,CAAEuO,QAASA,EAASnkB,KAAMA,OAErEtQ,MAAK,SAAC00B,UACExhB,GAAc,CAAEyhB,KAAM,CAACD,SAizBlCntB,oBAlnBF,SAA2BoI,EAA4B4Z,OAC/C5S,EAAkB4S,EAAK,GACvBrS,EAAYqS,EAAK,GACjBpI,EAASoI,EAAK,GACdpS,EAAuBoS,EAAK,GAC9BmJ,EAAUnJ,EAAK,MAEI,IAAnBmJ,EAAQnxB,aACJ,IAAI5D,MAAM,oCAEC,MAAf+0B,EAAQ,GAAY,KAEhBC,EAAMjJ,eAAgB,KAC5BgJ,EAAUzP,YAAkB0P,MAAOD,OAG/BkC,EAAWlL,cAAegJ,GAC1BU,EAAc3G,GAASmI,EAAU,WAOvC5mB,SAAkB2B,QAAQC,OAAS+J,WAAiBA,QAE7C1C,GAAatH,EAASgH,EAAiBO,EAAWC,GACtDnX,MAAK,SAACgX,UAGEkK,GAASvR,EAFAqH,EAAQK,cAEgB8J,EADtBnK,EAAQO,oBAG3BvX,MAAK,SAACyyB,WACDoC,EAA8BxyB,QAAQ1C,qBACjC6B,OACDszB,EAAsB1B,EAAY5xB,GAAGsK,KAAI,SAACynB,OACxCwB,EAAW9R,OAAUyP,EAASa,GAC9ByB,EAAUtL,eAAgBqL,GAC1BzC,EAAWiB,EAAStnB,QAAQ,SAAU,YACrC+B,UACIskB,EAAU0C,EAAS,CAAEP,SAAS,EAAOnkB,MAAM,IACnDtQ,MAAK,SAAC00B,GACL9nB,QAAQC,gBAAgB0mB,SAAemB,SAG7CG,EAAgBA,EAAc70B,MAAK,kBAAMqC,QAAQsS,IAAImgB,OAX9CtzB,EAAI,EAAGA,EAAI4xB,EAAY7xB,OAAQC,MAA/BA,UAaFqzB,KAER70B,MAAK,kBAAMkT,GAAc0hB,EAASrzB,YAkkBrCiG,2DACAG,YAt5BF,SAAuBgI,EAA4B4Z,OAC3ChW,EAAa7B,GAAiB6X,EAAK,WAClClnB,QAAQ1C,UAAUK,MAAK,eACtB+R,EAAO0B,GAAqB9D,EAAS4D,UACpCL,GAAc,CACnBgH,IAAKnI,EACLoI,OAAQd,GAASe,SAASrI,SAi5B9BtK,oBAl0CF,SAA2BkI,EAA4B4Z,OAC/Cnb,EAAUiL,GAASoY,SAASlI,EAAK,OAEnCA,EAAKhoB,QAAU,GAAOgoB,EAAK,GAAI,KAC3B9J,EAAOlQ,SAASga,EAAK,WACpBlnB,QAAQ1C,UACZK,MAAK,kBACG2P,EAAQsQ,sBAAsB7R,EAASqR,MAE/Czf,MAAK,SAAAi1B,UACJ/hB,GACE+hB,EAAcnpB,KAAI,SAAC0B,SACH,CACZY,QAASiL,GAASe,SAAS5M,EAAEY,SAC7B8mB,aAAc1nB,EAAE0nB,aAAa3yB,WAC7B4yB,YAAa3nB,EAAE2nB,YAAY5yB,uBAQjC6yB,EAAiB,UAErB,SAASC,EAA0B5V,UAC1B9P,EAAQsQ,sBAAsB7R,EAASqR,GAAMzf,MAAK,SAACs1B,UAClC,GAAlBA,EAAQ/zB,OACH6zB,GAEPA,EAAUA,EAAQG,OAAOD,GAClBD,EAA0B5V,EAAO,OAKvC4V,CAA0B,GAAGr1B,MAAK,SAACi1B,UACxC/hB,GACE+hB,EAAcnpB,KAAI,SAAC0B,SACH,CACZY,QAASiL,GAASe,SAAS5M,EAAEY,SAC7B8mB,aAAc1nB,EAAE0nB,aAAa3yB,WAC7B4yB,YAAa3nB,EAAE2nB,YAAY5yB,oBAyxCrCyF,4DACAC,8DACAC,+DACAC,qEACAI,6DACAQ,aA7jDF,SAAqB4G,EAA4B4Z,OAEzCxV,EAAcT,KAAKsW,MAAMF,eADXH,EAAK,IACmChnB,mBACrDF,QAAQ1C,UAAUK,MAAK,kBAAM8T,GAAeC,EAAawV,EAAK,QA2jDrEvgB,cAxgDF,SAAsB2G,EAA4B4Z,OAW5ChV,EAVEihB,EAAgBjM,EAAK,GACrBkM,EAAoBlM,EAAK,GACzBhW,EAAa7B,GAAiB6X,EAAK,IACnC1H,EAAa0H,EAAK,GAElBmM,EAAoBhM,eAAgB+L,GAAmBlzB,WAEvDwqB,EAAetZ,GAAqB9D,EAAS4D,GAC7CoiB,EAAsBhmB,EAAQmM,qBAAqBiR,GAGrDhrB,EAAO,GAEPyzB,EAAc1jB,WAAW,OAE3ByC,EAAkBlS,QAAQ1C,UAAUK,MAAK,iBAChC,CACLoO,QAASonB,EAAczyB,MAAM,QAKjCwR,EAAkBN,GAAgBtE,EAAS6lB,GAC3CzzB,EAAOyzB,OAGHI,EAAuBtM,GAAc3Z,EAAS,CAClD8lB,QACME,WAGDtzB,QAAQsS,IAAI,CAACJ,EAAiBqhB,IAClC51B,MAAK,gBAAEmU,UAEJ+U,MACE/U,GACAxE,EAAQgE,cAAcQ,EAAS/F,WAAauB,EAAQgE,cAAcoZ,UAE9D,IAAIpvB,MACR,uFACyBovB,UAGtB7K,GAAqBvS,EAAS,CAACkS,GAAa6T,EAAmBnM,EAAK,GAAIxnB,MAEhF/B,MAAK,SAACmiB,UACDA,EAASxmB,eAAe,SACnBuX,GAAc,CAAEqQ,SAAUpB,EAASoB,SAAWrjB,MAAOiiB,EAASjiB,QAAU,GAExEgT,GAAc,CAAEqa,YAAapL,EAASoB,eAu9CnDta,eAAgBqgB,GAEhB9f,2DACAC,qDACAC,+DACAzC,OA/GF,SAAoB4uB,EAAsBtM,OACpCnb,EAAUmb,EAAK,GAGbgF,EAAY,IAAIC,gBAAc,CAClCC,SAAUC,UACVC,SAAU,kDAGI,IAAImH,aAAWvH,GAG5BwH,aAAa,CAAE3nB,QAAAA,IACfpO,MAAK,SAACg2B,UACE9iB,GAAc,CACnB9B,KAAM4kB,EAASC,KACflL,YAAa9R,GAA0B+c,EAASC,KAAO,IAAI5L,6BAGxD,SAACnqB,UAAeA,EAAMqC,yBAkGjB2zB,SAER9oB,WPwwCN+oB,EACA/oB,YAAAA,IAAAA,EAAe,gDAETgpB,EAAsB,GACtBC,EAAgB,GAChBC,EAAWH,EAAKpzB,MAAM,GAEnBvB,EAAI,EAAGA,EAAI4L,EAAK7L,OAAQC,IAChB,KAAX4L,EAAK5L,KAIP40B,EAAUhpB,EAAK5L,IADbA,EAAI,EAAI4L,EAAK7L,QAAyB,KAAf6L,EAAK5L,EAAI,IACb,oBAMPhG,OAAOgH,KAAK4zB,0BAAnBG,OACA/0B,EAAI,EAAGA,EAAI80B,EAAS/0B,QACP,OAAhB+0B,EAAS90B,IAGO,OAAhB80B,EAAS90B,GAJsBA,QAQf+0B,IACJD,EAAS90B,MACA,IAAnB40B,EAAUG,IAEZH,EAAUG,IAAO,EACjBD,EAAS90B,GAAK,KAGd40B,EAAUG,GAAOD,EAAS90B,EAAI,GAC9B80B,EAAS90B,GAAK,GACd80B,EAAS90B,EAAI,GAAK,SAMrB,IAAIA,EAAI,EAAGA,EAAI80B,EAAS/0B,OAAQC,OAC/B80B,EAAS90B,GAAGD,OAAS,EAAG,IACN,OAAhB+0B,EAAS90B,YAGb60B,EAAcr1B,KAAKs1B,EAAS90B,WAIhC40B,EAAS,EAAQC,EACVD,EO7zCMI,CADAnsB,QAGPosB,WPk9CkBC,MACpBA,EAAQn1B,QAAU,QACb,CACLo1B,SAAS,EACTz2B,MAAO,mBACP8xB,OAAO,EACPzmB,QAAS,QAIPgB,EAAcmqB,EAAQ,GACtBE,EAAiBF,EAAQ3zB,MAAM,OAEhC8C,GAASC,WAAWnK,eAAe4Q,SAC/B,CACLoqB,SAAS,EACTz2B,+BAAgCqM,MAChCylB,OAAO,EACPzmB,QAASgB,OAIPsqB,WA/HuBtrB,EAAiBurB,OAC1CC,EAAelxB,GAASC,WAAWyF,GAASvF,MAC3CuH,MAAMypB,QAAQD,KACjBA,EAAe,CAACA,YAGZE,EAAc,GACdC,EAAoC,GAGjC11B,EAAI,EAAGA,EAAIs1B,EAASv1B,OAAQC,OAC/Bs1B,EAASt1B,GAAGsQ,WAAW,MAAO,KAE1BqlB,EAAUL,EAASt1B,GAAGuB,MAAM,GAC9Bq0B,EAAW,QAGXF,EAAUv7B,eAAew7B,SACpB,CACLvY,QAAQ,EACR1e,4BAA6B42B,EAASt1B,QAIrC,IAAI2J,EAAI,EAAGA,EAAI4rB,EAAax1B,OAAQ4J,OAClC4rB,EAAa5rB,GAAGxP,eAAe,SAGhCo7B,EAAa5rB,GAAGpJ,OAASo1B,EAAS,IAGhC31B,EAAI,GAAKs1B,EAASv1B,aACb,CACLqd,QAAQ,EACR1e,+BAAgC42B,EAASt1B,IAI7C41B,EAAWN,EAASt1B,EAAI,OAIxB41B,QAKK,CACLxY,QAAQ,EACR1e,0BAA2B42B,EAASt1B,IALtCA,GAAK,EACL01B,EAAUC,GAAWC,OASvBH,EAAYj2B,KAAK81B,EAASt1B,YAMxB61B,EAAa,GACfC,EAAkB,EAEb91B,EAAI,EAAGA,EAAIu1B,EAAax1B,OAAQC,IACnC81B,EAAkBL,EAAY11B,OAC3Bw1B,EAAav1B,GAAG7F,eAAe,SAIxBu7B,EAAUv7B,eAAeo7B,EAAav1B,GAAGO,MAMnDs1B,EAAWr2B,KAAKk2B,EAAUH,EAAav1B,GAAGO,QAR1Cs1B,EAAWr2B,KAAKi2B,EAAYK,IAC5BA,GAAmB,GAWrBD,EAAWr2B,KAAKk2B,EAAUH,EAAav1B,GAAGO,aAIvC,CACL6c,QAAQ,EACR2Y,UAAWF,GA0CaG,CAAejrB,EAAaqqB,OACjDC,EAAkBjY,aACd,CACL+X,SAAS,EACTz2B,MAAO22B,EAAkB32B,MACzB8xB,OAAO,EACPzmB,QAASgB,WAIPC,EAAcqqB,EAAkBU,UAKhCE,EAAgBnkB,KAAKsW,MAAMtW,KAAKvO,UAAUc,GAASC,WAAWyG,KAC3D/K,EAAIi2B,EAActxB,SAAU3E,EAAIi2B,EAAcrxB,SAAU5E,IAC3DA,EAAIgL,EAAajL,QACfiL,MAAAA,EAAahL,KAIfgL,EAAYhL,GAAK,KACjBi2B,EAAczxB,MAAMxE,GAAK,CAAEhD,KAAM,aAKjCk5B,EAAMC,gBACED,EAAIE,SAASH,EAAejrB,GAC9B,SACNya,EAAW,GACNzlB,EAAI,EAAGA,EAAIk2B,EAAIG,OAAQt2B,OAAQC,IAMtCylB,yCAJEyQ,EAAIG,OAAQ,GAAGC,6CACiBJ,EAAIG,OAAQ,GAAGzjB,sBAAqBd,KAAKvO,UACzE2yB,EAAIG,OAAQ,GAAGE,qBAIZ,CACLpB,SAAS,EACTz2B,MAAO+mB,EACP+K,OAAO,EACPzmB,QAASgB,SAIN,CACLoqB,SAAS,EACTprB,QAASgB,EACTgd,KAAM/c,GO3hDawrB,CACnB1qB,GAAoBF,EAAM,KAAOE,GAAoBF,EAAM,KAAQ,OAEhEqpB,EAAQE,QAcN,CACL3N,GAAS3b,GAAaD,EAAM,KAC5B6b,GAAe5b,GAAaD,EAAM,KAClC8b,IAAgB7b,GAAaD,EAAM,KACnCkP,GAAoBlP,EAAI,EAAQmC,SAASpC,GAAeC,EAAM,MAASkP,GACvEC,GAAcnP,EAAI,EAAQmC,SAASpC,GAAeC,EAAM,MAASmP,GACjE6M,GAAmBhc,EAAI,EAAQmC,SAASpC,GAAeC,EAAM,MAASgc,OAEhE6O,EAAQ5qB,GAAaD,EAAM,KAC3B6O,EAAgB9O,GAAeC,EAAM,KACrC8qB,EAAmB7qB,GAAaD,EAAM,KACtC6P,EAAU5P,GAAaD,EAAM,KAE7B+qB,GADahrB,GAAeC,EAAM,KACzBD,GAAeC,EAAM,MAC9BgrB,EAA4BjrB,GAAeC,EAAM,KACjDqP,EAAatP,GAAeC,EAAM,KAClCirB,EAAUlrB,GAAeC,EAAM,KAC/B1H,EAAmByH,GAAeC,EAAM,KACxC3H,EAAmB0H,GAAeC,EAAM,KAE1C8qB,IACF7O,GAAkB6O,OAGdI,EAAanrB,GAAeC,EAAM,KACpCD,GAAeC,EAAM,KACrB8qB,EPpqDmC,iCOsqDnCjb,EPrqDmC,iCAFR,yBO2qDzBsb,EAAoBprB,GAAeC,EAAM,KACzC8O,EAAU/O,GAAeC,EAAM,KAAOmC,SAASpC,GAAeC,EAAM,MAAS,EAC7EgP,EAAajP,GAAeC,EAAM,KAAOD,GAAeC,EAAM,KAAO,IACrEiP,EAAalP,GAAeC,EAAM,KAIlCorB,WP8+CiBC,EAAoBC,MACzB,YAAhBA,GAA6C,YAAhBA,GAA4C,WAAfA,QACtD,IAAI/6B,MAAM,4BAGdg7B,EAGFA,EAAYn9B,OAAOoK,OAAO,GADR,YAAhB8yB,EAC4BxzB,EACL,YAAhBwzB,EACqBlzB,EAEAG,OAI9BgzB,EAAYrlB,KAAKsW,MAAMF,eAAgB+O,GAAYl2B,YACnD,MAAOuN,WAEF6oB,EOjgDcC,CAAWN,EAFVrb,EAAU,UAAYib,EAAmB,UAAY,WAKvEM,EAAWjzB,UAAUX,MADnBqzB,EAC2B,QAEA,OAE3BvyB,IACF8yB,EAAW9yB,iBAAmBA,GAE5BD,IACF+yB,EAAW/yB,iBAAmBA,GAG5B4yB,IACFG,EAAWlzB,eAAiB+yB,GAG9BQ,YAAkB,CAChBj0B,MAAO4zB,EAAWjzB,UAAUX,MAC5Bk0B,WAAY,CAAC,IAAID,aAAmBE,QAAQP,EAAWjzB,kBAGnDyzB,EAA4B,CAChC/c,cAAeA,GAAgC,KAC/CC,QAASA,GAAoB,KAC7BC,qBAAsBoc,GAAwC,KAC9Dnc,WAAYA,GAA0B,KACtCC,WAAYA,GAA0B,KACtCC,kBAAmBA,IAAwC,KAC3DC,YAAaA,IAA4B,KACzCC,UAAW2b,GAAkBK,EAAWrzB,iBACxCuX,6BAA8B0b,GAE1BI,EAAWnzB,oBACfoX,WAAYA,GAA0B+b,EAAWpzB,mBAI7C6zB,WHz/CiBT,EAA6BU,UAClDA,EACc,IAAIlrB,UAAW2B,QAAQwpB,aACrCX,EAAWrzB,iBACXqzB,EAAWnzB,oBACX,IAAI2I,UAAW2B,QAAQypB,YAAYZ,EAAWlzB,eAAgB,CAC5D4uB,SAAUsE,EAAW9yB,kBAAoB,aACzCqI,SAAUyqB,EAAW/yB,kBAAoB,sBAM7B,IAAImX,oBAClB4b,EAAWrzB,iBACXqzB,EAAWnzB,oBACX,IAAI2I,UAAW2B,QAAQ0pB,kBAAkBb,EAAWlzB,iBGy+C/Bg0B,CACrBd,IACEnP,MAAqB6O,KAAsBjb,GAEzCsc,EAAoB,IAAIvd,GAAkBid,EAAgBD,GAMhEhrB,SAAkBwrB,SAAW,QAEL,SAApB/C,EAAQlrB,UACVqB,QAAQC,IAAIX,GAAuBuqB,EAAQlN,KAAK,KAChDlf,OAAa,QAIXovB,EAAW,GAEfh8B,EAHe6yB,GAASmG,EAAQlrB,UAGzBguB,EAAmB9C,EAAQlN,MAC/BvpB,MAAK,SAACF,UAGCA,aAAkBkP,cACblP,MAED45B,EAAepmB,KAAKsW,MAAM9pB,UAC5B45B,EAAQ/9B,eAAe,YAAc+9B,EAAQ9a,SAC/C6a,EAAW,GAEN35B,EAET,MAAOgQ,UACAhQ,MAGVE,MAAK,SAACF,GACDA,aAAkBkP,OACpB3E,SAAeqL,MAAM5V,GAErB8M,QAAQC,IAAI/M,MAGfE,MAAK,WACCmpB,IACH9e,OAAaovB,aAGV,SAAC3pB,GACNlD,QAAQ1M,MAAM4P,EAAErG,OAChBmD,QAAQ1M,MAAM4P,EAAEsE,SACX+U,IACH9e,OAAa,WAhJfosB,EAAQv2B,OACV0M,QAAQC,IAAI4pB,EAAQv2B,OAElBu2B,EAAQzE,QACNyE,EAAQlrB,SACVqB,QAAQC,IAAIX,GAAuBuqB,EAAQlrB,UAC3CqB,QAAQC,IAAI,sCAEZD,QAAQC,IAAIzC,IACZwC,QAAQC,IAAIrB,QAGhBnB,OAAa,GC9uDjB,IAAMsvB,GAAuC,GAK7CC,OAAM,OAAa,CACjBC,SAAU,CACR/P,OAAQ,aAEVtI,aAAc,CACZsY,QAAS,SAASC,UACTJ,GAAgBI,IAEzBtY,QAAS,SAASsY,EAAkBC,GAClCL,GAAgBI,GAAYC,GAE9BC,WAAY,SAASF,UACZJ,GAAgBI,MAK7BH,OAAM,aAAmBA,OAAM,OAAWpY,aAE1C0U"}
{"version":3,"file":"data.esm.js","sources":["../src/data.ts"],"sourcesContent":["import * as blockstack from 'blockstack';\nimport * as URL from 'url';\nimport * as crypto from 'crypto';\nimport * as jsontokens from 'jsontokens';\n\nconst ZoneFile = require('zone-file');\n\nimport {\n  canonicalPrivateKey,\n  getPrivateKeyAddress,\n  checkUrl,\n  SafetyError,\n  getPublicKeyFromPrivateKey,\n} from './utils';\n\nimport { CLINetworkAdapter, NameInfoType } from './network';\n\nimport { UserData } from '@stacks/auth';\n\nimport { GaiaHubConfig, connectToGaiaHub } from '@stacks/storage';\n\n/*\n * Set up a session for Gaia.\n * Generate an authentication response like what the browser would do,\n * and store the relevant data to our emulated localStorage.\n */\nfunction makeFakeAuthResponseToken(\n  appPrivateKey: string | null,\n  hubURL: string | null,\n  associationToken?: string\n) {\n  const ownerPrivateKey = '24004db06ef6d26cdd2b0fa30b332a1b10fa0ba2b07e63505ffc2a9ed7df22b4';\n  const transitPrivateKey = 'f33fb466154023aba2003c17158985aa6603db68db0f1afc0fcf1d641ea6c2cb';\n  const transitPublicKey =\n    '0496345da77fb5e06757b9c4fd656bf830a3b293f245a6cc2f11f8334ebb690f1' +\n    '9582124f4b07172eb61187afba4514828f866a8a223e0d5c539b2e38a59ab8bb3';\n\n  // eslint-disable-next-line\n  window.localStorage.setItem('blockstack-transit-private-key', transitPrivateKey);\n\n  const authResponse = blockstack.makeAuthResponse(\n    ownerPrivateKey,\n    { type: '@Person', accounts: [] },\n    // @ts-ignore\n    null,\n    {},\n    null,\n    appPrivateKey,\n    undefined,\n    transitPublicKey,\n    hubURL,\n    blockstack.config.network.blockstackAPIUrl,\n    associationToken\n  );\n\n  return authResponse;\n}\n\n/*\n * Make an association token for the given address.\n * TODO belongs in a \"gaia.js\" library\n */\nexport function makeAssociationToken(appPrivateKey: string, identityKey: string): string {\n  const appPublicKey = getPublicKeyFromPrivateKey(`${canonicalPrivateKey(appPrivateKey)}01`);\n  const FOUR_MONTH_SECONDS = 60 * 60 * 24 * 31 * 4;\n  const salt = crypto.randomBytes(16).toString('hex');\n  const identityPublicKey = getPublicKeyFromPrivateKey(identityKey);\n  const associationTokenClaim = {\n    childToAssociate: appPublicKey,\n    iss: identityPublicKey,\n    exp: FOUR_MONTH_SECONDS + new Date().getTime() / 1000,\n    salt,\n  };\n  const associationToken = new jsontokens.TokenSigner('ES256K', identityKey).sign(\n    associationTokenClaim\n  );\n  return associationToken;\n}\n\n/*\n * Authenticate to Gaia.  Used for reading, writing, and listing files.\n * Process a (fake) session token and set up a Gaia hub connection.\n * Returns a Promise that resolves to the (fake) userData\n */\nexport function gaiaAuth(\n  network: CLINetworkAdapter,\n  appPrivateKey: string | null,\n  hubUrl: string | null,\n  ownerPrivateKey?: string\n): Promise<UserData> {\n  // Gaia speaks mainnet only!\n  if (!network.isMainnet()) {\n    throw new Error('Gaia only works with mainnet networks.');\n  }\n\n  let associationToken;\n  if (ownerPrivateKey && appPrivateKey) {\n    associationToken = makeAssociationToken(appPrivateKey, ownerPrivateKey);\n  }\n\n  const authSessionToken = makeFakeAuthResponseToken(appPrivateKey, hubUrl, associationToken);\n  const nameLookupUrl = `${network.legacyNetwork.blockstackAPIUrl}/v1/names/`;\n  const transitPrivateKey = 'f33fb466154023aba2003c17158985aa6603db68db0f1afc0fcf1d641ea6c2cb'; // same as above\n  //@ts-ignore\n  return blockstack.handlePendingSignIn(nameLookupUrl, authSessionToken, transitPrivateKey);\n}\n\n/*\n * Connect to Gaia hub and generate a hub config.\n * Used for reading and writing profiles.\n * Make sure we use a mainnet address always, even in test mode.\n * Returns a Promise that resolves to a GaiaHubConfig\n */\nexport function gaiaConnect(\n  network: CLINetworkAdapter,\n  gaiaHubUrl: string,\n  privateKey: string,\n  ownerPrivateKey?: string\n) {\n  const addressMainnet = network.coerceMainnetAddress(\n    getPrivateKeyAddress(network, `${canonicalPrivateKey(privateKey)}01`)\n  );\n  const addressMainnetCanonical = network.coerceMainnetAddress(\n    getPrivateKeyAddress(network, canonicalPrivateKey(privateKey))\n  );\n\n  let associationToken;\n  if (ownerPrivateKey) {\n    associationToken = makeAssociationToken(privateKey, ownerPrivateKey);\n  }\n\n  return connectToGaiaHub(gaiaHubUrl, canonicalPrivateKey(privateKey), associationToken).then(\n    hubConfig => {\n      // ensure that hubConfig always has a mainnet address, even if we're in testnet\n      if (network.coerceMainnetAddress(hubConfig.address) === addressMainnet) {\n        hubConfig.address = addressMainnet;\n      } else if (network.coerceMainnetAddress(hubConfig.address) === addressMainnetCanonical) {\n        hubConfig.address = addressMainnetCanonical;\n      } else {\n        throw new Error(\n          'Invalid private key: ' +\n            `${network.coerceMainnetAddress(hubConfig.address)} is neither ` +\n            `${addressMainnet} or ${addressMainnetCanonical}`\n        );\n      }\n      return hubConfig;\n    }\n  );\n}\n\n/*\n * Find the profile.json path for a name\n * @network (object) the network to use\n * @blockstackID (string) the blockstack ID to query\n *\n * Returns a Promise that resolves to the filename to use for the profile\n * Throws an exception if the profile URL could not be determined\n */\nfunction gaiaFindProfileName(\n  network: CLINetworkAdapter,\n  hubConfig: GaiaHubConfig,\n  blockstackID?: string\n): Promise<string> {\n  if (!blockstackID || blockstackID === null || blockstackID === undefined) {\n    return Promise.resolve().then(() => 'profile.json');\n  } else {\n    return network.getNameInfo(blockstackID).then((nameInfo: NameInfoType) => {\n      let profileUrl;\n      try {\n        const zonefileJSON = ZoneFile.parseZoneFile(nameInfo.zonefile);\n        if (zonefileJSON.uri && zonefileJSON.hasOwnProperty('$origin')) {\n          profileUrl = blockstack.getTokenFileUrl(zonefileJSON);\n        }\n      } catch (e) {\n        throw new Error(\n          `Could not determine profile URL for ${String(blockstackID)}: could not parse zone file`\n        );\n      }\n\n      if (profileUrl === null || profileUrl === undefined) {\n        throw new Error(\n          `Could not determine profile URL for ${String(blockstackID)}: no URL in zone file`\n        );\n      }\n\n      // profile URL path must match Gaia hub's URL prefix and address\n      // (the host can be different)\n      const gaiaReadPrefix = `${hubConfig.url_prefix}${hubConfig.address}`;\n      const gaiaReadUrlPath = String(URL.parse(gaiaReadPrefix).path);\n      const profileUrlPath = String(URL.parse(profileUrl).path);\n\n      if (!profileUrlPath.startsWith(gaiaReadUrlPath)) {\n        throw new Error(\n          `Could not determine profile URL for ${String(blockstackID)}: wrong Gaia hub` +\n            ` (${gaiaReadPrefix} does not correspond to ${profileUrl})`\n        );\n      }\n\n      const profilePath = profileUrlPath.substring(gaiaReadUrlPath.length + 1);\n      return profilePath;\n    });\n  }\n}\n\n/*\n * Upload profile data to a Gaia hub.\n *\n * Legacy compat:\n * If a blockstack ID is given, then the zone file will be queried and the profile URL\n * inspected to make sure that we handle the special (legacy) case where a profile.json\n * file got stored to $GAIA_URL/$ADDRESS/$INDEX/profile.json (where $INDEX is a number).\n * In such cases, the profile will be stored to $INDEX/profile.json, instead of just\n * profile.json.\n *\n * @network (object) the network to use\n * @gaiaHubUrl (string) the base scheme://host:port URL to the Gaia hub\n * @gaiaData (string) the data to upload\n * @privateKey (string) the private key to use to sign the challenge\n * @blockstackID (string) optional; the blockstack ID for which this profile will be stored.\n */\nexport function gaiaUploadProfile(\n  network: CLINetworkAdapter,\n  gaiaHubURL: string,\n  gaiaData: string,\n  privateKey: string,\n  blockstackID?: string\n) {\n  let hubConfig: GaiaHubConfig;\n  return gaiaConnect(network, gaiaHubURL, privateKey)\n    .then((hubconf: GaiaHubConfig) => {\n      // make sure we use the *right* gaia path.\n      // if the blockstackID is given, then we should inspect the zone file to\n      // determine if the Gaia profile URL contains an index.  If it does, then\n      // we need to preserve it!\n      hubConfig = hubconf;\n      return gaiaFindProfileName(network, hubConfig, blockstackID);\n    })\n    .then((profilePath: string) => {\n      return blockstack.uploadToGaiaHub(profilePath, gaiaData, hubConfig);\n    });\n}\n\n/*\n * Upload profile data to all Gaia hubs, given a zone file.\n * @network (object) the network to use\n * @gaiaUrls (array) list of Gaia URLs\n * @gaiaData (string) the data to store\n * @privateKey (string) the hex-encoded private key\n * @return a promise with {'dataUrls': [urls to the data]}, or {'error': ...}\n */\nexport function gaiaUploadProfileAll(\n  network: CLINetworkAdapter,\n  gaiaUrls: string[],\n  gaiaData: string,\n  privateKey: string,\n  blockstackID?: string\n): Promise<{ dataUrls?: string[] | null; error?: string | null }> {\n  const sanitizedGaiaUrls = gaiaUrls\n    .map(gaiaUrl => {\n      const urlInfo = URL.parse(gaiaUrl);\n      if (!urlInfo.protocol) {\n        return '';\n      }\n      if (!urlInfo.host) {\n        return '';\n      }\n      // keep flow happy\n      return `${String(urlInfo.protocol)}//${String(urlInfo.host)}`;\n    })\n    .filter(gaiaUrl => gaiaUrl.length > 0);\n\n  const uploadPromises = sanitizedGaiaUrls.map(gaiaUrl =>\n    gaiaUploadProfile(network, gaiaUrl, gaiaData, privateKey, blockstackID)\n  );\n\n  return Promise.all(uploadPromises)\n    .then(publicUrls => {\n      return { error: null, dataUrls: publicUrls! };\n    })\n    .catch(e => {\n      return { error: `Failed to upload: ${e.message}`, dataUrls: null };\n    });\n}\n\n/*\n * Make a zone file from a Gaia hub---reach out to the Gaia hub, get its read URL prefix,\n * and generate a zone file with the profile mapped to the Gaia hub.\n *\n * @network (object) the network connection\n * @name (string) the name that owns the zone file\n * @gaiaHubUrl (string) the URL to the gaia hub write endpoint\n * @ownerKey (string) the owner private key\n *\n * Returns a promise that resolves to the zone file with the profile URL\n */\nexport function makeZoneFileFromGaiaUrl(\n  network: CLINetworkAdapter,\n  name: string,\n  gaiaHubUrl: string,\n  ownerKey: string\n) {\n  const address = getPrivateKeyAddress(network, ownerKey);\n  const mainnetAddress = network.coerceMainnetAddress(address);\n\n  return gaiaConnect(network, gaiaHubUrl, ownerKey).then(hubConfig => {\n    if (!hubConfig.url_prefix) {\n      throw new Error('Invalid hub config: no read_url_prefix defined');\n    }\n    const gaiaReadUrl = hubConfig.url_prefix.replace(/\\/+$/, '');\n    const profileUrl = `${gaiaReadUrl}/${mainnetAddress}/profile.json`;\n    try {\n      checkUrl(profileUrl);\n    } catch (e) {\n      throw new SafetyError({\n        status: false,\n        error: e.message,\n        hints: [\n          'Make sure the Gaia hub read URL scheme is present and well-formed.',\n          `Check the \"read_url_prefix\" field of ${gaiaHubUrl}/hub_info`,\n        ],\n      });\n    }\n    return blockstack.makeProfileZoneFile(name, profileUrl);\n  });\n}\n\n/*\n * Given a Gaia bucket URL, extract its address\n */\nexport function getGaiaAddressFromURL(appUrl: string): string {\n  const matches = appUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n  if (!matches) {\n    throw new Error('Failed to parse gaia address');\n  }\n  return matches[matches.length - 1];\n}\n\n/*\n * Given a profile and an app origin, find its app address\n * Returns the address on success\n * Throws on error or not found\n */\nexport function getGaiaAddressFromProfile(\n  network: CLINetworkAdapter,\n  profile: any,\n  appOrigin: string\n): string {\n  if (!profile) {\n    throw new Error('No profile');\n  }\n  if (!profile.apps) {\n    throw new Error('No profile apps');\n  }\n  if (!profile.apps[appOrigin]) {\n    throw new Error(`No app entry for ${appOrigin}`);\n  }\n\n  // do we already have an address set for this app?\n  const appUrl = profile.apps[appOrigin];\n  let existingAppAddress;\n  // what's the address?\n  try {\n    existingAppAddress = network.coerceMainnetAddress(getGaiaAddressFromURL(appUrl));\n  } catch (e) {\n    throw new Error(`Failed to parse app URL ${appUrl}`);\n  }\n\n  return existingAppAddress;\n}\n"],"names":["ZoneFile","require","makeFakeAuthResponseToken","appPrivateKey","hubURL","associationToken","ownerPrivateKey","transitPrivateKey","transitPublicKey","window","localStorage","setItem","authResponse","blockstack","type","accounts","undefined","network","blockstackAPIUrl","makeAssociationToken","identityKey","appPublicKey","getPublicKeyFromPrivateKey","canonicalPrivateKey","FOUR_MONTH_SECONDS","salt","crypto","toString","identityPublicKey","associationTokenClaim","childToAssociate","iss","exp","Date","getTime","jsontokens","sign","gaiaAuth","hubUrl","isMainnet","Error","authSessionToken","nameLookupUrl","legacyNetwork","gaiaConnect","gaiaHubUrl","privateKey","addressMainnet","coerceMainnetAddress","getPrivateKeyAddress","addressMainnetCanonical","connectToGaiaHub","then","hubConfig","address","gaiaFindProfileName","blockstackID","Promise","resolve","getNameInfo","nameInfo","profileUrl","zonefileJSON","parseZoneFile","zonefile","uri","hasOwnProperty","e","String","gaiaReadPrefix","url_prefix","gaiaReadUrlPath","URL","path","profileUrlPath","startsWith","profilePath","substring","length","gaiaUploadProfile","gaiaHubURL","gaiaData","hubconf","gaiaUploadProfileAll","gaiaUrls","sanitizedGaiaUrls","map","gaiaUrl","urlInfo","protocol","host","filter","uploadPromises","all","publicUrls","error","dataUrls","message","getGaiaAddressFromURL","appUrl","matches","match","getGaiaAddressFromProfile","profile","appOrigin","apps","existingAppAddress"],"mappings":"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"}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const types_1 = require("./types");
const keys_1 = require("./keys");
const BigNum = require("bn.js");
class Deserializable {
    static deserialize(bufferReader) {
        const message = new this();
        message.deserialize(bufferReader);
        return message;
    }
}
class MessageSignature extends Deserializable {
    constructor(signature) {
        super();
        if (signature) {
            const length = Buffer.from(signature, 'hex').byteLength;
            if (length != constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
                throw Error('Invalid signature');
            }
        }
        this.signature = signature;
    }
    static empty() {
        const messageSignature = new this();
        messageSignature.signature = Buffer.alloc(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex');
        return messageSignature;
    }
    toString() {
        var _a;
        return _a = this.signature, (_a !== null && _a !== void 0 ? _a : '');
    }
    serialize() {
        const bufferArray = new utils_1.BufferArray();
        if (this.signature === undefined) {
            throw new Error('"signature" is undefined');
        }
        bufferArray.appendHexString(this.signature);
        return bufferArray.concatBuffer();
    }
    deserialize(bufferReader) {
        this.signature = bufferReader.readBuffer(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex');
    }
}
exports.MessageSignature = MessageSignature;
class SpendingCondition extends Deserializable {
    constructor(addressHashMode, pubKey, nonce, fee) {
        super();
        this.addressHashMode = addressHashMode;
        if (addressHashMode !== undefined && pubKey) {
            this.signerAddress = types_1.addressFromPublicKeys(0, addressHashMode, 1, [
                keys_1.createStacksPublicKey(pubKey),
            ]);
        }
        this.nonce = nonce;
        this.fee = fee;
        if (pubKey) {
            this.pubKeyEncoding = keys_1.isCompressed(keys_1.createStacksPublicKey(pubKey))
                ? constants_1.PubKeyEncoding.Compressed
                : constants_1.PubKeyEncoding.Uncompressed;
        }
        this.signature = MessageSignature.empty();
    }
    singleSig() {
        if (this.addressHashMode === constants_1.AddressHashMode.SerializeP2PKH ||
            this.addressHashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
            return true;
        }
        else {
            return false;
        }
    }
    clear() {
        const cleared = _.cloneDeep(this);
        cleared.nonce = new BigNum(0);
        cleared.fee = new BigNum(0);
        cleared.signature = MessageSignature.empty();
        return cleared;
    }
    static makeSigHashPreSign(curSigHash, authType, fee, nonce) {
        // new hash combines the previous hash and all the new data this signature will add. This
        // includes:
        // * the previous hash
        // * the auth flag
        // * the tx fee (big-endian 8-byte number)
        // * nonce (big-endian 8-byte number)
        const hashLength = 32 + 1 + 8 + 8;
        const sigHash = curSigHash +
            Buffer.from([authType]).toString('hex') +
            fee.toArrayLike(Buffer, 'be', 8).toString('hex') +
            nonce.toArrayLike(Buffer, 'be', 8).toString('hex');
        if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {
            throw Error('Invalid signature hash length');
        }
        return utils_1.txidFromData(Buffer.from(sigHash, 'hex'));
    }
    static makeSigHashPostSign(curSigHash, publicKey, signature) {
        // new hash combines the previous hash and all the new data this signature will add.  This
        // includes:
        // * the public key compression flag
        // * the signature
        const hashLength = 32 + 1 + constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
        const pubKeyEncoding = keys_1.isCompressed(publicKey)
            ? constants_1.PubKeyEncoding.Compressed
            : constants_1.PubKeyEncoding.Uncompressed;
        const sigHash = curSigHash + utils_1.leftPadHex(pubKeyEncoding.toString(16)) + signature.toString();
        if (Buffer.from(sigHash, 'hex').byteLength > hashLength) {
            throw Error('Invalid signature hash length');
        }
        return new utils_1.sha512_256().update(sigHash).digest('hex');
    }
    static nextSignature(curSigHash, authType, fee, nonce, privateKey) {
        const sigHashPreSign = this.makeSigHashPreSign(curSigHash, authType, fee, nonce);
        const signature = keys_1.signWithKey(privateKey, sigHashPreSign);
        const publicKey = keys_1.getPublicKey(privateKey);
        const nextSigHash = this.makeSigHashPostSign(sigHashPreSign, publicKey, signature);
        return {
            nextSig: signature,
            nextSigHash,
        };
    }
    numSignatures() {
        return 0;
    }
    serialize() {
        const bufferArray = new utils_1.BufferArray();
        if (this.addressHashMode === undefined) {
            throw new Error('"addressHashMode" is undefined');
        }
        if (this.signerAddress === undefined) {
            throw new Error('"signerAddress" is undefined');
        }
        if (this.signerAddress.hash160 === undefined) {
            throw new Error('"signerAddress.data" is undefined');
        }
        if (this.nonce === undefined) {
            throw new Error('"nonce" is undefined');
        }
        if (this.fee === undefined) {
            throw new Error('"fee" is undefined');
        }
        bufferArray.appendByte(this.addressHashMode);
        bufferArray.appendHexString(this.signerAddress.hash160);
        bufferArray.push(this.nonce.toArrayLike(Buffer, 'be', 8));
        bufferArray.push(this.fee.toArrayLike(Buffer, 'be', 8));
        if (this.addressHashMode === constants_1.AddressHashMode.SerializeP2PKH ||
            this.addressHashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
            if (this.pubKeyEncoding === undefined) {
                throw new Error('"pubKeyEncoding" is undefined');
            }
            bufferArray.appendByte(this.pubKeyEncoding);
            bufferArray.push(this.signature.serialize());
        }
        else if (this.addressHashMode === constants_1.AddressHashMode.SerializeP2SH ||
            this.addressHashMode === constants_1.AddressHashMode.SerializeP2WSH) {
            // TODO
            throw new Error(`Not yet implemented: serializing AddressHashMode: ${this.addressHashMode}`);
        }
        return bufferArray.concatBuffer();
    }
    deserialize(bufferReader) {
        this.addressHashMode = bufferReader.readUInt8Enum(constants_1.AddressHashMode, n => {
            throw new Error(`Could not parse ${n} as AddressHashMode`);
        });
        const signerPubKeyHash = bufferReader.readBuffer(20).toString('hex');
        this.signerAddress = types_1.addressFromVersionHash(0, signerPubKeyHash);
        this.nonce = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
        this.fee = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
        if (this.addressHashMode === constants_1.AddressHashMode.SerializeP2PKH ||
            this.addressHashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
            this.pubKeyEncoding = bufferReader.readUInt8Enum(constants_1.PubKeyEncoding, n => {
                throw new Error(`Could not parse ${n} as PubKeyEncoding`);
            });
            this.signature = MessageSignature.deserialize(bufferReader);
        }
        else if (this.addressHashMode === constants_1.AddressHashMode.SerializeP2SH ||
            this.addressHashMode === constants_1.AddressHashMode.SerializeP2WSH) {
            throw new Error('not implemented');
            // TODO
        }
    }
}
exports.SpendingCondition = SpendingCondition;
class SingleSigSpendingCondition extends SpendingCondition {
    constructor(addressHashMode, pubKey, nonce, fee) {
        super(addressHashMode, pubKey, nonce, fee);
        this.signaturesRequired = 1;
    }
    numSignatures() {
        return this.signature.toString() === MessageSignature.empty().toString() ? 0 : 1;
    }
}
exports.SingleSigSpendingCondition = SingleSigSpendingCondition;
class MultiSigSpendingCondition extends SpendingCondition {
}
exports.MultiSigSpendingCondition = MultiSigSpendingCondition;
class Authorization extends Deserializable {
    constructor(authType, spendingConditions) {
        super();
        this.authType = authType;
        this.spendingCondition = spendingConditions;
    }
    intoInitialSighashAuth() {
        var _a, _b;
        if (this.authType === constants_1.AuthType.Standard) {
            return new Authorization(constants_1.AuthType.Standard, (_a = this.spendingCondition) === null || _a === void 0 ? void 0 : _a.clear());
        }
        else {
            return new Authorization(constants_1.AuthType.Sponsored, (_b = this.spendingCondition) === null || _b === void 0 ? void 0 : _b.clear());
        }
    }
    serialize() {
        const bufferArray = new utils_1.BufferArray();
        if (this.authType === undefined) {
            throw new Error('"authType" is undefined');
        }
        bufferArray.appendByte(this.authType);
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                if (this.spendingCondition === undefined) {
                    throw new Error('"spendingCondition" is undefined');
                }
                bufferArray.push(this.spendingCondition.serialize());
                break;
            case constants_1.AuthType.Sponsored:
                // TODO
                throw new Error('Not yet implemented: serializing sponsored transactions');
            default:
                throw new Error(`Unexpected transaction AuthType while serializing: ${this.authType}`);
        }
        return bufferArray.concatBuffer();
    }
    deserialize(bufferReader) {
        this.authType = bufferReader.readUInt8Enum(constants_1.AuthType, n => {
            throw new Error(`Could not parse ${n} as AuthType`);
        });
        switch (this.authType) {
            case constants_1.AuthType.Standard:
                this.spendingCondition = SpendingCondition.deserialize(bufferReader);
                break;
            case constants_1.AuthType.Sponsored:
                // TODO
                throw new Error('Not yet implemented: deserializing sponsored transactions');
            default:
                throw new Error(`Unexpected transaction AuthType while deserializing: ${this.authType}`);
        }
    }
}
exports.Authorization = Authorization;
class StandardAuthorization extends Authorization {
    constructor(spendingCondition) {
        super(constants_1.AuthType.Standard, spendingCondition);
    }
}
exports.StandardAuthorization = StandardAuthorization;
class SponsoredAuthorization extends Authorization {
    constructor(spendingCondition) {
        super(constants_1.AuthType.Sponsored, spendingCondition);
    }
}
exports.SponsoredAuthorization = SponsoredAuthorization;
//# sourceMappingURL=authorization.js.map
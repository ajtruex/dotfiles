/// <reference types="node" />
import { AuthType, AddressHashMode, PubKeyEncoding } from './constants';
import { Address } from './types';
import { StacksPublicKey, StacksPrivateKey } from './keys';
import * as BigNum from 'bn.js';
import { BufferReader } from './bufferReader';
declare abstract class Deserializable {
    abstract serialize(): Buffer;
    abstract deserialize(bufferReader: BufferReader): void;
    static deserialize<T extends Deserializable>(this: new () => T, bufferReader: BufferReader): T;
}
export declare class MessageSignature extends Deserializable {
    signature?: string;
    constructor(signature?: string);
    static empty(): MessageSignature;
    toString(): string;
    serialize(): Buffer;
    deserialize(bufferReader: BufferReader): void;
}
export declare class SpendingCondition extends Deserializable {
    addressHashMode?: AddressHashMode;
    signerAddress?: Address;
    nonce?: BigNum;
    fee?: BigNum;
    pubKeyEncoding?: PubKeyEncoding;
    signature: MessageSignature;
    signaturesRequired?: number;
    constructor(addressHashMode?: AddressHashMode, pubKey?: string, nonce?: BigNum, fee?: BigNum);
    singleSig(): boolean;
    clear(): SpendingCondition;
    static makeSigHashPreSign(curSigHash: string, authType: AuthType, fee: BigNum, nonce: BigNum): string;
    static makeSigHashPostSign(curSigHash: string, publicKey: StacksPublicKey, signature: MessageSignature): string;
    static nextSignature(curSigHash: string, authType: AuthType, fee: BigNum, nonce: BigNum, privateKey: StacksPrivateKey): {
        nextSig: MessageSignature;
        nextSigHash: string;
    };
    numSignatures(): number;
    serialize(): Buffer;
    deserialize(bufferReader: BufferReader): void;
}
export declare class SingleSigSpendingCondition extends SpendingCondition {
    constructor(addressHashMode?: AddressHashMode, pubKey?: string, nonce?: BigNum, fee?: BigNum);
    numSignatures(): number;
}
export declare class MultiSigSpendingCondition extends SpendingCondition {
}
export declare class Authorization extends Deserializable {
    authType?: AuthType;
    spendingCondition?: SpendingCondition;
    constructor(authType?: AuthType, spendingConditions?: SpendingCondition);
    intoInitialSighashAuth(): Authorization;
    serialize(): Buffer;
    deserialize(bufferReader: BufferReader): void;
}
export declare class StandardAuthorization extends Authorization {
    constructor(spendingCondition: SpendingCondition);
}
export declare class SponsoredAuthorization extends Authorization {
    constructor(spendingCondition: SpendingCondition);
}
export {};

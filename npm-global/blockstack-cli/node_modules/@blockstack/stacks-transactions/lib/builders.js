"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const transaction_1 = require("./transaction");
const payload_1 = require("./payload");
const authorization_1 = require("./authorization");
const keys_1 = require("./keys");
const signer_1 = require("./signer");
const postcondition_1 = require("./postcondition");
const constants_1 = require("./constants");
const types_1 = require("./types");
const BigNum = require("bn.js");
/**
 * Generates a Stacks token transfer transaction
 *
 * Returns a signed Stacks token transfer transaction.
 *
 * @param  {String} recipientAddress - the c32check address of the recipient
 * @param  {BigNum} amount - number of tokens to transfer in microstacks
 * @param  {BigNum} fee - transaction fee in microstacks
 * @param  {String} senderKey - hex string sender private key used to sign transaction
 * @param  {TokenTransferOptions} options - an options object for the token transfer
 *
 * @return {StacksTransaction}
 */
function makeSTXTokenTransfer(recipient, amount, fee, senderKey, options) {
    const defaultOptions = {
        nonce: new BigNum(0),
        version: constants_1.DEFAULT_TRANSACTION_VERSION,
        chainId: constants_1.DEFAULT_CHAIN_ID,
        anchorMode: constants_1.AnchorMode.Any,
        postConditionMode: constants_1.PostConditionMode.Deny,
        memo: '',
    };
    const normalizedOptions = Object.assign(defaultOptions, options);
    const payload = payload_1.createTokenTransferPayload(recipient, amount, normalizedOptions.memo);
    const addressHashMode = constants_1.AddressHashMode.SerializeP2PKH;
    const privKey = keys_1.createStacksPrivateKey(senderKey);
    const pubKey = keys_1.getPublicKey(privKey);
    const spendingCondition = new authorization_1.SingleSigSpendingCondition(addressHashMode, keys_1.publicKeyToString(pubKey), normalizedOptions.nonce, fee);
    const authorization = new authorization_1.StandardAuthorization(spendingCondition);
    const postConditions = [];
    if (normalizedOptions.postConditions && normalizedOptions.postConditions.length > 0) {
        normalizedOptions.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = types_1.createLPList(postConditions);
    const transaction = new transaction_1.StacksTransaction(normalizedOptions.version, authorization, payload, lpPostConditions, normalizedOptions.postConditionMode, defaultOptions.anchorMode, normalizedOptions.chainId);
    const signer = new signer_1.TransactionSigner(transaction);
    signer.signOrigin(privKey);
    return transaction;
}
exports.makeSTXTokenTransfer = makeSTXTokenTransfer;
/**
 * Generates a Clarity smart contract deploy transaction
 *
 * Returns a signed Stacks smart contract deploy transaction.
 *
 * @param  {String} contractName - the contract name
 * @param  {String} codeBody - the code body string
 * @param  {BigNum} fee - transaction fee in microstacks
 * @param  {String} senderKey - hex string sender private key used to sign transaction
 *
 * @return {StacksTransaction}
 */
function makeSmartContractDeploy(contractName, codeBody, fee, senderKey, options) {
    const defaultOptions = {
        nonce: new BigNum(0),
        version: constants_1.DEFAULT_TRANSACTION_VERSION,
        chainId: constants_1.DEFAULT_CHAIN_ID,
        anchorMode: constants_1.AnchorMode.Any,
        postConditionMode: constants_1.PostConditionMode.Deny,
    };
    const normalizedOptions = Object.assign(defaultOptions, options);
    const payload = payload_1.createSmartContractPayload(contractName, codeBody);
    const addressHashMode = constants_1.AddressHashMode.SerializeP2PKH;
    const privKey = keys_1.createStacksPrivateKey(senderKey);
    const pubKey = keys_1.getPublicKey(privKey);
    const spendingCondition = new authorization_1.SingleSigSpendingCondition(addressHashMode, keys_1.publicKeyToString(pubKey), normalizedOptions.nonce, fee);
    const authorization = new authorization_1.StandardAuthorization(spendingCondition);
    const postConditions = [];
    if (normalizedOptions.postConditions && normalizedOptions.postConditions.length > 0) {
        normalizedOptions.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = types_1.createLPList(postConditions);
    const transaction = new transaction_1.StacksTransaction(normalizedOptions.version, authorization, payload, lpPostConditions, normalizedOptions.postConditionMode, normalizedOptions.anchorMode, normalizedOptions.chainId);
    const signer = new signer_1.TransactionSigner(transaction);
    signer.signOrigin(privKey);
    return transaction;
}
exports.makeSmartContractDeploy = makeSmartContractDeploy;
/**
 * Generates a Clarity smart contract function call transaction
 *
 * Returns a signed Stacks smart contract deploy transaction.
 *
 * @param  {String} contractAddress - the c32check address of the contract
 * @param  {String} contractName - the contract name
 * @param  {String} functionName - name of the function to be called
 * @param  {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call
 * @param  {BigNum} fee - transaction fee rate in microstacks
 * @param  {BigNum} nonce - a nonce must be increased monotonically with each new transaction
 * @param  {String} senderKey - hex string sender private key used to sign transaction
 * @param  {TransactionVersion} version - can be set to mainnet or testnet
 *
 * @return {StacksTransaction}
 */
function makeContractCall(contractAddress, contractName, functionName, functionArgs, fee, senderKey, options) {
    const defaultOptions = {
        nonce: new BigNum(0),
        version: constants_1.DEFAULT_TRANSACTION_VERSION,
        chainId: constants_1.DEFAULT_CHAIN_ID,
        anchorMode: constants_1.AnchorMode.Any,
        postConditionMode: constants_1.PostConditionMode.Deny,
    };
    const normalizedOptions = Object.assign(defaultOptions, options);
    const payload = payload_1.createContractCallPayload(contractAddress, contractName, functionName, functionArgs);
    const addressHashMode = constants_1.AddressHashMode.SerializeP2PKH;
    const privKey = keys_1.createStacksPrivateKey(senderKey);
    const pubKey = keys_1.getPublicKey(privKey);
    const spendingCondition = new authorization_1.SingleSigSpendingCondition(addressHashMode, keys_1.publicKeyToString(pubKey), normalizedOptions.nonce, fee);
    const authorization = new authorization_1.StandardAuthorization(spendingCondition);
    const postConditions = [];
    if (normalizedOptions.postConditions && normalizedOptions.postConditions.length > 0) {
        normalizedOptions.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = types_1.createLPList(postConditions);
    const transaction = new transaction_1.StacksTransaction(normalizedOptions.version, authorization, payload, lpPostConditions, normalizedOptions.postConditionMode, normalizedOptions.anchorMode, normalizedOptions.chainId);
    const signer = new signer_1.TransactionSigner(transaction);
    signer.signOrigin(privKey);
    return transaction;
}
exports.makeContractCall = makeContractCall;
/**
 * Generates a STX post condition with a standard principal
 *
 * Returns a STX post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of STX tokens
 *
 * @return {STXPostCondition}
 */
function makeStandardSTXPostCondition(address, conditionCode, amount) {
    return postcondition_1.createSTXPostCondition(types_1.createStandardPrincipal(address), conditionCode, amount);
}
exports.makeStandardSTXPostCondition = makeStandardSTXPostCondition;
/**
 * Generates a STX post condition with a contract principal
 *
 * Returns a STX post condition object
 *
 * @param  {String} address - the c32check address of the contract
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of STX tokens
 *
 * @return {STXPostCondition}
 */
function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
    return postcondition_1.createSTXPostCondition(types_1.createContractPrincipal(address, contractName), conditionCode, amount);
}
exports.makeContractSTXPostCondition = makeContractSTXPostCondition;
/**
 * Generates a fungible token post condition with a standard principal
 *
 * Returns a fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of fungible tokens
 * @param  {AssetInfo} assetInfo - asset info describing the fungible token
 *
 * @return {FungiblePostCondition}
 */
function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
    return postcondition_1.createFungiblePostCondition(types_1.createStandardPrincipal(address), conditionCode, amount, assetInfo);
}
exports.makeStandardFungiblePostCondition = makeStandardFungiblePostCondition;
/**
 * Generates a fungible token post condition with a contract principal
 *
 * Returns a fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {BigNum} amount - the amount of fungible tokens
 * @param  {AssetInfo} assetInfo - asset info describing the fungible token
 *
 * @return {FungiblePostCondition}
 */
function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
    return postcondition_1.createFungiblePostCondition(types_1.createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);
}
exports.makeContractFungiblePostCondition = makeContractFungiblePostCondition;
/**
 * Generates a non-fungible token post condition with a standard principal
 *
 * Returns a non-fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token
 *
 * @return {NonFungiblePostCondition}
 */
function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {
    return postcondition_1.createNonFungiblePostCondition(types_1.createStandardPrincipal(address), conditionCode, assetInfo, assetName);
}
exports.makeStandardNonFungiblePostCondition = makeStandardNonFungiblePostCondition;
/**
 * Generates a non-fungible token post condition with a contract principal
 *
 * Returns a non-fungible token post condition object
 *
 * @param  {String} address - the c32check address
 * @param  {String} contractName - the name of the contract
 * @param  {FungibleConditionCode} conditionCode - the condition code
 * @param  {AssetInfo} assetInfo - asset info describing the non-fungible token
 *
 * @return {NonFungiblePostCondition}
 */
function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {
    return postcondition_1.createNonFungiblePostCondition(types_1.createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);
}
exports.makeContractNonFungiblePostCondition = makeContractNonFungiblePostCondition;
//# sourceMappingURL=builders.js.map
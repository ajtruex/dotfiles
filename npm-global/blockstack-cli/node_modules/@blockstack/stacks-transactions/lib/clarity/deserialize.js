"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const bufferReader_1 = require("../bufferReader");
const types_1 = require("../types");
function deserializeCV(buffer) {
    const bufferReader = Buffer.isBuffer(buffer) ? new bufferReader_1.BufferReader(buffer) : buffer;
    const type = bufferReader.readUInt8Enum(_1.ClarityType, n => {
        throw new Error(`Cannot recognize Clarity Type: ${n}`);
    });
    switch (type) {
        case _1.ClarityType.Int:
            return _1.intCV(bufferReader.readBuffer(16));
        case _1.ClarityType.UInt:
            return _1.uintCV(bufferReader.readBuffer(16));
        case _1.ClarityType.Buffer:
            const bufferLength = bufferReader.readUInt32BE();
            return _1.bufferCV(bufferReader.readBuffer(bufferLength));
        case _1.ClarityType.BoolTrue:
            return _1.trueCV();
        case _1.ClarityType.BoolFalse:
            return _1.falseCV();
        case _1.ClarityType.PrincipalStandard:
            const sAddress = types_1.deserializeAddress(bufferReader);
            return _1.standardPrincipalCVFromAddress(sAddress);
        case _1.ClarityType.PrincipalContract:
            const cAddress = types_1.deserializeAddress(bufferReader);
            const contractName = types_1.deserializeLPString(bufferReader);
            return _1.contractPrincipalCVFromAddress(cAddress, contractName);
        case _1.ClarityType.ResponseOk:
            return _1.responseOkCV(deserializeCV(bufferReader));
        case _1.ClarityType.ResponseErr:
            return _1.responseErrorCV(deserializeCV(bufferReader));
        case _1.ClarityType.OptionalNone:
            return _1.noneCV();
        case _1.ClarityType.OptionalSome:
            return _1.someCV(deserializeCV(bufferReader));
        case _1.ClarityType.List:
            const listLength = bufferReader.readUInt32BE();
            const listContents = [];
            for (let i = 0; i < listLength; i++) {
                listContents.push(deserializeCV(bufferReader));
            }
            return _1.listCV(listContents);
        case _1.ClarityType.Tuple:
            const tupleLength = bufferReader.readUInt32BE();
            const tupleContents = {};
            for (let i = 0; i < tupleLength; i++) {
                const clarityName = types_1.deserializeLPString(bufferReader).content;
                if (clarityName === undefined) {
                    throw new Error('"content" is undefined');
                }
                tupleContents[clarityName] = deserializeCV(bufferReader);
            }
            return _1.tupleCV(tupleContents);
        default:
            throw new Error('Unable to deserialize Clarity Value from buffer. Could not find valid Clarity Type.');
    }
}
exports.default = deserializeCV;
//# sourceMappingURL=deserialize.js.map
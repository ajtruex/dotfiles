"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const elliptic_1 = require("elliptic");
const authorization_1 = require("./authorization");
function createStacksPublicKey(key) {
    return {
        type: constants_1.StacksMessageType.PublicKey,
        data: Buffer.from(key, 'hex'),
    };
}
exports.createStacksPublicKey = createStacksPublicKey;
function publicKeyFromBuffer(data) {
    return { type: constants_1.StacksMessageType.PublicKey, data };
}
exports.publicKeyFromBuffer = publicKeyFromBuffer;
function isCompressed(key) {
    return !key.data.toString('hex').startsWith('04');
}
exports.isCompressed = isCompressed;
function publicKeyToString(key) {
    return key.data.toString('hex');
}
exports.publicKeyToString = publicKeyToString;
function serializePublicKey(key) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.push(key.data);
    return bufferArray.concatBuffer();
}
exports.serializePublicKey = serializePublicKey;
function pubKeyfromPrivKey(privateKey) {
    const privKey = createStacksPrivateKey(privateKey);
    const ec = new elliptic_1.ec('secp256k1');
    const keyPair = ec.keyFromPrivate(privKey.data.toString('hex').slice(0, 64), 'hex');
    const pubKey = keyPair.getPublic(privKey.compressed, 'hex');
    return createStacksPublicKey(pubKey);
}
exports.pubKeyfromPrivKey = pubKeyfromPrivKey;
function deserializePublicKey(bufferReader) {
    const compressed = bufferReader.readUInt8() !== 4;
    bufferReader.readOffset = 0;
    const keyLength = compressed ? constants_1.COMPRESSED_PUBKEY_LENGTH_BYTES : constants_1.UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
    return publicKeyFromBuffer(bufferReader.readBuffer(keyLength + 1));
}
exports.deserializePublicKey = deserializePublicKey;
function createStacksPrivateKey(key) {
    let compressed;
    if (key.length === 66) {
        if (!key.endsWith('01')) {
            throw new Error('Improperly formatted private-key hex string. 66-length hex usually ' +
                'indicates compressed key, but last byte must be == 1');
        }
        compressed = true;
    }
    else if (key.length === 64) {
        compressed = false;
    }
    else {
        throw new Error(`Improperly formatted private-key hex string: length should be 64 or 66, provided with length ${key.length}`);
    }
    const data = Buffer.from(key, 'hex');
    return { data, compressed };
}
exports.createStacksPrivateKey = createStacksPrivateKey;
function makeRandomPrivKey() {
    const ec = new elliptic_1.ec('secp256k1');
    const options = { entropy: utils_1.randomBytes(32) };
    const keyPair = ec.genKeyPair(options);
    const privateKey = keyPair.getPrivate().toString('hex', 32);
    return createStacksPrivateKey(privateKey);
}
exports.makeRandomPrivKey = makeRandomPrivKey;
function signWithKey(privateKey, input) {
    const ec = new elliptic_1.ec('secp256k1');
    const key = ec.keyFromPrivate(privateKey.data.toString('hex').slice(0, 64), 'hex');
    const signature = key.sign(input, 'hex', { canonical: true });
    const coordinateValueBytes = 32;
    const r = utils_1.leftPadHexToLength(signature.r.toString('hex'), coordinateValueBytes * 2);
    const s = utils_1.leftPadHexToLength(signature.s.toString('hex'), coordinateValueBytes * 2);
    if (signature.recoveryParam === undefined || signature.recoveryParam === null) {
        throw new Error('"signature.recoveryParam" is not set');
    }
    const recoveryParam = utils_1.intToHexString(signature.recoveryParam, 1);
    const recoverableSignatureString = recoveryParam + r + s;
    const recoverableSignature = new authorization_1.MessageSignature(recoverableSignatureString);
    return recoverableSignature;
}
exports.signWithKey = signWithKey;
function getPublicKey(privateKey) {
    return pubKeyfromPrivKey(privateKey.data.toString('hex'));
}
exports.getPublicKey = getPublicKey;
function privateKeyToString(privateKey) {
    return privateKey.data.toString('hex');
}
exports.privateKeyToString = privateKeyToString;
//# sourceMappingURL=keys.js.map
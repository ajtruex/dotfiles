"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const smart_buffer_1 = require("smart-buffer");
function createEnumChecker(enumVariable) {
    // Create a set of valid enum number values.
    const enumValues = Object.values(enumVariable).filter(v => typeof v === 'number');
    const enumValueSet = new Set(enumValues);
    return (value) => enumValueSet.has(value);
}
const enumCheckFunctions = new Map();
/**
 * Type guard to check if a given value is a valid enum value.
 * @param enumVariable - Literal `enum` type.
 * @param value - A value to check against the enum's values.
 * @example
 * ```ts
 * enum Color {
 *   Purple = 3,
 *   Orange = 5
 * }
 * const val: number = 3;
 * if (isEnum(Color, val)) {
 *   // `val` is known as enum type `Color`, e.g.:
 *   const colorVal: Color = val;
 * }
 * ```
 */
function isEnum(enumVariable, value) {
    const checker = enumCheckFunctions.get(enumVariable);
    if (checker !== undefined) {
        return checker(value);
    }
    const newChecker = createEnumChecker(enumVariable);
    enumCheckFunctions.set(enumVariable, newChecker);
    return isEnum(enumVariable, value);
}
exports.isEnum = isEnum;
class BufferReader extends smart_buffer_1.SmartBuffer {
    static fromBuffer(buffer) {
        return new BufferReader({ buff: buffer });
    }
    constructor(options) {
        if (Buffer.isBuffer(options)) {
            super({ buff: options });
        }
        else {
            super(options);
        }
    }
    readBigUIntLE(length) {
        const buffer = Buffer.from(this.readBuffer(length)).reverse();
        const hex = buffer.toString('hex');
        const num = BigInt(`0x${hex}`);
        return num;
    }
    readBigUIntBE(length) {
        const buffer = this.readBuffer(length);
        const hex = buffer.toString('hex');
        const num = BigInt(`0x${hex}`);
        return num;
    }
    readUInt8Enum(enumVariable, invalidEnumErrorFormatter) {
        const num = this.readUInt8();
        if (isEnum(enumVariable, num)) {
            return num;
        }
        else {
            throw invalidEnumErrorFormatter(num);
        }
    }
}
exports.BufferReader = BufferReader;
//# sourceMappingURL=bufferReader.js.map
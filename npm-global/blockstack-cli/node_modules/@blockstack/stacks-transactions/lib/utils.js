"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const sha_js_1 = require("sha.js");
const RIPEMD160 = require("ripemd160");
const randombytes = require("randombytes");
exports.randomBytes = randombytes;
// eslint-disable-next-line import/no-unassigned-import
require("cross-fetch/polyfill");
class BufferArray extends Array {
    appendHexString(hexString) {
        this.push(Buffer.from(hexString, 'hex'));
    }
    appendByte(octet) {
        if (!Number.isInteger(octet) || octet < 0 || octet > 255) {
            throw new Error(`Value ${octet} is not a valid byte`);
        }
        this.push(Buffer.from([octet]));
    }
    concatBuffer() {
        return Buffer.concat(this);
    }
}
exports.BufferArray = BufferArray;
class BufferReader {
    constructor(buffer) {
        this.buffer = buffer;
        this.index = 0;
    }
    read(bytes, incrementIndex = true) {
        const readBuffer = Buffer.alloc(bytes);
        this.buffer.copy(readBuffer, 0, this.index, this.index + bytes);
        if (incrementIndex) {
            this.index += bytes;
        }
        return readBuffer;
    }
    readByte(incrementIndex = true) {
        const val = this.buffer[this.index];
        if (incrementIndex) {
            this.index += 1;
        }
        return val;
    }
    setIndex(index) {
        this.index = index;
    }
}
exports.BufferReader = BufferReader;
exports.leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;
exports.leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');
exports.rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');
// export const bigIntToHexString = (integer: BigInt, lengthBytes: number = 8): string =>
//   integer.toString(16).padStart(lengthBytes * 2, '0');
// export const hexStringToBigInt = (hexString: string): BigInt => BigInt("0x" + hexString);
exports.intToHexString = (integer, lengthBytes = 8) => integer.toString(16).padStart(lengthBytes * 2, '0');
exports.hexStringToInt = (hexString) => parseInt(hexString, 16);
exports.exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? Buffer.from(string).length > maxLengthBytes : false;
class sha512_256 extends sha_js_1.sha512 {
    constructor() {
        super();
        // set the "SHA-512/256" initialization vector
        // see https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
        Object.assign(this, {
            _ah: 0x22312194,
            _al: 0xfc2bf72c,
            _bh: 0x9f555fa3,
            _bl: 0xc84c64c2,
            _ch: 0x2393b86b,
            _cl: 0x6f53b151,
            _dh: 0x96387719,
            _dl: 0x5940eabd,
            _eh: 0x96283ee2,
            _el: 0xa88effe3,
            _fh: 0xbe5e1e25,
            _fl: 0x53863992,
            _gh: 0x2b0199fc,
            _gl: 0x2c85b8aa,
            _hh: 0x0eb72ddc,
            _hl: 0x81c52ca2,
        });
    }
    digest(encoding) {
        // "SHA-512/256" truncates the digest to 32 bytes
        const buff = super.digest().slice(0, 32);
        return encoding ? buff.toString(encoding) : buff;
    }
}
exports.sha512_256 = sha512_256;
exports.txidFromData = (data) => new sha512_256().update(data).digest('hex');
exports.hash160 = (input) => {
    const inputBuffer = Buffer.from(input, 'hex');
    const sha256Result = new sha_js_1.sha256().update(inputBuffer).digest('hex');
    return new RIPEMD160().update(Buffer.from(sha256Result, 'hex')).digest('hex');
};
exports.hash_p2pkh = (input) => {
    return exports.hash160(input);
};
function isClarityName(name) {
    const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
    return regex.test(name) && name.length < 128;
}
exports.isClarityName = isClarityName;
/** @ignore */
function fetchPrivate(input, init) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultFetchOpts = {
            referrer: 'no-referrer',
            referrerPolicy: 'no-referrer',
        };
        const fetchOpts = Object.assign(defaultFetchOpts, init);
        // eslint-disable-next-line no-restricted-globals
        const fetchResult = yield fetch(input, fetchOpts);
        return fetchResult;
    });
}
exports.fetchPrivate = fetchPrivate;
//# sourceMappingURL=utils.js.map
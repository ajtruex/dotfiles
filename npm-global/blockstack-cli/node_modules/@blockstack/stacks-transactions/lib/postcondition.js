"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const types_1 = require("./types");
const BigNum = require("bn.js");
const clarity_1 = require("./clarity");
function createSTXPostCondition(principal, conditionCode, amount) {
    if (typeof principal === 'string') {
        principal = types_1.parsePrincipalString(principal);
    }
    return {
        type: constants_1.StacksMessageType.PostCondition,
        conditionType: constants_1.PostConditionType.STX,
        principal,
        conditionCode,
        amount,
    };
}
exports.createSTXPostCondition = createSTXPostCondition;
function createFungiblePostCondition(principal, conditionCode, amount, assetInfo) {
    if (typeof principal === 'string') {
        principal = types_1.parsePrincipalString(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = types_1.parseAssetInfoString(assetInfo);
    }
    return {
        type: constants_1.StacksMessageType.PostCondition,
        conditionType: constants_1.PostConditionType.Fungible,
        principal,
        conditionCode,
        amount,
        assetInfo,
    };
}
exports.createFungiblePostCondition = createFungiblePostCondition;
function createNonFungiblePostCondition(principal, conditionCode, assetInfo, assetName) {
    if (typeof principal === 'string') {
        principal = types_1.parsePrincipalString(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = types_1.parseAssetInfoString(assetInfo);
    }
    return {
        type: constants_1.StacksMessageType.PostCondition,
        conditionType: constants_1.PostConditionType.NonFungible,
        principal,
        conditionCode,
        assetInfo,
        assetName,
    };
}
exports.createNonFungiblePostCondition = createNonFungiblePostCondition;
function serializePostCondition(postCondition) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendByte(postCondition.conditionType);
    bufferArray.push(types_1.serializePrincipal(postCondition.principal));
    if (postCondition.conditionType === constants_1.PostConditionType.Fungible ||
        postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bufferArray.push(types_1.serializeAssetInfo(postCondition.assetInfo));
    }
    if (postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bufferArray.push(clarity_1.serializeCV(postCondition.assetName));
    }
    bufferArray.appendByte(postCondition.conditionCode);
    if (postCondition.conditionType === constants_1.PostConditionType.STX ||
        postCondition.conditionType === constants_1.PostConditionType.Fungible) {
        bufferArray.push(postCondition.amount.toArrayLike(Buffer, 'be', 8));
    }
    return bufferArray.concatBuffer();
}
exports.serializePostCondition = serializePostCondition;
function deserializePostCondition(bufferReader) {
    const postConditionType = bufferReader.readUInt8Enum(constants_1.PostConditionType, n => {
        throw new Error(`Could not read ${n} as PostConditionType`);
    });
    const principal = types_1.deserializePrincipal(bufferReader);
    let conditionCode;
    let assetInfo;
    let amount;
    switch (postConditionType) {
        case constants_1.PostConditionType.STX:
            conditionCode = bufferReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new Error(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.STX,
                principal,
                conditionCode,
                amount,
            };
        case constants_1.PostConditionType.Fungible:
            assetInfo = types_1.deserializeAssetInfo(bufferReader);
            conditionCode = bufferReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new Error(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = new BigNum(bufferReader.readBuffer(8).toString('hex'), 16);
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.Fungible,
                principal,
                conditionCode,
                amount,
                assetInfo,
            };
        case constants_1.PostConditionType.NonFungible:
            assetInfo = types_1.deserializeAssetInfo(bufferReader);
            const assetName = clarity_1.deserializeCV(bufferReader);
            conditionCode = bufferReader.readUInt8Enum(constants_1.NonFungibleConditionCode, n => {
                throw new Error(`Could not read ${n} as FungibleConditionCode`);
            });
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.NonFungible,
                principal,
                conditionCode,
                assetInfo,
                assetName,
            };
    }
}
exports.deserializePostCondition = deserializePostCondition;
//# sourceMappingURL=postcondition.js.map
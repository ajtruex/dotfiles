"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const constants_1 = require("./constants");
const authorization_1 = require("./authorization");
const utils_1 = require("./utils");
const payload_1 = require("./payload");
const types_1 = require("./types");
class StacksTransaction {
    constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {
        this.version = version;
        this.auth = auth;
        this.payload = payload;
        this.chainId = (chainId !== null && chainId !== void 0 ? chainId : constants_1.DEFAULT_CHAIN_ID);
        this.postConditionMode = (postConditionMode !== null && postConditionMode !== void 0 ? postConditionMode : constants_1.PostConditionMode.Deny);
        this.postConditions = (postConditions !== null && postConditions !== void 0 ? postConditions : types_1.createLPList([]));
        if (anchorMode) {
            this.anchorMode = anchorMode;
        }
        else {
            switch (payload.payloadType) {
                case constants_1.PayloadType.Coinbase:
                case constants_1.PayloadType.PoisonMicroblock: {
                    this.anchorMode = constants_1.AnchorMode.OnChainOnly;
                    break;
                }
                case constants_1.PayloadType.ContractCall:
                case constants_1.PayloadType.SmartContract:
                case constants_1.PayloadType.TokenTransfer: {
                    this.anchorMode = constants_1.AnchorMode.Any;
                    break;
                }
            }
        }
    }
    signBegin() {
        const tx = _.cloneDeep(this);
        tx.auth = tx.auth.intoInitialSighashAuth();
        return tx.txid();
    }
    signNextOrigin(sigHash, privateKey) {
        if (this.auth.spendingCondition === undefined) {
            throw new Error('"auth.spendingCondition" is undefined');
        }
        if (this.auth.authType === undefined) {
            throw new Error('"auth.authType" is undefined');
        }
        return this.signAndAppend(this.auth.spendingCondition, sigHash, this.auth.authType, privateKey);
    }
    signAndAppend(condition, curSigHash, authType, privateKey) {
        if (condition.fee === undefined) {
            throw new Error('"condition.fee" is undefined');
        }
        if (condition.nonce === undefined) {
            throw new Error('"condition.nonce" is undefined');
        }
        const { nextSig, nextSigHash } = authorization_1.SpendingCondition.nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);
        if (condition.singleSig()) {
            condition.signature = nextSig;
        }
        else {
            // condition.pushSignature();
        }
        return nextSigHash;
    }
    txid() {
        const serialized = this.serialize();
        return utils_1.txidFromData(serialized);
    }
    serialize() {
        if (this.version === undefined) {
            throw new Error('"version" is undefined');
        }
        if (this.chainId === undefined) {
            throw new Error('"chainId" is undefined');
        }
        if (this.auth === undefined) {
            throw new Error('"auth" is undefined');
        }
        if (this.anchorMode === undefined) {
            throw new Error('"anchorMode" is undefined');
        }
        if (this.payload === undefined) {
            throw new Error('"payload" is undefined');
        }
        const bufferArray = new utils_1.BufferArray();
        bufferArray.appendByte(this.version);
        const chainIdBuffer = Buffer.alloc(4);
        chainIdBuffer.writeUInt32BE(this.chainId, 0);
        bufferArray.push(chainIdBuffer);
        bufferArray.push(this.auth.serialize());
        bufferArray.appendByte(this.anchorMode);
        bufferArray.appendByte(this.postConditionMode);
        bufferArray.push(types_1.serializeLPList(this.postConditions));
        bufferArray.push(payload_1.serializePayload(this.payload));
        return bufferArray.concatBuffer();
    }
    /**
     * Broadcast the signed transaction to a core node
     *
     * @param {String} apiUrl - specify the core node URL to broadcast to
     *
     * @returns {Promise} that resolves to a response if the operation succeeds
     */
    broadcast(apiUrl) {
        const tx = this.serialize();
        const requestHeaders = {
            'Content-Type': 'application/octet-stream',
        };
        const options = {
            method: 'POST',
            headers: requestHeaders,
            body: tx,
        };
        const url = apiUrl || `${constants_1.DEFAULT_CORE_NODE_API_URL}/v2/transactions`;
        return utils_1.fetchPrivate(url, options).then(response => {
            if (response.ok) {
                return response.text();
            }
            else {
                return response.text();
            }
        });
    }
}
exports.StacksTransaction = StacksTransaction;
function deserializeTransaction(bufferReader) {
    const version = bufferReader.readUInt8Enum(constants_1.TransactionVersion, n => {
        throw new Error(`Could not parse ${n} as TransactionVersion`);
    });
    const chainId = bufferReader.readUInt32BE();
    const auth = authorization_1.Authorization.deserialize(bufferReader);
    const anchorMode = bufferReader.readUInt8Enum(constants_1.AnchorMode, n => {
        throw new Error(`Could not parse ${n} as AnchorMode`);
    });
    const postConditionMode = bufferReader.readUInt8Enum(constants_1.PostConditionMode, n => {
        throw new Error(`Could not parse ${n} as PostConditionMode`);
    });
    const postConditions = types_1.deserializeLPList(bufferReader, constants_1.StacksMessageType.PostCondition);
    const payload = payload_1.deserializePayload(bufferReader);
    return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);
}
exports.deserializeTransaction = deserializeTransaction;
//# sourceMappingURL=transaction.js.map
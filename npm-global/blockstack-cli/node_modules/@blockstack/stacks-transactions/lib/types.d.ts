/// <reference types="node" />
import { AddressHashMode, AddressVersion, TransactionVersion, StacksMessageType, PostConditionPrincipalID } from './constants';
import { StacksPublicKey } from './keys';
import { BufferReader } from './bufferReader';
import { PostCondition } from './postcondition';
import { Payload } from './payload';
export declare type StacksMessage = Address | PostConditionPrincipal | LengthPrefixedString | LengthPrefixedList | Payload | MemoString | AssetInfo | PostCondition | StacksPublicKey;
export declare function serializeStacksMessage(message: StacksMessage): Buffer;
export declare function deserializeStacksMessage(bufferReader: BufferReader, type: StacksMessageType, listType?: StacksMessageType): StacksMessage;
export interface Address {
    readonly type: StacksMessageType.Address;
    readonly version: AddressVersion;
    readonly hash160: string;
}
export declare function createAddress(c32AddressString: string): Address;
export declare function addressFromVersionHash(version: AddressVersion, hash: string): Address;
/**
 * Translates the tx auth hash mode to the corresponding address version.
 * @see https://github.com/blockstack/stacks-blockchain/blob/master/sip/sip-005-blocks-and-transactions.md#transaction-authorization
 */
export declare function addressHashModeToVersion(hashMode: AddressHashMode, txVersion: TransactionVersion): AddressVersion;
export declare function addressFromHashMode(hashMode: AddressHashMode, txVersion: TransactionVersion, data: string): Address;
export declare function addressFromPublicKeys(version: AddressVersion, hashMode: AddressHashMode, numSigs: number, publicKeys: Array<StacksPublicKey>): Address;
export declare function addressToString(address: Address): string;
export declare function serializeAddress(address: Address): Buffer;
export declare function deserializeAddress(bufferReader: BufferReader): Address;
export declare type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;
export interface StandardPrincipal {
    readonly type: StacksMessageType.Principal;
    readonly prefix: PostConditionPrincipalID.Standard;
    readonly address: Address;
}
export interface ContractPrincipal {
    readonly type: StacksMessageType.Principal;
    readonly prefix: PostConditionPrincipalID.Contract;
    readonly address: Address;
    readonly contractName: LengthPrefixedString;
}
/**
 * Parses a principal string for either a standard principal or contract principal.
 * @param principalString - String in the format `{address}.{contractName}`
 * @example "SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract"
 * @example "SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G"
 */
export declare function parsePrincipalString(principalString: string): StandardPrincipal | ContractPrincipal;
export declare function createStandardPrincipal(addressString: string): StandardPrincipal;
export declare function createContractPrincipal(addressString: string, contractName: string): ContractPrincipal;
export declare function serializePrincipal(principal: PostConditionPrincipal): Buffer;
export declare function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal;
export interface LengthPrefixedString {
    readonly type: StacksMessageType.LengthPrefixedString;
    readonly content: string;
    readonly lengthPrefixBytes: number;
    readonly maxLengthBytes: number;
}
export declare function createLPString(content: string): LengthPrefixedString;
export declare function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;
export declare function createLPString(content: string, lengthPrefixBytes: number, maxLengthBytes: number): LengthPrefixedString;
export declare function serializeLPString(lps: LengthPrefixedString): Buffer;
export declare function deserializeLPString(bufferReader: BufferReader, prefixBytes?: number, maxLength?: number): LengthPrefixedString;
export declare function codeBodyString(content: string): LengthPrefixedString;
export interface MemoString {
    readonly type: StacksMessageType.MemoString;
    readonly content: string;
}
export declare function createMemoString(content: string): MemoString;
export declare function serializeMemoString(memoString: MemoString): Buffer;
export declare function deserializeMemoString(bufferReader: BufferReader): MemoString;
export interface AssetInfo {
    readonly type: StacksMessageType.AssetInfo;
    readonly address: Address;
    readonly contractName: LengthPrefixedString;
    readonly assetName: LengthPrefixedString;
}
/**
 * Parse a fully qualified string that identifies the token type.
 * @param id - String in the format `{address}.{contractName}::{assetName}`
 * @example "SP13N5TE1FBBGRZD1FCM49QDGN32WAXM2E5F8WT2G.example-contract::example-token"
 */
export declare function parseAssetInfoString(id: string): AssetInfo;
export declare function createAssetInfo(addressString: string, contractName: string, assetName: string): AssetInfo;
export declare function serializeAssetInfo(info: AssetInfo): Buffer;
export declare function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo;
export interface LengthPrefixedList {
    readonly type: StacksMessageType.LengthPrefixedList;
    readonly lengthPrefixBytes: number;
    readonly values: StacksMessage[];
}
export declare function createLPList<T extends StacksMessage>(values: T[], lengthPrefixBytes?: number): LengthPrefixedList;
export declare function serializeLPList(lpList: LengthPrefixedList): Buffer;
export declare function deserializeLPList(bufferReader: BufferReader, type: StacksMessageType, lengthPrefixBytes?: number): LengthPrefixedList;

/// <reference types="node" />
import { TransactionVersion, AnchorMode, PostConditionMode, AuthType, ChainID } from './constants';
import { Authorization, SpendingCondition } from './authorization';
import { Payload } from './payload';
import { LengthPrefixedList } from './types';
import { StacksPrivateKey } from './keys';
import { BufferReader } from './bufferReader';
export declare class StacksTransaction {
    version: TransactionVersion;
    chainId: ChainID;
    auth: Authorization;
    anchorMode: AnchorMode;
    payload: Payload;
    postConditionMode: PostConditionMode;
    postConditions: LengthPrefixedList;
    constructor(version: TransactionVersion, auth: Authorization, payload: Payload, postConditions?: LengthPrefixedList, postConditionMode?: PostConditionMode, anchorMode?: AnchorMode, chainId?: ChainID);
    signBegin(): string;
    signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): string;
    signAndAppend(condition: SpendingCondition, curSigHash: string, authType: AuthType, privateKey: StacksPrivateKey): string;
    txid(): string;
    serialize(): Buffer;
    /**
     * Broadcast the signed transaction to a core node
     *
     * @param {String} apiUrl - specify the core node URL to broadcast to
     *
     * @returns {Promise} that resolves to a response if the operation succeeds
     */
    broadcast(apiUrl?: string): Promise<string>;
}
export declare function deserializeTransaction(bufferReader: BufferReader): StacksTransaction;

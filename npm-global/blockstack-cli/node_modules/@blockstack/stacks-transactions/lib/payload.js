"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const types_1 = require("./types");
const clarity_1 = require("./clarity/");
const BigNum = require("bn.js");
const principalCV_1 = require("./clarity/types/principalCV");
function createTokenTransferPayload(recipient, amount, memo) {
    if (typeof recipient === 'string') {
        recipient = principalCV_1.principalCV(recipient);
    }
    if (typeof memo === 'string') {
        memo = types_1.createMemoString(memo);
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.TokenTransfer,
        recipient,
        amount,
        memo: (memo !== null && memo !== void 0 ? memo : types_1.createMemoString('')),
    };
}
exports.createTokenTransferPayload = createTokenTransferPayload;
function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {
    if (typeof contractAddress === 'string') {
        contractAddress = types_1.createAddress(contractAddress);
    }
    if (typeof contractName === 'string') {
        contractName = types_1.createLPString(contractName);
    }
    if (typeof functionName === 'string') {
        functionName = types_1.createLPString(functionName);
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.ContractCall,
        contractAddress,
        contractName,
        functionName,
        functionArgs,
    };
}
exports.createContractCallPayload = createContractCallPayload;
function createSmartContractPayload(contractName, codeBody) {
    if (typeof contractName === 'string') {
        contractName = types_1.createLPString(contractName);
    }
    if (typeof codeBody === 'string') {
        codeBody = types_1.codeBodyString(codeBody);
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.SmartContract,
        contractName,
        codeBody,
    };
}
exports.createSmartContractPayload = createSmartContractPayload;
function createPoisonPayload() {
    return { type: constants_1.StacksMessageType.Payload, payloadType: constants_1.PayloadType.PoisonMicroblock };
}
exports.createPoisonPayload = createPoisonPayload;
function createCoinbasePayload(coinbaseBuffer) {
    if (coinbaseBuffer.byteLength != constants_1.COINBASE_BUFFER_LENGTH_BYTES) {
        throw Error(`Coinbase buffer size must be ${constants_1.COINBASE_BUFFER_LENGTH_BYTES} bytes`);
    }
    return { type: constants_1.StacksMessageType.Payload, payloadType: constants_1.PayloadType.Coinbase, coinbaseBuffer };
}
exports.createCoinbasePayload = createCoinbasePayload;
function serializePayload(payload) {
    const bufferArray = new utils_1.BufferArray();
    bufferArray.appendByte(payload.payloadType);
    switch (payload.payloadType) {
        case constants_1.PayloadType.TokenTransfer:
            bufferArray.push(clarity_1.serializeCV(payload.recipient));
            bufferArray.push(payload.amount.toArrayLike(Buffer, 'be', 8));
            bufferArray.push(types_1.serializeStacksMessage(payload.memo));
            break;
        case constants_1.PayloadType.ContractCall:
            bufferArray.push(types_1.serializeStacksMessage(payload.contractAddress));
            bufferArray.push(types_1.serializeStacksMessage(payload.contractName));
            bufferArray.push(types_1.serializeStacksMessage(payload.functionName));
            const numArgs = Buffer.alloc(4);
            numArgs.writeUInt32BE(payload.functionArgs.length, 0);
            bufferArray.push(numArgs);
            payload.functionArgs.forEach(arg => {
                bufferArray.push(clarity_1.serializeCV(arg));
            });
            break;
        case constants_1.PayloadType.SmartContract:
            bufferArray.push(types_1.serializeStacksMessage(payload.contractName));
            bufferArray.push(types_1.serializeStacksMessage(payload.codeBody));
            break;
        case constants_1.PayloadType.PoisonMicroblock:
            // TODO: implement
            break;
        case constants_1.PayloadType.Coinbase:
            bufferArray.push(payload.coinbaseBuffer);
            break;
    }
    return bufferArray.concatBuffer();
}
exports.serializePayload = serializePayload;
function deserializePayload(bufferReader) {
    const payloadType = bufferReader.readUInt8Enum(constants_1.PayloadType, n => {
        throw new Error(`Cannot recognize PayloadType: ${n}`);
    });
    switch (payloadType) {
        case constants_1.PayloadType.TokenTransfer:
            const recipient = clarity_1.deserializeCV(bufferReader);
            const amount = new BigNum(bufferReader.readBuffer(8));
            const memo = types_1.deserializeMemoString(bufferReader);
            return createTokenTransferPayload(recipient, amount, memo);
        case constants_1.PayloadType.ContractCall:
            const contractAddress = types_1.deserializeAddress(bufferReader);
            const contractCallName = types_1.deserializeLPString(bufferReader);
            const functionName = types_1.deserializeLPString(bufferReader);
            const functionArgs = [];
            const numberOfArgs = bufferReader.readUInt32BE();
            for (let i = 0; i < numberOfArgs; i++) {
                const clarityValue = clarity_1.deserializeCV(bufferReader);
                functionArgs.push(clarityValue);
            }
            return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);
        case constants_1.PayloadType.SmartContract:
            const smartContractName = types_1.deserializeLPString(bufferReader);
            const codeBody = types_1.deserializeLPString(bufferReader, 4, 100000);
            return createSmartContractPayload(smartContractName, codeBody);
        case constants_1.PayloadType.PoisonMicroblock:
            // TODO: implement
            return createPoisonPayload();
        case constants_1.PayloadType.Coinbase:
            const coinbaseBuffer = bufferReader.readBuffer(constants_1.COINBASE_BUFFER_LENGTH_BYTES);
            return createCoinbasePayload(coinbaseBuffer);
    }
}
exports.deserializePayload = deserializePayload;
//# sourceMappingURL=payload.js.map
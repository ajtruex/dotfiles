{"version":3,"sources":["../../../../../src/commands/upload/submission-service/utils/files.ts"],"names":["pipeline","stream","moveFileOfTypeAsync","directory","extension","dest","matching","absolute","cwd","Error","matchingExtension","toLowerCase","destExtension","fs","move","createDownloadStream","url","got","on","pathIsTar","path","endsWith","downloadAppArchiveAsync","filename","destinationFolder","temporary","destinationPath","downloadStream","tar","extract","createWriteStream","uploadAppArchiveAsync","fileSize","stat","size","UploadType","SUBMISSION_APP_ARCHIVE","decompressTarAsync","src","destination","createReadStream","extractLocalArchiveAsync","filePath"],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport { sync as globSync } from 'glob';\nimport got from 'got';\nimport Request from 'got/dist/source/core';\nimport { basename, extname, join } from 'path';\nimport stream from 'stream';\nimport tar from 'tar';\nimport temporary from 'tempy';\nimport { promisify } from 'util';\n\nimport { uploadAsync, UploadType } from '../../../../uploads';\nimport { createProgressTracker } from '../../../utils/progress';\n\nconst pipeline = promisify(stream.pipeline);\n\nasync function moveFileOfTypeAsync(\n  directory: string,\n  extension: string,\n  dest: string\n): Promise<string> {\n  const [matching] = globSync(`*.${extension}`, {\n    absolute: true,\n    cwd: directory,\n  });\n\n  if (!matching) {\n    throw new Error(`No .${extension} files found in directory: ${directory}`);\n  }\n\n  // The incoming destination may be tar.gz because it wasn't clear what type of app file was included.\n  // Compare the app file extension with the destination extension and if they don't match,\n  // append the app file extension to the destination. Ex. App.tar.gz.ipa\n  const matchingExtension = extname(matching).toLowerCase();\n  const destExtension = extname(dest).toLowerCase();\n\n  if (matchingExtension !== destExtension) {\n    dest = `${dest}${matchingExtension}`;\n  }\n\n  // Ensure we actually need to move the file.\n  if (matching !== dest) {\n    await fs.move(matching, dest);\n  }\n\n  return dest;\n}\n\nfunction createDownloadStream(url: string): Request {\n  return got.stream(url).on('downloadProgress', createProgressTracker());\n}\n\nfunction pathIsTar(path: string): boolean {\n  return path.endsWith('tar.gz');\n}\n\nasync function downloadAppArchiveAsync(url: string): Promise<string> {\n  const filename = basename(url);\n  // Since we may need to rename the destination path,\n  // add everything to a folder which can be nuked to ensure we don't accidentally use an old build with the same name.\n  const destinationFolder = temporary.directory();\n  const destinationPath = join(destinationFolder, filename);\n\n  const downloadStream = createDownloadStream(url);\n  // Special use-case for downloading an EAS tar.gz file and unpackaging it.\n  if (pathIsTar(url)) {\n    await pipeline(downloadStream, tar.extract({ cwd: destinationFolder }, []));\n    // Move the folder contents matching .ipa, .apk, or .aab\n    return await moveFileOfTypeAsync(destinationFolder, '{ipa,apk,aab}', destinationPath);\n  } else {\n    await pipeline(downloadStream, fs.createWriteStream(destinationPath));\n  }\n  return destinationPath;\n}\n\nasync function uploadAppArchiveAsync(path: string): Promise<string> {\n  const fileSize = (await fs.stat(path)).size;\n  return await uploadAsync(\n    UploadType.SUBMISSION_APP_ARCHIVE,\n    path,\n    createProgressTracker(fileSize)\n  );\n}\n\nasync function decompressTarAsync(src: string, destination: string): Promise<void> {\n  await pipeline(fs.createReadStream(src), tar.extract({ cwd: destination }, []));\n}\n\nasync function extractLocalArchiveAsync(filePath: string): Promise<string> {\n  if (!pathIsTar(filePath)) {\n    // No need to extract, copy, or rename the file.\n    // Leave it in place and return the path.\n    return filePath;\n  }\n\n  const filename = basename(filePath);\n  // Since we may need to rename the destination path,\n  // add everything to a folder which can be nuked to ensure we don't accidentally use an old build with the same name.\n  const destinationFolder = temporary.directory();\n  const destinationPath = join(destinationFolder, filename);\n\n  // Special use-case for downloading an EAS tar.gz file and unpackaging it.\n  await decompressTarAsync(filePath, destinationFolder);\n  // Move the folder contents matching .ipa, .apk, or .aab\n  return await moveFileOfTypeAsync(destinationFolder, '{ipa,apk,aab}', destinationPath);\n}\n\nexport {\n  createDownloadStream,\n  downloadAppArchiveAsync,\n  extractLocalArchiveAsync,\n  pathIsTar,\n  uploadAppArchiveAsync,\n};\n"],"file":"files.js"}
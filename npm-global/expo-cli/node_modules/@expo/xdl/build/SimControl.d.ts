import { SpawnOptions } from '@expo/spawn-async';
declare type DeviceState = 'Shutdown' | 'Booted';
export declare type Device = {
    availabilityError: 'runtime profile not found';
    /**
     * '/Users/name/Library/Developer/CoreSimulator/Devices/00E55DC0-0364-49DF-9EC6-77BE587137D4/data'
     */
    dataPath: string;
    /**
     * '/Users/name/Library/Logs/CoreSimulator/00E55DC0-0364-49DF-9EC6-77BE587137D4'
     */
    logPath: string;
    /**
     * '00E55DC0-0364-49DF-9EC6-77BE587137D4'
     */
    udid: string;
    /**
     * com.apple.CoreSimulator.SimRuntime.tvOS-13-4
     */
    runtime: string;
    isAvailable: boolean;
    /**
     * 'com.apple.CoreSimulator.SimDeviceType.Apple-TV-1080p'
     */
    deviceTypeIdentifier: string;
    state: DeviceState;
    /**
     * 'Apple TV'
     */
    name: string;
    osType: OSType;
    /**
     * '13.4'
     */
    osVersion: string;
    /**
     * 'iPhone 11 (13.6)'
     */
    windowName: string;
};
declare type OSType = 'iOS' | 'tvOS' | 'watchOS';
declare type PermissionName = 'all' | 'calendar' | 'contacts-limited' | 'contacts' | 'location' | 'location-always' | 'photos-add' | 'photos' | 'media-library' | 'microphone' | 'motion' | 'reminders' | 'siri';
declare type SimulatorDeviceList = {
    devices: {
        [runtime: string]: Device[];
    };
};
export declare function isSimulatorRunningAsync(): Promise<boolean>;
export declare function getDefaultSimulatorDeviceUDIDAsync(): Promise<string | null>;
/**
 * Returns the local path for the installed tar.app. Returns null when the app isn't installed.
 *
 * @param udid
 * @param bundleIdentifier
 */
export declare function getContainerPathAsync(udid: string, bundleIdentifier: string): Promise<string | null>;
export declare function openURLAsync(options: {
    udid?: string;
    url: string;
}): Promise<any>;
export declare function bootAsync({ udid }: {
    udid: string;
}): Promise<Device | null>;
export declare function getBootedSimulatorsAsync(): Promise<Device[]>;
export declare function isSimulatorBootedAsync({ udid }: {
    udid?: string;
}): Promise<Device | null>;
export declare function installAsync(options: {
    udid: string;
    dir: string;
}): Promise<any>;
export declare function uninstallAsync(options: {
    udid?: string;
    bundleIdentifier: string;
}): Promise<any>;
export declare function listAsync(type: 'devices' | 'devicetypes' | 'runtimes' | 'pairs', query?: string | 'available'): Promise<SimulatorDeviceList>;
export declare function shutdownAsync(udid?: string): Promise<any>;
export declare function updatePermissionsAsync(udid: string, action: 'grant' | 'revoke' | 'reset', permission: PermissionName, bundleIdentifier?: string): Promise<any>;
export declare function setAppearanceAsync(udid: string, theme: 'light' | 'dark'): Promise<any>;
export declare function eraseAsync(udid: string): Promise<any>;
export declare function eraseAllAsync(): Promise<any>;
export declare function addMediaAsync(udid: string, mediaPath: string): Promise<any>;
export declare function captureScreenAsync(udid: string, captureType: 'screenshot' | 'recordVideo', outputFilePath: string): Promise<any>;
export declare function deleteUnavailableAsync(): Promise<any>;
export declare function simctlAsync([command, ...args]: (string | undefined)[], options?: SpawnOptions): Promise<any>;
/**
 * I think the app can be open while no simulators are booted.
 */
export declare function isSimulatorAppRunningAsync(): Promise<boolean>;
export declare function openSimulatorAppAsync({ udid }: {
    udid?: string;
}): Promise<import("@expo/spawn-async").SpawnResult>;
export declare function killAllAsync(): Promise<import("@expo/spawn-async").SpawnResult>;
export declare function isLicenseOutOfDate(text: string): boolean;
export declare function isXcrunInstalledAsync(): Promise<boolean>;
export declare function xcrunAsync(args: string[], options?: SpawnOptions): Promise<import("@expo/spawn-async").SpawnResult>;
export declare function xcrunWithLogging(args: string[], options?: SpawnOptions): Promise<import("@expo/spawn-async").SpawnResult>;
export {};

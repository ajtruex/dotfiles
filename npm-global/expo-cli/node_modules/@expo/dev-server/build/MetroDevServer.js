"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const ExpoMetroConfig = __importStar(require("@expo/metro-config"));
const cli_server_api_1 = require("@react-native-community/cli-server-api");
const body_parser_1 = __importDefault(require("body-parser"));
const LogReporter_1 = __importDefault(require("./LogReporter"));
const clientLogsMiddleware_1 = __importDefault(require("./middleware/clientLogsMiddleware"));
async function runMetroDevServerAsync(projectRoot, options) {
    const Metro = importMetroFromProject(projectRoot);
    const reporter = new LogReporter_1.default(options.logger);
    const metroConfig = await ExpoMetroConfig.loadAsync(projectRoot, Object.assign({ reporter }, options));
    const { middleware, attachToServer } = cli_server_api_1.createDevServerMiddleware({
        port: metroConfig.server.port,
        watchFolders: metroConfig.watchFolders,
    });
    middleware.use(body_parser_1.default.json());
    middleware.use('/logs', clientLogsMiddleware_1.default(options.logger));
    const customEnhanceMiddleware = metroConfig.server.enhanceMiddleware;
    // @ts-ignore can't mutate readonly config
    metroConfig.server.enhanceMiddleware = (metroMiddleware, server) => {
        if (customEnhanceMiddleware) {
            metroMiddleware = customEnhanceMiddleware(metroMiddleware, server);
        }
        return middleware.use(metroMiddleware);
    };
    const serverInstance = await Metro.runServer(metroConfig, { hmrEnabled: true });
    const { eventsSocket } = attachToServer(serverInstance);
    reporter.reportEvent = eventsSocket.reportEvent;
    return {
        server: serverInstance,
        middleware,
    };
}
exports.runMetroDevServerAsync = runMetroDevServerAsync;
let nextBuildID = 0;
async function bundleAsync(projectRoot, options, bundles) {
    const metro = importMetroFromProject(projectRoot);
    const Server = importMetroServerFromProject(projectRoot);
    const reporter = new LogReporter_1.default(options.logger);
    const config = await ExpoMetroConfig.loadAsync(projectRoot, Object.assign({ reporter }, options));
    const buildID = `bundle_${nextBuildID++}`;
    const metroServer = await metro.runMetro(config, {
        watch: false,
    });
    const buildAsync = async (bundle) => {
        var _a, _b, _c, _d;
        const bundleOptions = Object.assign(Object.assign({}, Server.DEFAULT_BUNDLE_OPTIONS), { bundleType: 'bundle', platform: bundle.platform, entryFile: bundle.entryPoint, dev: (_a = bundle.dev) !== null && _a !== void 0 ? _a : false, minify: (_b = bundle.minify) !== null && _b !== void 0 ? _b : !bundle.dev, inlineSourceMap: false, sourceMapUrl: bundle.sourceMapUrl, createModuleIdFactory: config.serializer.createModuleIdFactory, onProgress: (transformedFileCount, totalFileCount) => {
                if (!options.quiet) {
                    reporter.update({
                        buildID,
                        type: 'bundle_transform_progressed',
                        transformedFileCount,
                        totalFileCount,
                    });
                }
            } });
        reporter.update({
            buildID,
            type: 'bundle_build_started',
            bundleDetails: {
                bundleType: bundleOptions.bundleType,
                platform: bundle.platform,
                entryFile: bundle.entryPoint,
                dev: (_c = bundle.dev) !== null && _c !== void 0 ? _c : false,
                minify: (_d = bundle.minify) !== null && _d !== void 0 ? _d : false,
            },
        });
        const { code, map } = await metroServer.build(bundleOptions);
        const assets = (await metroServer.getAssets(bundleOptions));
        reporter.update({
            buildID,
            type: 'bundle_build_done',
        });
        return { code, map, assets };
    };
    try {
        return await Promise.all(bundles.map((bundle) => buildAsync(bundle)));
    }
    finally {
        metroServer.end();
    }
}
exports.bundleAsync = bundleAsync;
function importMetroFromProject(projectRoot) {
    const { exp } = config_1.getConfig(projectRoot, { skipSDKVersionRequirement: true });
    const resolvedPath = config_1.projectHasModule('metro', projectRoot, exp);
    if (!resolvedPath) {
        throw new Error('Missing package "metro" in the project at ' +
            projectRoot +
            '. ' +
            'This usually means `react-native` is not installed. ' +
            'Please verify that dependencies in package.json include "react-native" ' +
            'and run `yarn` or `npm install`.');
    }
    return require(resolvedPath);
}
function importMetroServerFromProject(projectRoot) {
    const { exp } = config_1.getConfig(projectRoot, { skipSDKVersionRequirement: true });
    const resolvedPath = config_1.projectHasModule('metro/src/Server', projectRoot, exp);
    if (!resolvedPath) {
        throw new Error('Missing module "metro/src/Server" in the project. ' +
            'This usually means React Native is not installed. ' +
            'Please verify that dependencies in package.json include "react-native" ' +
            'and run `yarn` or `npm install`.');
    }
    return require(resolvedPath);
}
//# sourceMappingURL=MetroDevServer.js.map